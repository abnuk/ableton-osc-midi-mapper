"use strict";
const require$$1$2 = require("electron");
const require$$0$1 = require("path");
const require$$1$1 = require("util");
const require$$0 = require("fs");
const crypto$1 = require("crypto");
const require$$4 = require("assert");
const require$$5 = require("events");
const require$$1 = require("os");
const node_dgram = require("node:dgram");
require("node:events");
function _interopNamespaceDefault(e2) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k2 in e2) {
      if (k2 !== "default") {
        const d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n, k2, d2.get ? d2 : {
          enumerable: true,
          get: () => e2[k2]
        });
      }
    }
  }
  n.default = e2;
  return Object.freeze(n);
}
const require$$0__namespace = /* @__PURE__ */ _interopNamespaceDefault(require$$0$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function(Reflect2) {
  (function(factory) {
    var root = typeof globalThis === "object" ? globalThis : typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter = makeExporter(Reflect2);
    if (typeof root.Reflect !== "undefined") {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter, root);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect2;
    }
    function makeExporter(target, previous) {
      return function(key, value) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value });
        if (previous)
          previous(key, value);
      };
    }
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_2) {
      }
    }
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_2) {
      }
    }
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
  })(function(exporter, root) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata2(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata2);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function OrdinaryHasMetadata(MetadataKey, O2, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O2);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P2);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O2, P2) {
      var provider = GetMetadataProvider(
        O2,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O2, P2));
    }
    function OrdinaryGetMetadata(MetadataKey, O2, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
      var parent = OrdinaryGetPrototypeOf(O2);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P2);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O2, P2) {
      var provider = GetMetadataProvider(
        O2,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2) {
      var provider = GetMetadataProvider(
        O2,
        P2,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2);
    }
    function OrdinaryMetadataKeys(O2, P2) {
      var ownKeys = OrdinaryOwnMetadataKeys(O2, P2);
      var parent = OrdinaryGetPrototypeOf(O2);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P2);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O2, P2) {
      var provider = GetMetadataProvider(
        O2,
        P2,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O2, P2);
    }
    function Type2(x3) {
      if (x3 === null)
        return 1;
      switch (typeof x3) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x3 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x3) {
      return x3 === void 0;
    }
    function IsNull(x3) {
      return x3 === null;
    }
    function IsSymbol(x3) {
      return typeof x3 === "symbol";
    }
    function IsObject(x3) {
      return typeof x3 === "object" ? x3 !== null : typeof x3 === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type2(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = "string";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input);
    }
    function OrdinaryToPrimitive(O2, hint) {
      var valueOf, result, toString_2;
      {
        var toString_1 = O2.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O2);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O2.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O2);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(argument);
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type2(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function SameValueZero(x3, y2) {
      return x3 === y2 || x3 !== x3 && y2 !== y2;
    }
    function GetMethod(V2, P2) {
      var func = V2[P2];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f3 = iterator["return"];
      if (f3)
        f3.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O2) {
      var proto = Object.getPrototypeOf(O2);
      if (typeof O2 !== "function" || O2 === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O2.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O2)
        return proto;
      return constructor;
    }
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root.Reflect);
      }
      var first;
      var second;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first):
            first = provider;
            break;
          case first === provider:
            break;
          case IsUndefined(second):
            second = provider;
            break;
          case second === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      function getProviderNoCache(O2, P2) {
        if (!IsUndefined(first)) {
          if (first.isProviderFor(O2, P2))
            return first;
          if (!IsUndefined(second)) {
            if (second.isProviderFor(O2, P2))
              return first;
            if (!IsUndefined(rest)) {
              var iterator = GetIterator(rest);
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  return void 0;
                }
                var provider = IteratorValue(next);
                if (provider.isProviderFor(O2, P2)) {
                  IteratorClose(iterator);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O2, P2)) {
          return fallback;
        }
        return void 0;
      }
      function getProvider(O2, P2) {
        var providerMap = targetProviderMap.get(O2);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P2);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O2, P2);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O2, providerMap);
          }
          providerMap.set(P2, provider);
        }
        return provider;
      }
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
      }
      function setProvider(O2, P2, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O2, P2);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O2);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O2, providerMap);
          }
          providerMap.set(P2, provider);
        }
        return true;
      }
    }
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        metadataRegistry2 = root.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        Object.defineProperty(root.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    function CreateMetadataProvider(registry) {
      var metadata3 = new _WeakMap();
      var provider = {
        isProviderFor: function(O2, P2) {
          var targetMetadata = metadata3.get(O2);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P2);
        },
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O2, P2, Create) {
        var targetMetadata = metadata3.get(O2);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata3.set(O2, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P2);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P2, metadataMap);
          if (!registry.setProvider(O2, P2, provider)) {
            targetMetadata.delete(P2);
            if (createdTargetMetadata) {
              metadata3.delete(O2);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      function OrdinaryHasOwnMetadata2(MetadataKey, O2, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetOwnMetadata2(MetadataKey, O2, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O2, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P2,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryOwnMetadataKeys2(O2, P2) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k2 = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k2;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k2] = nextValue;
          } catch (e2) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e2;
            }
          }
          k2++;
        }
      }
      function OrdinaryDeleteMetadata(MetadataKey, O2, P2) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P2,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata3.get(O2);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P2);
            if (targetMetadata.size === 0) {
              metadata3.delete(targetMetadata);
            }
          }
        }
        return true;
      }
    }
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: function(O2, P2) {
          var metadataPropertySet = metadataOwner.get(O2);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P2)) {
            return true;
          }
          if (getOwnMetadataKeys2(O2, P2).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O2, metadataPropertySet);
            }
            metadataPropertySet.add(P2);
            return true;
          }
          return false;
        },
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    function GetMetadataProvider(O2, P2, Create) {
      var registeredProvider = metadataRegistry.getProvider(O2, P2);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O2, P2, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error2) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error2;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i2 = index + 1; i2 < size; i2++) {
                this._keys[i2 - 1] = this._keys[i2];
                this._values[i2 - 1] = this._values[i2];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i2 = 0; i2 < this._keys.length; i2++) {
                if (SameValueZero(this._keys[i2], key)) {
                  this._cacheIndex = i2;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _2) {
        return key;
      }
      function getValue(_2, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      var Set2 = (
        /** @class */
        function() {
          function Set3() {
            this._map = new _Map();
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set3.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }()
      );
      return Set2;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i2 = 0; i2 < size; ++i2)
          buffer[i2] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size);
          }
          return array;
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect$1 || (Reflect$1 = {}));
const t$3 = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
let r$1 = class r {
  [t$3];
  #e;
  constructor(e2) {
    this.#e = e2, this[t$3] = true;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[t$3];
  }
  unwrap() {
    return this.#e();
  }
};
function t$2(t2, e2) {
  return Reflect.getMetadata(e2, t2);
}
function e(e2, n, a2, c2) {
  const f3 = c2(t$2(e2, n) ?? a2);
  Reflect.defineMetadata(n, f3, e2);
}
const a$1 = "named", r2 = "name", i = "unmanaged", o = "optional", s$1 = "inject", c$1 = "multi_inject", u$1 = "post_construct", d$1 = "pre_destroy";
const m$1 = [s$1, c$1, r2, i, a$1, o], l$1 = Symbol.for("@inversifyjs/core/InversifyCoreError");
let f$1 = class f extends Error {
  [l$1];
  kind;
  constructor(t2, e2, n) {
    super(e2, n), this[l$1] = true, this.kind = t2;
  }
  static is(t2) {
    return "object" == typeof t2 && null !== t2 && true === t2[l$1];
  }
  static isErrorOfKind(t2, e2) {
    return f.is(t2) && t2.kind === e2;
  }
};
var g$1, p$1;
function h$1(t2, e2) {
  const n = [];
  for (let t3 = 0; t3 < e2.length; ++t3) {
    void 0 === e2[t3] && n.push(t3);
  }
  if (n.length > 0) throw new f$1(g$1.missingInjectionDecorator, `Found unexpected missing metadata on type "${t2.name}" at constructor indexes "${n.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
}
function y$1(t2) {
  return { kind: p$1.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), targetName: void 0, value: t2 };
}
function v(t2) {
  const e2 = t2.find((t3) => t3.key === s$1), n = t2.find((t3) => t3.key === c$1);
  if (void 0 !== t2.find((t3) => t3.key === i)) return function(t3, e3) {
    if (void 0 !== e3 || void 0 !== t3) throw new f$1(g$1.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
    return { kind: p$1.unmanaged };
  }(e2, n);
  if (void 0 === n && void 0 === e2) throw new f$1(g$1.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
  const u2 = t2.find((t3) => t3.key === a$1), d2 = t2.find((t3) => t3.key === o), l2 = t2.find((t3) => t3.key === r2);
  return { kind: void 0 === e2 ? p$1.multipleInjection : p$1.singleInjection, name: u2?.value, optional: void 0 !== d2, tags: new Map(t2.filter((t3) => m$1.every((e3) => t3.key !== e3)).map((t3) => [t3.key, t3.value])), targetName: l2?.value, value: void 0 === e2 ? n?.value : e2.value };
}
function j$1(t2, e2, n) {
  try {
    return v(n);
  } catch (n2) {
    throw f$1.isErrorOfKind(n2, g$1.missingInjectionDecorator) ? new f$1(g$1.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t2.name}" at constructor arguments at index "${e2.toString()}"`, { cause: n2 }) : n2;
  }
}
function k$1(e2) {
  const n = t$2(e2, "design:paramtypes"), a2 = t$2(e2, "inversify:tagged"), r3 = [];
  if (void 0 !== a2) for (const [t2, n2] of Object.entries(a2)) {
    const a3 = parseInt(t2);
    r3[a3] = j$1(e2, a3, n2);
  }
  if (void 0 !== n) {
    for (let t2 = 0; t2 < n.length; ++t2) if (void 0 === r3[t2]) {
      const e3 = n[t2];
      r3[t2] = y$1(e3);
    }
  }
  return h$1(e2, r3), r3;
}
function I$1(t2, e2, n) {
  try {
    return v(n);
  } catch (n2) {
    throw f$1.isErrorOfKind(n2, g$1.missingInjectionDecorator) ? new f$1(g$1.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t2.name}" at property "${e2.toString()}"`, { cause: n2 }) : n2;
  }
}
function w$1(e2) {
  const n = t$2(e2, "inversify:tagged_props"), a2 = /* @__PURE__ */ new Map();
  if (void 0 !== n) for (const t2 of Reflect.ownKeys(n)) {
    const r3 = n[t2];
    a2.set(t2, I$1(e2, t2, r3));
  }
  return a2;
}
function M$1(e2) {
  const n = t$2(e2, u$1), a2 = t$2(e2, d$1);
  return { constructorArguments: k$1(e2), lifecycle: { postConstructMethodName: n?.value, preDestroyMethodName: a2?.value }, properties: w$1(e2) };
}
function N$1(t2, e2) {
  const n = e2.getConstructorMetadata(t2), a2 = [];
  for (const [e3, r3] of Object.entries(n.userGeneratedMetadata)) {
    const n2 = parseInt(e3);
    a2[n2] = j$1(t2, n2, r3);
  }
  if (void 0 !== n.compilerGeneratedMetadata) {
    for (let t3 = 0; t3 < n.compilerGeneratedMetadata.length; ++t3) if (void 0 === a2[t3]) {
      const e3 = n.compilerGeneratedMetadata[t3];
      a2[t3] = y$1(e3);
    }
  }
  return h$1(t2, a2), a2;
}
function E$1(t2, e2) {
  const n = e2.getPropertiesMetadata(t2), a2 = /* @__PURE__ */ new Map();
  for (const e3 of Reflect.ownKeys(n)) {
    const r3 = n[e3];
    a2.set(e3, I$1(t2, e3, r3));
  }
  return a2;
}
function D$1(e2, n) {
  const a2 = t$2(e2, u$1), r3 = t$2(e2, d$1);
  return { constructorArguments: N$1(e2, n), lifecycle: { postConstructMethodName: a2?.value, preDestroyMethodName: r3?.value }, properties: E$1(e2, n) };
}
function b$2(t2) {
  const e2 = Object.getPrototypeOf(t2.prototype), n = e2?.constructor;
  return n;
}
function O$1(t2) {
  return t2.kind === p$1.unmanaged ? [{ key: i, value: true }] : function(t3) {
    const e2 = [A$1(t3)];
    void 0 !== t3.name && e2.push({ key: a$1, value: t3.name });
    t3.optional && e2.push({ key: o, value: true });
    for (const [n, a2] of t3.tags) e2.push({ key: n, value: a2 });
    void 0 !== t3.targetName && e2.push({ key: r2, value: t3.targetName });
    return e2;
  }(t2);
}
function A$1(t2) {
  let e2;
  switch (t2.kind) {
    case p$1.multipleInjection:
      e2 = { key: c$1, value: t2.value };
      break;
    case p$1.singleInjection:
      e2 = { key: s$1, value: t2.value };
  }
  return e2;
}
!function(t2) {
  t2[t2.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", t2[t2.missingInjectionDecorator = 1] = "missingInjectionDecorator", t2[t2.planning = 2] = "planning", t2[t2.unknown = 3] = "unknown";
}(g$1 || (g$1 = {})), function(t2) {
  t2[t2.multipleInjection = 0] = "multipleInjection", t2[t2.singleInjection = 1] = "singleInjection", t2[t2.unmanaged = 2] = "unmanaged";
}(p$1 || (p$1 = {}));
let x$1 = class x {
  #t;
  constructor(t2) {
    this.#t = t2;
  }
  startsWith(t2) {
    return this.#t.startsWith(t2);
  }
  endsWith(t2) {
    return this.#t.endsWith(t2);
  }
  contains(t2) {
    return this.#t.includes(t2);
  }
  equals(t2) {
    return this.#t === t2;
  }
  value() {
    return this.#t;
  }
};
const C$1 = "@inversifyjs/core/targetId";
let T$1 = class T {
  #e;
  #n;
  #a;
  #r;
  #i;
  #o;
  constructor(n, a2, r3) {
    this.#n = function() {
      const n2 = t$2(Object, C$1) ?? 0;
      return n2 === Number.MAX_SAFE_INTEGER ? e(Object, C$1, n2, () => Number.MIN_SAFE_INTEGER) : e(Object, C$1, n2, (t2) => t2 + 1), n2;
    }(), this.#a = n, this.#r = void 0, this.#e = a2, this.#i = new x$1("string" == typeof n ? n : n.toString().slice(7, -1)), this.#o = r3;
  }
  get id() {
    return this.#n;
  }
  get identifier() {
    return this.#a;
  }
  get metadata() {
    return void 0 === this.#r && (this.#r = O$1(this.#e)), this.#r;
  }
  get name() {
    return this.#i;
  }
  get type() {
    return this.#o;
  }
  get serviceIdentifier() {
    return r$1.is(this.#e.value) ? this.#e.value.unwrap() : this.#e.value;
  }
  getCustomTags() {
    return [...this.#e.tags.entries()].map(([t2, e2]) => ({ key: t2, value: e2 }));
  }
  getNamedTag() {
    return void 0 === this.#e.name ? null : { key: a$1, value: this.#e.name };
  }
  hasTag(t2) {
    return this.metadata.some((e2) => e2.key === t2);
  }
  isArray() {
    return this.#e.kind === p$1.multipleInjection;
  }
  isNamed() {
    return void 0 !== this.#e.name;
  }
  isOptional() {
    return this.#e.optional;
  }
  isTagged() {
    return this.#e.tags.size > 0;
  }
  matchesArray(t2) {
    return this.isArray() && this.#e.value === t2;
  }
  matchesNamedTag(t2) {
    return this.#e.name === t2;
  }
  matchesTag(t2) {
    return (e2) => this.metadata.some((n) => n.key === t2 && n.value === e2);
  }
};
const _ = (t2) => /* @__PURE__ */ function(t3, e2) {
  return function(n) {
    const a2 = t3(n);
    let r3 = b$2(n);
    for (; void 0 !== r3 && r3 !== Object; ) {
      const t4 = e2(r3);
      for (const [e3, n2] of t4) a2.properties.has(e3) || a2.properties.set(e3, n2);
      r3 = b$2(r3);
    }
    const i2 = [];
    for (const t4 of a2.constructorArguments) if (t4.kind !== p$1.unmanaged) {
      const e3 = t4.targetName ?? "";
      i2.push(new T$1(e3, t4, "ConstructorArgument"));
    }
    for (const [t4, e3] of a2.properties) if (e3.kind !== p$1.unmanaged) {
      const n2 = e3.targetName ?? t4;
      i2.push(new T$1(n2, e3, "ClassProperty"));
    }
    return i2;
  };
}(void 0 === t2 ? M$1 : (e2) => D$1(e2, t2), void 0 === t2 ? w$1 : (e2) => E$1(e2, t2));
const s = "named", a = "unmanaged", c = "optional", d = "inject", u = "multi_inject", h = "inversify:tagged", l = "inversify:tagged_props", g = "inversify:paramtypes", y = "design:paramtypes", p = "post_construct", f2 = "pre_destroy";
const b$1 = { Request: "Request", Singleton: "Singleton", Transient: "Transient" }, w = { ConstantValue: "ConstantValue", Constructor: "Constructor", DynamicValue: "DynamicValue", Factory: "Factory", Function: "Function", Instance: "Instance", Invalid: "Invalid", Provider: "Provider" }, m = { ConstructorArgument: "ConstructorArgument", Variable: "Variable" };
let A = 0;
function S() {
  return A++;
}
class I {
  id;
  moduleId;
  activated;
  serviceIdentifier;
  implementationType;
  cache;
  dynamicValue;
  scope;
  type;
  factory;
  provider;
  constraint;
  onActivation;
  onDeactivation;
  constructor(t2, n) {
    this.id = S(), this.activated = false, this.serviceIdentifier = t2, this.scope = n, this.type = w.Invalid, this.constraint = (t3) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
  }
  clone() {
    const t2 = new I(this.serviceIdentifier, this.scope);
    return t2.activated = t2.scope === b$1.Singleton && this.activated, t2.implementationType = this.implementationType, t2.dynamicValue = this.dynamicValue, t2.scope = this.scope, t2.type = this.type, t2.factory = this.factory, t2.provider = this.provider, t2.constraint = this.constraint, t2.onActivation = this.onActivation, t2.onDeactivation = this.onDeactivation, t2.cache = this.cache, t2;
  }
}
const T2 = "Metadata key was used more than once in a parameter:", D = "NULL argument", N = "Key Not Found", C = "Ambiguous match found for serviceIdentifier:", x2 = "No matching bindings found for serviceIdentifier:", R = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.", E = (t2, n) => `onDeactivation() error in class ${t2}: ${n}`;
class M {
  getConstructorMetadata(t2) {
    return { compilerGeneratedMetadata: Reflect.getMetadata(y, t2) ?? [], userGeneratedMetadata: Reflect.getMetadata(h, t2) ?? {} };
  }
  getPropertiesMetadata(t2) {
    return Reflect.getMetadata(l, t2) ?? {};
  }
}
var B;
function P(t2) {
  return t2 instanceof RangeError || "Maximum call stack size exceeded" === t2.message;
}
!function(t2) {
  t2[t2.MultipleBindingsAvailable = 2] = "MultipleBindingsAvailable", t2[t2.NoBindingsAvailable = 0] = "NoBindingsAvailable", t2[t2.OnlyOneBindingAvailable = 1] = "OnlyOneBindingAvailable";
}(B || (B = {}));
function k(t2) {
  return "function" == typeof t2 ? t2.name : "symbol" == typeof t2 ? t2.toString() : t2;
}
function q(t2, n, e2) {
  let i2 = "";
  const r3 = e2(t2, n);
  return 0 !== r3.length && (i2 = "\nRegistered bindings:", r3.forEach((t3) => {
    let n2 = "Object";
    null !== t3.implementationType && (n2 = O(t3.implementationType)), i2 = `${i2}
 ${n2}`, t3.constraint.metaData && (i2 = `${i2} - ${t3.constraint.metaData}`);
  })), i2;
}
function F(t2, n) {
  return null !== t2.parentRequest && (t2.parentRequest.serviceIdentifier === n || F(t2.parentRequest, n));
}
function j(t2) {
  t2.childRequests.forEach((n) => {
    if (F(t2, n.serviceIdentifier)) {
      const t3 = function(t4) {
        const n2 = function t5(n3, e2 = []) {
          const i2 = k(n3.serviceIdentifier);
          return e2.push(i2), null !== n3.parentRequest ? t5(n3.parentRequest, e2) : e2;
        }(t4);
        return n2.reverse().join(" --> ");
      }(n);
      throw new Error(`Circular dependency found: ${t3}`);
    }
    j(n);
  });
}
function O(t2) {
  if (null != t2.name && "" !== t2.name) return t2.name;
  {
    const n = t2.toString(), e2 = n.match(/^function\s*([^\s(]+)/);
    return null === e2 ? `Anonymous function: ${n}` : e2[1];
  }
}
function $(t2) {
  return `{"key":"${t2.key.toString()}","value":"${t2.value.toString()}"}`;
}
class V {
  id;
  container;
  plan;
  currentRequest;
  constructor(t2) {
    this.id = S(), this.container = t2;
  }
  addPlan(t2) {
    this.plan = t2;
  }
  setCurrentRequest(t2) {
    this.currentRequest = t2;
  }
}
class W {
  key;
  value;
  constructor(t2, n) {
    this.key = t2, this.value = n;
  }
  toString() {
    return this.key === s ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
}
class G {
  parentContext;
  rootRequest;
  constructor(t2, n) {
    this.parentContext = t2, this.rootRequest = n;
  }
}
function K(t2, e2) {
  const i2 = function(t3) {
    const n = Object.getPrototypeOf(t3.prototype), e3 = n?.constructor;
    return e3;
  }(e2);
  if (void 0 === i2 || i2 === Object) return 0;
  const r3 = _(t2)(i2), s2 = r3.map((t3) => t3.metadata.filter((t4) => t4.key === a)), o2 = [].concat.apply([], s2).length, c2 = r3.length - o2;
  return c2 > 0 ? c2 : K(t2, i2);
}
class H {
  id;
  serviceIdentifier;
  parentContext;
  parentRequest;
  bindings;
  childRequests;
  target;
  requestScope;
  constructor(t2, n, e2, i2, r3) {
    this.id = S(), this.serviceIdentifier = t2, this.parentContext = n, this.parentRequest = e2, this.target = r3, this.childRequests = [], this.bindings = Array.isArray(i2) ? i2 : [i2], this.requestScope = null === e2 ? /* @__PURE__ */ new Map() : null;
  }
  addChildRequest(t2, n, e2) {
    const i2 = new H(t2, this.parentContext, this, n, e2);
    return this.childRequests.push(i2), i2;
  }
}
function U(t2) {
  return t2._bindingDictionary;
}
function L(t2, n, e2, i2, r3) {
  let s2 = J(e2.container, r3.serviceIdentifier), o2 = [];
  return s2.length === B.NoBindingsAvailable && true === e2.container.options.autoBindInjectable && "function" == typeof r3.serviceIdentifier && t2.getConstructorMetadata(r3.serviceIdentifier).compilerGeneratedMetadata && (e2.container.bind(r3.serviceIdentifier).toSelf(), s2 = J(e2.container, r3.serviceIdentifier)), o2 = n ? s2 : s2.filter((t3) => {
    const n2 = new H(t3.serviceIdentifier, e2, i2, t3, r3);
    return t3.constraint(n2);
  }), function(t3, n2, e3, i3, r4) {
    switch (n2.length) {
      case B.NoBindingsAvailable:
        if (i3.isOptional()) return n2;
        {
          const n3 = k(t3);
          let s3 = x2;
          throw s3 += function(t4, n4) {
            if (n4.isTagged() || n4.isNamed()) {
              let e4 = "";
              const i4 = n4.getNamedTag(), r5 = n4.getCustomTags();
              return null !== i4 && (e4 += $(i4) + "\n"), null !== r5 && r5.forEach((t5) => {
                e4 += $(t5) + "\n";
              }), ` ${t4}
 ${t4} - ${e4}`;
            }
            return ` ${t4}`;
          }(n3, i3), s3 += q(r4, n3, J), null !== e3 && (s3 += `
Trying to resolve bindings for "${k(e3.serviceIdentifier)}"`), new Error(s3);
        }
      case B.OnlyOneBindingAvailable:
        return n2;
      case B.MultipleBindingsAvailable:
      default:
        if (i3.isArray()) return n2;
        {
          const n3 = k(t3);
          let e4 = `${C} ${n3}`;
          throw e4 += q(r4, n3, J), new Error(e4);
        }
    }
  }(r3.serviceIdentifier, o2, i2, r3, e2.container), o2;
}
function Y(t2, n) {
  const e2 = n.isMultiInject ? u : d, i2 = [new W(e2, t2)];
  return void 0 !== n.customTag && i2.push(new W(n.customTag.key, n.customTag.value)), true === n.isOptional && i2.push(new W(c, true)), i2;
}
function z(t2, e2, i2, r3, s2, o2) {
  let a2, c2;
  if (null === s2) {
    a2 = L(t2, e2, r3, null, o2), c2 = new H(i2, r3, null, a2, o2);
    const n = new G(r3, c2);
    r3.addPlan(n);
  } else a2 = L(t2, e2, r3, s2, o2), c2 = s2.addChildRequest(o2.serviceIdentifier, a2, o2);
  a2.forEach((e3) => {
    let i3 = null;
    if (o2.isArray()) i3 = c2.addChildRequest(e3.serviceIdentifier, e3, o2);
    else {
      if (null !== e3.cache) return;
      i3 = c2;
    }
    if (e3.type === w.Instance && null !== e3.implementationType) {
      const s3 = function(t3, e4) {
        return _(t3)(e4);
      }(t2, e3.implementationType);
      if (true !== r3.container.options.skipBaseClassChecks) {
        const n = K(t2, e3.implementationType);
        if (s3.length < n) {
          const t3 = `The number of constructor arguments in the derived class ${O(e3.implementationType)} must be >= than the number of constructor arguments of its base class.`;
          throw new Error(t3);
        }
      }
      s3.forEach((n) => {
        z(t2, false, n.serviceIdentifier, r3, i3, n);
      });
    }
  });
}
function J(t2, n) {
  let e2 = [];
  const i2 = U(t2);
  return i2.hasKey(n) ? e2 = i2.get(n) : null !== t2.parent && (e2 = J(t2.parent, n)), e2;
}
function Q(t2, n, s2, o2, a2, c2 = false) {
  const d2 = new V(n), u2 = function(t3, n2, s3) {
    const o3 = Y(n2, s3), a3 = v(o3);
    if (a3.kind === p$1.unmanaged) throw new Error("Unexpected metadata when creating target");
    return new T$1("", a3, t3);
  }(s2, o2, a2);
  try {
    return z(t2, c2, o2, d2, null, u2), d2;
  } catch (t3) {
    throw P(t3) && j(d2.plan.rootRequest), t3;
  }
}
function X(t2) {
  return ("object" == typeof t2 && null !== t2 || "function" == typeof t2) && "function" == typeof t2.then;
}
function Z(t2) {
  return !!X(t2) || Array.isArray(t2) && t2.some(X);
}
const tt = (t2, n, e2) => {
  t2.has(n.id) || t2.set(n.id, e2);
}, nt = (t2, n) => {
  t2.cache = n, t2.activated = true, X(n) && et(t2, n);
}, et = async (t2, n) => {
  try {
    const e2 = await n;
    t2.cache = e2;
  } catch (n2) {
    throw t2.cache = null, t2.activated = false, n2;
  }
};
var it;
!function(t2) {
  t2.DynamicValue = "toDynamicValue", t2.Factory = "toFactory", t2.Provider = "toProvider";
}(it || (it = {}));
function st(t2, n, e2) {
  let i2;
  if (n.length > 0) {
    const r3 = function(t3, n2) {
      return t3.reduce((t4, e3) => {
        const i3 = n2(e3);
        return e3.target.type === m.ConstructorArgument ? t4.constructorInjections.push(i3) : (t4.propertyRequests.push(e3), t4.propertyInjections.push(i3)), t4.isAsync || (t4.isAsync = Z(i3)), t4;
      }, { constructorInjections: [], isAsync: false, propertyInjections: [], propertyRequests: [] });
    }(n, e2), s2 = { ...r3, constr: t2 };
    i2 = r3.isAsync ? async function(t3) {
      const n2 = await at(t3.constructorInjections), e3 = await at(t3.propertyInjections);
      return ot({ ...t3, constructorInjections: n2, propertyInjections: e3 });
    }(s2) : ot(s2);
  } else i2 = new t2();
  return i2;
}
function ot(t2) {
  const n = new t2.constr(...t2.constructorInjections);
  return t2.propertyRequests.forEach((e2, i2) => {
    const r3 = e2.target.identifier, s2 = t2.propertyInjections[i2];
    e2.target.isOptional() && void 0 === s2 || (n[r3] = s2);
  }), n;
}
async function at(t2) {
  const n = [];
  for (const e2 of t2) Array.isArray(e2) ? n.push(Promise.all(e2)) : n.push(e2);
  return Promise.all(n);
}
function ct(t2, n) {
  const e2 = function(t3, n2) {
    if (Reflect.hasMetadata(p, t3)) {
      const r3 = Reflect.getMetadata(p, t3);
      try {
        return n2[r3.value]?.();
      } catch (n3) {
        if (n3 instanceof Error) throw new Error((e3 = t3.name, i2 = n3.message, `@postConstruct error in class ${e3}: ${i2}`));
      }
    }
    var e3, i2;
  }(t2, n);
  return X(e2) ? e2.then(() => n) : n;
}
function dt(t2, n) {
  t2.scope !== b$1.Singleton && function(t3, n2) {
    const e2 = `Class cannot be instantiated in ${t3.scope === b$1.Request ? "request" : "transient"} scope.`;
    if ("function" == typeof t3.onDeactivation) throw new Error(E(n2.name, e2));
    if (Reflect.hasMetadata(f2, n2)) throw new Error(`@preDestroy error in class ${n2.name}: ${e2}`);
  }(t2, n);
}
const ut = (t2) => (n) => {
  n.parentContext.setCurrentRequest(n);
  const e2 = n.bindings, i2 = n.childRequests, r3 = n.target && n.target.isArray(), s2 = !(n.parentRequest && n.parentRequest.target && n.target && n.parentRequest.target.matchesArray(n.target.serviceIdentifier));
  if (r3 && s2) return i2.map((n2) => ut(t2)(n2));
  {
    if (n.target.isOptional() && 0 === e2.length) return;
    const i3 = e2[0];
    return yt(t2, n, i3);
  }
}, ht = (t2, n) => {
  const e2 = ((t3) => {
    switch (t3.type) {
      case w.Factory:
        return { factory: t3.factory, factoryType: it.Factory };
      case w.Provider:
        return { factory: t3.provider, factoryType: it.Provider };
      case w.DynamicValue:
        return { factory: t3.dynamicValue, factoryType: it.DynamicValue };
      default:
        throw new Error(`Unexpected factory type ${t3.type}`);
    }
  })(t2);
  return ((t3, n2) => {
    try {
      return t3();
    } catch (t4) {
      if (P(t4)) throw n2();
      throw t4;
    }
  })(() => e2.factory.bind(t2)(n), () => {
    return new Error((t3 = e2.factoryType, i2 = n.currentRequest.serviceIdentifier.toString(), `It looks like there is a circular dependency in one of the '${t3}' bindings. Please investigate bindings with service identifier '${i2}'.`));
    var t3, i2;
  });
}, lt$4 = (t2, n, e2) => {
  let i2;
  const r3 = n.childRequests;
  switch (((t3) => {
    let n2 = null;
    switch (t3.type) {
      case w.ConstantValue:
      case w.Function:
        n2 = t3.cache;
        break;
      case w.Constructor:
      case w.Instance:
        n2 = t3.implementationType;
        break;
      case w.DynamicValue:
        n2 = t3.dynamicValue;
        break;
      case w.Provider:
        n2 = t3.provider;
        break;
      case w.Factory:
        n2 = t3.factory;
    }
    if (null === n2) {
      const n3 = k(t3.serviceIdentifier);
      throw new Error(`Invalid binding type: ${n3}`);
    }
  })(e2), e2.type) {
    case w.ConstantValue:
    case w.Function:
      i2 = e2.cache;
      break;
    case w.Constructor:
      i2 = e2.implementationType;
      break;
    case w.Instance:
      i2 = function(t3, n2, e3, i3) {
        dt(t3, n2);
        const r4 = st(n2, e3, i3);
        return X(r4) ? r4.then((t4) => ct(n2, t4)) : ct(n2, r4);
      }(e2, e2.implementationType, r3, ut(t2));
      break;
    default:
      i2 = ht(e2, n.parentContext);
  }
  return i2;
}, gt$5 = (t2, n, e2) => {
  let i2 = ((t3, n2) => n2.scope === b$1.Singleton && n2.activated ? n2.cache : n2.scope === b$1.Request && t3.has(n2.id) ? t3.get(n2.id) : null)(t2, n);
  return null !== i2 || (i2 = e2(), ((t3, n2, e3) => {
    n2.scope === b$1.Singleton && nt(n2, e3), n2.scope === b$1.Request && tt(t3, n2, e3);
  })(t2, n, i2)), i2;
}, yt = (t2, n, e2) => gt$5(t2, e2, () => {
  let i2 = lt$4(t2, n, e2);
  return i2 = X(i2) ? i2.then((t3) => pt(n, e2, t3)) : pt(n, e2, i2), i2;
});
function pt(t2, n, e2) {
  let i2 = ft(t2.parentContext, n, e2);
  const r3 = wt(t2.parentContext.container);
  let s2, o2 = r3.next();
  do {
    s2 = o2.value;
    const n2 = t2.parentContext, e3 = t2.serviceIdentifier, a2 = bt(s2, e3);
    i2 = X(i2) ? vt(a2, n2, i2) : _t(a2, n2, i2), o2 = r3.next();
  } while (true !== o2.done && !U(s2).hasKey(t2.serviceIdentifier));
  return i2;
}
const ft = (t2, n, e2) => {
  let i2;
  return i2 = "function" == typeof n.onActivation ? n.onActivation(t2, e2) : e2, i2;
}, _t = (t2, n, e2) => {
  let i2 = t2.next();
  for (; true !== i2.done; ) {
    if (X(e2 = i2.value(n, e2))) return vt(t2, n, e2);
    i2 = t2.next();
  }
  return e2;
}, vt = async (t2, n, e2) => {
  let i2 = await e2, r3 = t2.next();
  for (; true !== r3.done; ) i2 = await r3.value(n, i2), r3 = t2.next();
  return i2;
}, bt = (t2, n) => {
  const e2 = t2._activations;
  return e2.hasKey(n) ? e2.get(n).values() : [].values();
}, wt = (t2) => {
  const n = [t2];
  let e2 = t2.parent;
  for (; null !== e2; ) n.push(e2), e2 = e2.parent;
  return { next: () => {
    const t3 = n.pop();
    return void 0 !== t3 ? { done: false, value: t3 } : { done: true, value: void 0 };
  } };
};
const mt = (t2, n) => {
  const e2 = t2.parentRequest;
  return null !== e2 && (!!n(e2) || mt(e2, n));
}, At = (t2) => (n) => {
  const e2 = (e3) => null !== e3 && null !== e3.target && e3.target.matchesTag(t2)(n);
  return e2.metaData = new W(t2, n), e2;
}, St = At(s), It = (t2) => (n) => {
  let e2 = null;
  if (null !== n) {
    if (e2 = n.bindings[0], "string" == typeof t2) return e2.serviceIdentifier === t2;
    {
      const e3 = n.bindings[0].implementationType;
      return t2 === e3;
    }
  }
  return false;
};
class Tt {
  _binding;
  constructor(t2) {
    this._binding = t2;
  }
  when(t2) {
    return this._binding.constraint = t2, new Dt(this._binding);
  }
  whenTargetNamed(t2) {
    return this._binding.constraint = St(t2), new Dt(this._binding);
  }
  whenTargetIsDefault() {
    return this._binding.constraint = (t2) => {
      if (null === t2) return false;
      return null !== t2.target && !t2.target.isNamed() && !t2.target.isTagged();
    }, new Dt(this._binding);
  }
  whenTargetTagged(t2, n) {
    return this._binding.constraint = At(t2)(n), new Dt(this._binding);
  }
  whenInjectedInto(t2) {
    return this._binding.constraint = (n) => null !== n && It(t2)(n.parentRequest), new Dt(this._binding);
  }
  whenParentNamed(t2) {
    return this._binding.constraint = (n) => null !== n && St(t2)(n.parentRequest), new Dt(this._binding);
  }
  whenParentTagged(t2, n) {
    return this._binding.constraint = (e2) => null !== e2 && At(t2)(n)(e2.parentRequest), new Dt(this._binding);
  }
  whenAnyAncestorIs(t2) {
    return this._binding.constraint = (n) => null !== n && mt(n, It(t2)), new Dt(this._binding);
  }
  whenNoAncestorIs(t2) {
    return this._binding.constraint = (n) => null !== n && !mt(n, It(t2)), new Dt(this._binding);
  }
  whenAnyAncestorNamed(t2) {
    return this._binding.constraint = (n) => null !== n && mt(n, St(t2)), new Dt(this._binding);
  }
  whenNoAncestorNamed(t2) {
    return this._binding.constraint = (n) => null !== n && !mt(n, St(t2)), new Dt(this._binding);
  }
  whenAnyAncestorTagged(t2, n) {
    return this._binding.constraint = (e2) => null !== e2 && mt(e2, At(t2)(n)), new Dt(this._binding);
  }
  whenNoAncestorTagged(t2, n) {
    return this._binding.constraint = (e2) => null !== e2 && !mt(e2, At(t2)(n)), new Dt(this._binding);
  }
  whenAnyAncestorMatches(t2) {
    return this._binding.constraint = (n) => null !== n && mt(n, t2), new Dt(this._binding);
  }
  whenNoAncestorMatches(t2) {
    return this._binding.constraint = (n) => null !== n && !mt(n, t2), new Dt(this._binding);
  }
}
class Dt {
  _binding;
  constructor(t2) {
    this._binding = t2;
  }
  onActivation(t2) {
    return this._binding.onActivation = t2, new Tt(this._binding);
  }
  onDeactivation(t2) {
    return this._binding.onDeactivation = t2, new Tt(this._binding);
  }
}
class Nt {
  _bindingWhenSyntax;
  _bindingOnSyntax;
  _binding;
  constructor(t2) {
    this._binding = t2, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding);
  }
  when(t2) {
    return this._bindingWhenSyntax.when(t2);
  }
  whenTargetNamed(t2) {
    return this._bindingWhenSyntax.whenTargetNamed(t2);
  }
  whenTargetIsDefault() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  }
  whenTargetTagged(t2, n) {
    return this._bindingWhenSyntax.whenTargetTagged(t2, n);
  }
  whenInjectedInto(t2) {
    return this._bindingWhenSyntax.whenInjectedInto(t2);
  }
  whenParentNamed(t2) {
    return this._bindingWhenSyntax.whenParentNamed(t2);
  }
  whenParentTagged(t2, n) {
    return this._bindingWhenSyntax.whenParentTagged(t2, n);
  }
  whenAnyAncestorIs(t2) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(t2);
  }
  whenNoAncestorIs(t2) {
    return this._bindingWhenSyntax.whenNoAncestorIs(t2);
  }
  whenAnyAncestorNamed(t2) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(t2);
  }
  whenAnyAncestorTagged(t2, n) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(t2, n);
  }
  whenNoAncestorNamed(t2) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(t2);
  }
  whenNoAncestorTagged(t2, n) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(t2, n);
  }
  whenAnyAncestorMatches(t2) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(t2);
  }
  whenNoAncestorMatches(t2) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(t2);
  }
  onActivation(t2) {
    return this._bindingOnSyntax.onActivation(t2);
  }
  onDeactivation(t2) {
    return this._bindingOnSyntax.onDeactivation(t2);
  }
}
class Ct {
  _binding;
  constructor(t2) {
    this._binding = t2;
  }
  inRequestScope() {
    return this._binding.scope = b$1.Request, new Nt(this._binding);
  }
  inSingletonScope() {
    return this._binding.scope = b$1.Singleton, new Nt(this._binding);
  }
  inTransientScope() {
    return this._binding.scope = b$1.Transient, new Nt(this._binding);
  }
}
class xt {
  _bindingInSyntax;
  _bindingWhenSyntax;
  _bindingOnSyntax;
  _binding;
  constructor(t2) {
    this._binding = t2, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding), this._bindingInSyntax = new Ct(t2);
  }
  inRequestScope() {
    return this._bindingInSyntax.inRequestScope();
  }
  inSingletonScope() {
    return this._bindingInSyntax.inSingletonScope();
  }
  inTransientScope() {
    return this._bindingInSyntax.inTransientScope();
  }
  when(t2) {
    return this._bindingWhenSyntax.when(t2);
  }
  whenTargetNamed(t2) {
    return this._bindingWhenSyntax.whenTargetNamed(t2);
  }
  whenTargetIsDefault() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  }
  whenTargetTagged(t2, n) {
    return this._bindingWhenSyntax.whenTargetTagged(t2, n);
  }
  whenInjectedInto(t2) {
    return this._bindingWhenSyntax.whenInjectedInto(t2);
  }
  whenParentNamed(t2) {
    return this._bindingWhenSyntax.whenParentNamed(t2);
  }
  whenParentTagged(t2, n) {
    return this._bindingWhenSyntax.whenParentTagged(t2, n);
  }
  whenAnyAncestorIs(t2) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(t2);
  }
  whenNoAncestorIs(t2) {
    return this._bindingWhenSyntax.whenNoAncestorIs(t2);
  }
  whenAnyAncestorNamed(t2) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(t2);
  }
  whenAnyAncestorTagged(t2, n) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(t2, n);
  }
  whenNoAncestorNamed(t2) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(t2);
  }
  whenNoAncestorTagged(t2, n) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(t2, n);
  }
  whenAnyAncestorMatches(t2) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(t2);
  }
  whenNoAncestorMatches(t2) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(t2);
  }
  onActivation(t2) {
    return this._bindingOnSyntax.onActivation(t2);
  }
  onDeactivation(t2) {
    return this._bindingOnSyntax.onDeactivation(t2);
  }
}
class Rt {
  _binding;
  constructor(t2) {
    this._binding = t2;
  }
  to(t2) {
    return this._binding.type = w.Instance, this._binding.implementationType = t2, new xt(this._binding);
  }
  toSelf() {
    if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
    const t2 = this._binding.serviceIdentifier;
    return this.to(t2);
  }
  toConstantValue(t2) {
    return this._binding.type = w.ConstantValue, this._binding.cache = t2, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = b$1.Singleton, new Nt(this._binding);
  }
  toDynamicValue(t2) {
    return this._binding.type = w.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = t2, this._binding.implementationType = null, new xt(this._binding);
  }
  toConstructor(t2) {
    return this._binding.type = w.Constructor, this._binding.implementationType = t2, this._binding.scope = b$1.Singleton, new Nt(this._binding);
  }
  toFactory(t2) {
    return this._binding.type = w.Factory, this._binding.factory = t2, this._binding.scope = b$1.Singleton, new Nt(this._binding);
  }
  toFunction(t2) {
    if ("function" != typeof t2) throw new Error("Value provided to function binding must be a function!");
    const n = this.toConstantValue(t2);
    return this._binding.type = w.Function, this._binding.scope = b$1.Singleton, n;
  }
  toAutoFactory(t2) {
    return this._binding.type = w.Factory, this._binding.factory = (n) => () => n.container.get(t2), this._binding.scope = b$1.Singleton, new Nt(this._binding);
  }
  toAutoNamedFactory(t2) {
    return this._binding.type = w.Factory, this._binding.factory = (n) => (e2) => n.container.getNamed(t2, e2), new Nt(this._binding);
  }
  toProvider(t2) {
    return this._binding.type = w.Provider, this._binding.provider = t2, this._binding.scope = b$1.Singleton, new Nt(this._binding);
  }
  toService(t2) {
    this._binding.type = w.DynamicValue, Object.defineProperty(this._binding, "cache", { configurable: true, enumerable: true, get: () => null, set(t3) {
    } }), this._binding.dynamicValue = (n) => {
      try {
        return n.container.get(t2);
      } catch (e2) {
        return n.container.getAsync(t2);
      }
    }, this._binding.implementationType = null;
  }
}
class Et {
  bindings;
  activations;
  deactivations;
  middleware;
  moduleActivationStore;
  static of(t2, n, e2, i2, r3) {
    const s2 = new Et();
    return s2.bindings = t2, s2.middleware = n, s2.deactivations = i2, s2.activations = e2, s2.moduleActivationStore = r3, s2;
  }
}
class Mt {
  _map;
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  getMap() {
    return this._map;
  }
  add(t2, n) {
    if (this._checkNonNulish(t2), null == n) throw new Error(D);
    const e2 = this._map.get(t2);
    void 0 !== e2 ? e2.push(n) : this._map.set(t2, [n]);
  }
  get(t2) {
    this._checkNonNulish(t2);
    const n = this._map.get(t2);
    if (void 0 !== n) return n;
    throw new Error(N);
  }
  remove(t2) {
    if (this._checkNonNulish(t2), !this._map.delete(t2)) throw new Error(N);
  }
  removeIntersection(t2) {
    this.traverse((n, e2) => {
      const i2 = t2.hasKey(n) ? t2.get(n) : void 0;
      if (void 0 !== i2) {
        const t3 = e2.filter((t4) => !i2.some((n2) => t4 === n2));
        this._setValue(n, t3);
      }
    });
  }
  removeByCondition(t2) {
    const n = [];
    return this._map.forEach((e2, i2) => {
      const r3 = [];
      for (const i3 of e2) {
        t2(i3) ? n.push(i3) : r3.push(i3);
      }
      this._setValue(i2, r3);
    }), n;
  }
  hasKey(t2) {
    return this._checkNonNulish(t2), this._map.has(t2);
  }
  clone() {
    const t2 = new Mt();
    return this._map.forEach((n, e2) => {
      n.forEach((n2) => {
        var i2;
        t2.add(e2, "object" == typeof (i2 = n2) && null !== i2 && "clone" in i2 && "function" == typeof i2.clone ? n2.clone() : n2);
      });
    }), t2;
  }
  traverse(t2) {
    this._map.forEach((n, e2) => {
      t2(e2, n);
    });
  }
  _checkNonNulish(t2) {
    if (null == t2) throw new Error(D);
  }
  _setValue(t2, n) {
    n.length > 0 ? this._map.set(t2, n) : this._map.delete(t2);
  }
}
class Bt {
  _map = /* @__PURE__ */ new Map();
  remove(t2) {
    const n = this._map.get(t2);
    return void 0 === n ? this._getEmptyHandlersStore() : (this._map.delete(t2), n);
  }
  addDeactivation(t2, n, e2) {
    this._getModuleActivationHandlers(t2).onDeactivations.add(n, e2);
  }
  addActivation(t2, n, e2) {
    this._getModuleActivationHandlers(t2).onActivations.add(n, e2);
  }
  clone() {
    const t2 = new Bt();
    return this._map.forEach((n, e2) => {
      t2._map.set(e2, { onActivations: n.onActivations.clone(), onDeactivations: n.onDeactivations.clone() });
    }), t2;
  }
  _getModuleActivationHandlers(t2) {
    let n = this._map.get(t2);
    return void 0 === n && (n = this._getEmptyHandlersStore(), this._map.set(t2, n)), n;
  }
  _getEmptyHandlersStore() {
    return { onActivations: new Mt(), onDeactivations: new Mt() };
  }
}
class Pt {
  id;
  parent;
  options;
  _middleware;
  _bindingDictionary;
  _activations;
  _deactivations;
  _snapshots;
  _metadataReader;
  _moduleActivationStore;
  constructor(t2) {
    const n = t2 || {};
    if ("object" != typeof n) throw new Error("Invalid Container constructor argument. Container options must be an object.");
    if (void 0 === n.defaultScope) n.defaultScope = b$1.Transient;
    else if (n.defaultScope !== b$1.Singleton && n.defaultScope !== b$1.Transient && n.defaultScope !== b$1.Request) throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');
    if (void 0 === n.autoBindInjectable) n.autoBindInjectable = false;
    else if ("boolean" != typeof n.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
    if (void 0 === n.skipBaseClassChecks) n.skipBaseClassChecks = false;
    else if ("boolean" != typeof n.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
    this.options = { autoBindInjectable: n.autoBindInjectable, defaultScope: n.defaultScope, skipBaseClassChecks: n.skipBaseClassChecks }, this.id = S(), this._bindingDictionary = new Mt(), this._snapshots = [], this._middleware = null, this._activations = new Mt(), this._deactivations = new Mt(), this.parent = null, this._metadataReader = new M(), this._moduleActivationStore = new Bt();
  }
  static merge(t2, n, ...e2) {
    const i2 = new Pt(), r3 = [t2, n, ...e2].map((t3) => U(t3)), s2 = U(i2);
    return r3.forEach((t3) => {
      var n2;
      n2 = s2, t3.traverse((t4, e3) => {
        e3.forEach((t5) => {
          n2.add(t5.serviceIdentifier, t5.clone());
        });
      });
    }), i2;
  }
  load(...t2) {
    const n = this._getContainerModuleHelpersFactory();
    for (const e2 of t2) {
      const t3 = n(e2.id);
      e2.registry(t3.bindFunction, t3.unbindFunction, t3.isboundFunction, t3.rebindFunction, t3.unbindAsyncFunction, t3.onActivationFunction, t3.onDeactivationFunction);
    }
  }
  async loadAsync(...t2) {
    const n = this._getContainerModuleHelpersFactory();
    for (const e2 of t2) {
      const t3 = n(e2.id);
      await e2.registry(t3.bindFunction, t3.unbindFunction, t3.isboundFunction, t3.rebindFunction, t3.unbindAsyncFunction, t3.onActivationFunction, t3.onDeactivationFunction);
    }
  }
  unload(...t2) {
    t2.forEach((t3) => {
      const n = this._removeModuleBindings(t3.id);
      this._deactivateSingletons(n), this._removeModuleHandlers(t3.id);
    });
  }
  async unloadAsync(...t2) {
    for (const n of t2) {
      const t3 = this._removeModuleBindings(n.id);
      await this._deactivateSingletonsAsync(t3), this._removeModuleHandlers(n.id);
    }
  }
  bind(t2) {
    return this._bind(this._buildBinding(t2));
  }
  rebind(t2) {
    return this.unbind(t2), this.bind(t2);
  }
  async rebindAsync(t2) {
    return await this.unbindAsync(t2), this.bind(t2);
  }
  unbind(t2) {
    if (this._bindingDictionary.hasKey(t2)) {
      const n = this._bindingDictionary.get(t2);
      this._deactivateSingletons(n);
    }
    this._removeServiceFromDictionary(t2);
  }
  async unbindAsync(t2) {
    if (this._bindingDictionary.hasKey(t2)) {
      const n = this._bindingDictionary.get(t2);
      await this._deactivateSingletonsAsync(n);
    }
    this._removeServiceFromDictionary(t2);
  }
  unbindAll() {
    this._bindingDictionary.traverse((t2, n) => {
      this._deactivateSingletons(n);
    }), this._bindingDictionary = new Mt();
  }
  async unbindAllAsync() {
    const t2 = [];
    this._bindingDictionary.traverse((n, e2) => {
      t2.push(this._deactivateSingletonsAsync(e2));
    }), await Promise.all(t2), this._bindingDictionary = new Mt();
  }
  onActivation(t2, n) {
    this._activations.add(t2, n);
  }
  onDeactivation(t2, n) {
    this._deactivations.add(t2, n);
  }
  isBound(t2) {
    let n = this._bindingDictionary.hasKey(t2);
    return !n && this.parent && (n = this.parent.isBound(t2)), n;
  }
  isCurrentBound(t2) {
    return this._bindingDictionary.hasKey(t2);
  }
  isBoundNamed(t2, n) {
    return this.isBoundTagged(t2, s, n);
  }
  isBoundTagged(t2, n, s2) {
    let o2 = false;
    if (this._bindingDictionary.hasKey(t2)) {
      const a2 = this._bindingDictionary.get(t2), c2 = function(t3, n2, s3) {
        const o3 = Y(n2, s3), a3 = v(o3);
        if (a3.kind === p$1.unmanaged) throw new Error("Unexpected metadata when creating target");
        const c3 = new T$1("", a3, "Variable"), d2 = new V(t3);
        return new H(n2, d2, null, [], c3);
      }(this, t2, { customTag: { key: n, value: s2 }, isMultiInject: false });
      o2 = a2.some((t3) => t3.constraint(c2));
    }
    return !o2 && this.parent && (o2 = this.parent.isBoundTagged(t2, n, s2)), o2;
  }
  snapshot() {
    this._snapshots.push(Et.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
  }
  restore() {
    const t2 = this._snapshots.pop();
    if (void 0 === t2) throw new Error("No snapshot available to restore.");
    this._bindingDictionary = t2.bindings, this._activations = t2.activations, this._deactivations = t2.deactivations, this._middleware = t2.middleware, this._moduleActivationStore = t2.moduleActivationStore;
  }
  createChild(t2) {
    const n = new Pt(t2 || this.options);
    return n.parent = this, n;
  }
  applyMiddleware(...t2) {
    const n = this._middleware ? this._middleware : this._planAndResolve();
    this._middleware = t2.reduce((t3, n2) => n2(t3), n);
  }
  applyCustomMetadataReader(t2) {
    this._metadataReader = t2;
  }
  get(t2) {
    const n = this._getNotAllArgs(t2, false, false);
    return this._getButThrowIfAsync(n);
  }
  async getAsync(t2) {
    const n = this._getNotAllArgs(t2, false, false);
    return this._get(n);
  }
  getTagged(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, false, false, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async getTaggedAsync(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, false, false, n, e2);
    return this._get(i2);
  }
  getNamed(t2, n) {
    return this.getTagged(t2, s, n);
  }
  async getNamedAsync(t2, n) {
    return this.getTaggedAsync(t2, s, n);
  }
  getAll(t2, n) {
    const e2 = this._getAllArgs(t2, n, false);
    return this._getButThrowIfAsync(e2);
  }
  async getAllAsync(t2, n) {
    const e2 = this._getAllArgs(t2, n, false);
    return this._getAll(e2);
  }
  getAllTagged(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, true, false, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async getAllTaggedAsync(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, true, false, n, e2);
    return this._getAll(i2);
  }
  getAllNamed(t2, n) {
    return this.getAllTagged(t2, s, n);
  }
  async getAllNamedAsync(t2, n) {
    return this.getAllTaggedAsync(t2, s, n);
  }
  resolve(t2) {
    const n = this.isBound(t2);
    n || this.bind(t2).toSelf();
    const e2 = this.get(t2);
    return n || this.unbind(t2), e2;
  }
  tryGet(t2) {
    const n = this._getNotAllArgs(t2, false, true);
    return this._getButThrowIfAsync(n);
  }
  async tryGetAsync(t2) {
    const n = this._getNotAllArgs(t2, false, true);
    return this._get(n);
  }
  tryGetTagged(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, false, true, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async tryGetTaggedAsync(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, false, true, n, e2);
    return this._get(i2);
  }
  tryGetNamed(t2, n) {
    return this.tryGetTagged(t2, s, n);
  }
  async tryGetNamedAsync(t2, n) {
    return this.tryGetTaggedAsync(t2, s, n);
  }
  tryGetAll(t2, n) {
    const e2 = this._getAllArgs(t2, n, true);
    return this._getButThrowIfAsync(e2);
  }
  async tryGetAllAsync(t2, n) {
    const e2 = this._getAllArgs(t2, n, true);
    return this._getAll(e2);
  }
  tryGetAllTagged(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, true, true, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async tryGetAllTaggedAsync(t2, n, e2) {
    const i2 = this._getNotAllArgs(t2, true, true, n, e2);
    return this._getAll(i2);
  }
  tryGetAllNamed(t2, n) {
    return this.tryGetAllTagged(t2, s, n);
  }
  async tryGetAllNamedAsync(t2, n) {
    return this.tryGetAllTaggedAsync(t2, s, n);
  }
  _preDestroy(t2, n) {
    if (void 0 !== t2 && Reflect.hasMetadata(f2, t2)) {
      const e2 = Reflect.getMetadata(f2, t2);
      return n[e2.value]?.();
    }
  }
  _removeModuleHandlers(t2) {
    const n = this._moduleActivationStore.remove(t2);
    this._activations.removeIntersection(n.onActivations), this._deactivations.removeIntersection(n.onDeactivations);
  }
  _removeModuleBindings(t2) {
    return this._bindingDictionary.removeByCondition((n) => n.moduleId === t2);
  }
  _deactivate(t2, n) {
    const e2 = null == n ? void 0 : Object.getPrototypeOf(n).constructor;
    try {
      if (this._deactivations.hasKey(t2.serviceIdentifier)) {
        const i3 = this._deactivateContainer(n, this._deactivations.get(t2.serviceIdentifier).values());
        if (X(i3)) return this._handleDeactivationError(i3.then(async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t2, n, e2)), t2.serviceIdentifier);
      }
      const i2 = this._propagateContainerDeactivationThenBindingAndPreDestroy(t2, n, e2);
      if (X(i2)) return this._handleDeactivationError(i2, t2.serviceIdentifier);
    } catch (n2) {
      if (n2 instanceof Error) throw new Error(E(k(t2.serviceIdentifier), n2.message));
    }
  }
  async _handleDeactivationError(t2, n) {
    try {
      await t2;
    } catch (t3) {
      if (t3 instanceof Error) throw new Error(E(k(n), t3.message));
    }
  }
  _deactivateContainer(t2, n) {
    let e2 = n.next();
    for (; "function" == typeof e2.value; ) {
      const i2 = e2.value(t2);
      if (X(i2)) return i2.then(async () => this._deactivateContainerAsync(t2, n));
      e2 = n.next();
    }
  }
  async _deactivateContainerAsync(t2, n) {
    let e2 = n.next();
    for (; "function" == typeof e2.value; ) await e2.value(t2), e2 = n.next();
  }
  _getContainerModuleHelpersFactory() {
    const t2 = (t3) => (n2) => {
      const e3 = this._buildBinding(n2);
      return e3.moduleId = t3, this._bind(e3);
    }, n = () => (t3) => {
      this.unbind(t3);
    }, e2 = () => async (t3) => this.unbindAsync(t3), i2 = () => (t3) => this.isBound(t3), r3 = (n2) => {
      const e3 = t2(n2);
      return (t3) => (this.unbind(t3), e3(t3));
    }, s2 = (t3) => (n2, e3) => {
      this._moduleActivationStore.addActivation(t3, n2, e3), this.onActivation(n2, e3);
    }, o2 = (t3) => (n2, e3) => {
      this._moduleActivationStore.addDeactivation(t3, n2, e3), this.onDeactivation(n2, e3);
    };
    return (a2) => ({ bindFunction: t2(a2), isboundFunction: i2(), onActivationFunction: s2(a2), onDeactivationFunction: o2(a2), rebindFunction: r3(a2), unbindAsyncFunction: e2(), unbindFunction: n() });
  }
  _bind(t2) {
    return this._bindingDictionary.add(t2.serviceIdentifier, t2), new Rt(t2);
  }
  _buildBinding(t2) {
    const n = this.options.defaultScope || b$1.Transient;
    return new I(t2, n);
  }
  async _getAll(t2) {
    return Promise.all(this._get(t2));
  }
  _get(t2) {
    const n = { ...t2, contextInterceptor: (t3) => t3, targetType: m.Variable };
    if (this._middleware) {
      const t3 = this._middleware(n);
      if (null == t3) throw new Error("Invalid return type in middleware. Middleware must return!");
      return t3;
    }
    return this._planAndResolve()(n);
  }
  _getButThrowIfAsync(t2) {
    const n = this._get(t2);
    if (Z(n)) throw new Error(`You are attempting to construct ${function(t3) {
      return "function" == typeof t3 ? `[function/class ${t3.name || "<anonymous>"}]` : "symbol" == typeof t3 ? t3.toString() : `'${t3}'`;
    }(t2.serviceIdentifier)} in a synchronous way but it has asynchronous dependencies.`);
    return n;
  }
  _getAllArgs(t2, n, e2) {
    return { avoidConstraints: !n?.enforceBindingConstraints, isMultiInject: true, isOptional: e2, serviceIdentifier: t2 };
  }
  _getNotAllArgs(t2, n, e2, i2, r3) {
    return { avoidConstraints: false, isMultiInject: n, isOptional: e2, key: i2, serviceIdentifier: t2, value: r3 };
  }
  _getPlanMetadataFromNextArgs(t2) {
    const n = { isMultiInject: t2.isMultiInject };
    return void 0 !== t2.key && (n.customTag = { key: t2.key, value: t2.value }), true === t2.isOptional && (n.isOptional = true), n;
  }
  _planAndResolve() {
    return (t2) => {
      let n = Q(this._metadataReader, this, t2.targetType, t2.serviceIdentifier, this._getPlanMetadataFromNextArgs(t2), t2.avoidConstraints);
      n = t2.contextInterceptor(n);
      const e2 = function(t3) {
        return ut(t3.plan.rootRequest.requestScope)(t3.plan.rootRequest);
      }(n);
      return e2;
    };
  }
  _deactivateIfSingleton(t2) {
    if (t2.activated) return X(t2.cache) ? t2.cache.then((n) => this._deactivate(t2, n)) : this._deactivate(t2, t2.cache);
  }
  _deactivateSingletons(t2) {
    for (const n of t2) {
      if (X(this._deactivateIfSingleton(n))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
    }
  }
  async _deactivateSingletonsAsync(t2) {
    await Promise.all(t2.map(async (t3) => this._deactivateIfSingleton(t3)));
  }
  _propagateContainerDeactivationThenBindingAndPreDestroy(t2, n, e2) {
    return this.parent ? this._deactivate.bind(this.parent)(t2, n) : this._bindingDeactivationAndPreDestroy(t2, n, e2);
  }
  async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(t2, n, e2) {
    this.parent ? await this._deactivate.bind(this.parent)(t2, n) : await this._bindingDeactivationAndPreDestroyAsync(t2, n, e2);
  }
  _removeServiceFromDictionary(t2) {
    try {
      this._bindingDictionary.remove(t2);
    } catch (n) {
      throw new Error(`Could not unbind serviceIdentifier: ${k(t2)}`);
    }
  }
  _bindingDeactivationAndPreDestroy(t2, n, e2) {
    if ("function" == typeof t2.onDeactivation) {
      const i2 = t2.onDeactivation(n);
      if (X(i2)) return i2.then(() => this._preDestroy(e2, n));
    }
    return this._preDestroy(e2, n);
  }
  async _bindingDeactivationAndPreDestroyAsync(t2, n, e2) {
    "function" == typeof t2.onDeactivation && await t2.onDeactivation(n), await this._preDestroy(e2, n);
  }
}
function Ft(t2, n, e2, i2) {
  !function(t3) {
    if (void 0 !== t3) throw new Error(R);
  }(n), Ot(h, t2, e2.toString(), i2);
}
function jt(t2) {
  let n = [];
  if (Array.isArray(t2)) {
    n = t2;
    const e2 = function(t3) {
      const n2 = /* @__PURE__ */ new Set();
      for (const e3 of t3) {
        if (n2.has(e3)) return e3;
        n2.add(e3);
      }
    }(n.map((t3) => t3.key));
    if (void 0 !== e2) throw new Error(`${T2} ${e2.toString()}`);
  } else n = [t2];
  return n;
}
function Ot(t2, n, e2, i2) {
  const r3 = jt(i2);
  let s2 = {};
  Reflect.hasOwnMetadata(t2, n) && (s2 = Reflect.getMetadata(t2, n));
  let o2 = s2[e2];
  if (void 0 === o2) o2 = [];
  else for (const t3 of o2) if (r3.some((n2) => n2.key === t3.key)) throw new Error(`${T2} ${t3.key.toString()}`);
  o2.push(...r3), s2[e2] = o2, Reflect.defineMetadata(t2, s2, n);
}
function $t(t2) {
  return (n, e2, i2) => {
    "number" == typeof i2 ? Ft(n, e2, i2, t2) : function(t3, n2, e3) {
      if (void 0 !== t3.prototype) throw new Error(R);
      Ot(l, t3.constructor, n2, e3);
    }(n, e2, t2);
  };
}
function Kt() {
  return function(t2) {
    if (Reflect.hasOwnMetadata(g, t2)) throw new Error("Cannot apply @injectable decorator multiple times.");
    const n = Reflect.getMetadata(y, t2) || [];
    return Reflect.defineMetadata(g, n, t2), t2;
  };
}
function Lt(t2) {
  return (n) => (e2, i2, r3) => {
    if (void 0 === n) {
      const t3 = "function" == typeof e2 ? e2.name : e2.constructor.name;
      throw new Error(`@inject called with undefined this could mean that the class ${t3} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`);
    }
    $t(new W(t2, n))(e2, i2, r3);
  };
}
const Yt = Lt(d);
const TYPES = {
  // Repositories
  MappingRepository: Symbol.for("IMappingRepository"),
  ConfigRepository: Symbol.for("IConfigRepository"),
  // Services
  MidiInputService: Symbol.for("IMidiInputService"),
  OscOutputService: Symbol.for("IOscOutputService"),
  TrackNameResolver: Symbol.for("ITrackNameResolver"),
  // Use Cases
  CreateMapping: Symbol.for("CreateMapping"),
  DeleteMapping: Symbol.for("DeleteMapping"),
  GetAllMappings: Symbol.for("GetAllMappings"),
  UpdateMapping: Symbol.for("UpdateMapping"),
  ProcessMidiInput: Symbol.for("ProcessMidiInput"),
  StartLearnMode: Symbol.for("StartLearnMode"),
  StopLearnMode: Symbol.for("StopLearnMode"),
  SelectMidiDevice: Symbol.for("SelectMidiDevice"),
  GetMidiDevices: Symbol.for("GetMidiDevices"),
  FetchTrackNames: Symbol.for("FetchTrackNames"),
  GetConfig: Symbol.for("GetConfig"),
  UpdateConfig: Symbol.for("UpdateConfig"),
  TestOscConnection: Symbol.for("TestOscConnection")
};
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i2 = 0; i2 < pathArray.length; i2++) {
    let p2 = pathArray[i2];
    while (p2[p2.length - 1] === "\\" && pathArray[i2 + 1] !== void 0) {
      p2 = p2.slice(0, -1) + ".";
      p2 += pathArray[++i2];
    }
    parts.push(p2);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      object = object[pathArray[i2]];
      if (object === void 0 || object === null) {
        if (i2 !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p2 = pathArray[i2];
      if (!isObj(object[p2])) {
        object[p2] = {};
      }
      if (i2 === pathArray.length - 1) {
        object[p2] = value;
      }
      object = object[p2];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p2 = pathArray[i2];
      if (i2 === pathArray.length - 1) {
        delete object[p2];
        return true;
      }
      object = object[p2];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      if (isObj(object)) {
        if (!(pathArray[i2] in object)) {
          return false;
        }
        object = object[pathArray[i2]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0;
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pathExistsExports = pathExists$1.exports;
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
var pTryExports = pTry$2.exports;
const pTry = pTryExports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.length > 0) {
      queue.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
var pLimitExports = pLimit$2.exports;
const pLimit = pLimitExports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts) => {
  opts = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts);
  const limit2 = pLimit(opts.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$0$1;
const pathExists = pathExistsExports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
var locatePathExports = locatePath$1.exports;
const path$4 = require$$0$1;
const locatePath = locatePathExports;
findUp$1.exports = (filename, opts = {}) => {
  const startDir = path$4.resolve(opts.cwd || "");
  const { root } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file) => {
        if (file) {
          resolve2(path$4.join(dir, file));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts = {}) => {
  let dir = path$4.resolve(opts.cwd || "");
  const { root } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file = locatePath.sync(filenames, { cwd: dir });
    if (file) {
      return path$4.join(dir, file);
    }
    if (dir === root) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
var findUpExports = findUp$1.exports;
const findUp = findUpExports;
pkgUp.exports = async ({ cwd } = {}) => findUp("package.json", { cwd });
pkgUp.exports.sync = ({ cwd } = {}) => findUp.sync("package.json", { cwd });
var pkgUpExports = pkgUp.exports;
var envPaths$1 = { exports: {} };
const path$3 = require$$0$1;
const os = require$$1;
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path$3.join(env.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var envPathsExports = envPaths$1.exports;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: /* @__PURE__ */ new Set(),
  queueWaiting: /* @__PURE__ */ new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0;
const util_1$S = require$$1$1;
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x3) => {
    return typeof x3 === "function";
  },
  isString: (x3) => {
    return typeof x3 === "string";
  },
  isUndefined: (x3) => {
    return typeof x3 === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue = Queues[id2];
    if (!queue)
      return;
    queue.shift();
    const job = queue[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue = Queues[id2];
      if (!queue)
        queue = Queues[id2] = [];
      queue.push(resolve2);
      if (queue.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$0$1;
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$0$1;
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat = await fs_1.default.statAttempt(filePath);
      if (stat) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat.uid, gid: stat.gid };
        if (useStatMode)
          options.mode = stat.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat = fs_1.default.statSyncAttempt(filePath);
      if (stat) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat.uid, gid: stat.gid };
        if (useStatMode)
          options.mode = stat.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv$1 = { exports: {} };
var core$5 = {};
var validate$1 = {};
var boolSchema$1 = {};
var errors$1 = {};
var codegen$1 = {};
var code$3 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports$1._CodeOrName = _CodeOrName;
  exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports$1.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports$1.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c2) => {
        if (c2 instanceof Name)
          names2[c2.str] = (names2[c2.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports$1._Code = _Code;
  exports$1.nil = new _Code("");
  function _2(strs, ...args) {
    const code2 = [strs[0]];
    let i2 = 0;
    while (i2 < args.length) {
      addCodeArg(code2, args[i2]);
      code2.push(strs[++i2]);
    }
    return new _Code(code2);
  }
  exports$1._ = _2;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i2 = 0;
    while (i2 < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i2]);
      expr.push(plus, safeStringify(strs[++i2]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports$1.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports$1.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i2 = 1;
    while (i2 < expr.length - 1) {
      if (expr[i2] === plus) {
        const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
        if (res !== void 0) {
          expr.splice(i2 - 1, 3, res);
          continue;
        }
        expr[i2++] = "+";
      }
      i2++;
    }
  }
  function mergeExprItems(a2, b2) {
    if (b2 === '""')
      return a2;
    if (a2 === '""')
      return b2;
    if (typeof a2 == "string") {
      if (b2 instanceof Name || a2[a2.length - 1] !== '"')
        return;
      if (typeof b2 != "string")
        return `${a2.slice(0, -1)}${b2}"`;
      if (b2[0] === '"')
        return a2.slice(0, -1) + b2.slice(1);
      return;
    }
    if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name))
      return `"${a2}${b2.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports$1.strConcat = strConcat;
  function interpolate(x3) {
    return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
  }
  function stringify(x3) {
    return new _Code(safeStringify(x3));
  }
  exports$1.stringify = stringify;
  function safeStringify(x3) {
    return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports$1.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
  }
  exports$1.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports$1.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports$1.regexpCode = regexpCode;
})(code$3);
var scope$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
  const code_12 = code$3;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
  exports$1.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports$1.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports$1.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c2 = valueCode(name);
          if (c2) {
            const def2 = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c2};${this.opts._n}`;
          } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c2}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports$1.ValueScope = ValueScope;
})(scope$1);
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
  const code_12 = code$3;
  const scope_1 = scope$1;
  var code_2 = code$3;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope$1;
  Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports$1.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i2, 1, ...n);
        else if (n)
          nodes[i2] = n;
        else
          nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e2 = this.else;
      if (e2) {
        const ns = e2.optimizeNodes();
        e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e2) {
        if (cond === false)
          return e2 instanceof If ? e2 : e2.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e2 instanceof If ? [e2] : e2.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c2) {
      if (typeof c2 == "function")
        c2();
      else if (c2 !== code_12.nil)
        this._leafNode(new AnyCode(c2));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i2) => {
          this.var(name, (0, code_12._)`${arr}[${i2}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports$1.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c2) => {
      if (c2 instanceof code_12.Name)
        c2 = replaceName(c2);
      if (c2 instanceof code_12._Code)
        items2.push(...c2._items);
      else
        items2.push(c2);
      return items2;
    }, []));
    function replaceName(n) {
      const c2 = constants2[n.str];
      if (c2 === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c2;
    }
    function canOptimize(e2) {
      return e2 instanceof code_12._Code && e2._items.some((c2) => c2 instanceof code_12.Name && names2[c2.str] === 1 && constants2[c2.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x3) {
    return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_12._)`!${par(x3)}`;
  }
  exports$1.not = not2;
  const andCode = mappend(exports$1.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports$1.and = and;
  const orCode = mappend(exports$1.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports$1.or = or;
  function mappend(op) {
    return (x3, y2) => x3 === code_12.nil ? y2 : y2 === code_12.nil ? x3 : (0, code_12._)`${par(x3)} ${op} ${par(y2)}`;
  }
  function par(x3) {
    return x3 instanceof code_12.Name ? x3 : (0, code_12._)`(${x3})`;
  }
})(codegen$1);
var util$2 = {};
Object.defineProperty(util$2, "__esModule", { value: true });
util$2.checkStrictMode = util$2.getErrorPath = util$2.Type = util$2.useFunc = util$2.setEvaluated = util$2.evaluatedPropsToName = util$2.mergeEvaluated = util$2.eachItem = util$2.unescapeJsonPointer = util$2.escapeJsonPointer = util$2.escapeFragment = util$2.unescapeFragment = util$2.schemaRefOrVal = util$2.schemaHasRulesButRef = util$2.schemaHasRules = util$2.checkUnknownRules = util$2.alwaysValidSchema = util$2.toHash = void 0;
const codegen_1$$ = codegen$1;
const code_1$l = code$3;
function toHash$1(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util$2.toHash = toHash$1;
function alwaysValidSchema$1(it2, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules$1(it2, schema);
  return !schemaHasRules$1(schema, it2.self.RULES.all);
}
util$2.alwaysValidSchema = alwaysValidSchema$1;
function checkUnknownRules$1(it2, schema = it2.schema) {
  const { opts, self: self2 } = it2;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema) {
    if (!rules2[key])
      checkStrictMode$1(it2, `unknown keyword: "${key}"`);
  }
}
util$2.checkUnknownRules = checkUnknownRules$1;
function schemaHasRules$1(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (rules2[key])
      return true;
  return false;
}
util$2.schemaHasRules = schemaHasRules$1;
function schemaHasRulesButRef$1(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util$2.schemaHasRulesButRef = schemaHasRulesButRef$1;
function schemaRefOrVal$1({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$$._)`${schema}`;
  }
  return (0, codegen_1$$._)`${topSchemaRef}${schemaPath}${(0, codegen_1$$.getProperty)(keyword2)}`;
}
util$2.schemaRefOrVal = schemaRefOrVal$1;
function unescapeFragment$1(str) {
  return unescapeJsonPointer$1(decodeURIComponent(str));
}
util$2.unescapeFragment = unescapeFragment$1;
function escapeFragment$1(str) {
  return encodeURIComponent(escapeJsonPointer$1(str));
}
util$2.escapeFragment = escapeFragment$1;
function escapeJsonPointer$1(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util$2.escapeJsonPointer = escapeJsonPointer$1;
function unescapeJsonPointer$1(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util$2.unescapeJsonPointer = unescapeJsonPointer$1;
function eachItem$1(xs, f3) {
  if (Array.isArray(xs)) {
    for (const x3 of xs)
      f3(x3);
  } else {
    f3(xs);
  }
}
util$2.eachItem = eachItem$1;
function makeMergeEvaluated$1({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
  return (gen, from, to, toName) => {
    const res = to === void 0 ? from : to instanceof codegen_1$$.Name ? (from instanceof codegen_1$$.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$$.Name ? (mergeToName(gen, to, from), from) : mergeValues2(from, to);
    return toName === codegen_1$$.Name && !(res instanceof codegen_1$$.Name) ? resultToName(gen, res) : res;
  };
}
util$2.mergeEvaluated = {
  props: makeMergeEvaluated$1({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true && ${from} !== undefined`, () => {
      gen.if((0, codegen_1$$._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$$._)`${to} || {}`).code((0, codegen_1$$._)`Object.assign(${to}, ${from})`));
    }),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true`, () => {
      if (from === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$$._)`${to} || {}`);
        setEvaluated$1(gen, to, from);
      }
    }),
    mergeValues: (from, to) => from === true ? true : { ...from, ...to },
    resultToName: evaluatedPropsToName$1
  }),
  items: makeMergeEvaluated$1({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$$._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$$._)`${to} > ${from} ? ${to} : ${from}`)),
    mergeValues: (from, to) => from === true ? true : Math.max(from, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName$1(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$$._)`{}`);
  if (ps !== void 0)
    setEvaluated$1(gen, props, ps);
  return props;
}
util$2.evaluatedPropsToName = evaluatedPropsToName$1;
function setEvaluated$1(gen, props, ps) {
  Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1$$._)`${props}${(0, codegen_1$$.getProperty)(p2)}`, true));
}
util$2.setEvaluated = setEvaluated$1;
const snippets$1 = {};
function useFunc$1(gen, f3) {
  return gen.scopeValue("func", {
    ref: f3,
    code: snippets$1[f3.code] || (snippets$1[f3.code] = new code_1$l._Code(f3.code))
  });
}
util$2.useFunc = useFunc$1;
var Type$1;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type$1 || (util$2.Type = Type$1 = {}));
function getErrorPath$1(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$$.Name) {
    const isNumber = dataPropType === Type$1.Num;
    return jsPropertySyntax ? isNumber ? (0, codegen_1$$._)`"[" + ${dataProp} + "]"` : (0, codegen_1$$._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$$._)`"/" + ${dataProp}` : (0, codegen_1$$._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$$.getProperty)(dataProp).toString() : "/" + escapeJsonPointer$1(dataProp);
}
util$2.getErrorPath = getErrorPath$1;
function checkStrictMode$1(it2, msg, mode = it2.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it2.self.logger.warn(msg);
}
util$2.checkStrictMode = checkStrictMode$1;
var names$3 = {};
Object.defineProperty(names$3, "__esModule", { value: true });
const codegen_1$_ = codegen$1;
const names$2 = {
  // validation function arguments
  data: new codegen_1$_.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$_.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$_.Name("instancePath"),
  parentData: new codegen_1$_.Name("parentData"),
  parentDataProperty: new codegen_1$_.Name("parentDataProperty"),
  rootData: new codegen_1$_.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$_.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$_.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$_.Name("errors"),
  // counter of validation errors
  this: new codegen_1$_.Name("this"),
  // "globals"
  self: new codegen_1$_.Name("self"),
  scope: new codegen_1$_.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$_.Name("json"),
  jsonPos: new codegen_1$_.Name("jsonPos"),
  jsonLen: new codegen_1$_.Name("jsonLen"),
  jsonPart: new codegen_1$_.Name("jsonPart")
};
names$3.default = names$2;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
  const codegen_12 = codegen$1;
  const util_12 = util$2;
  const names_12 = names$3;
  exports$1.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports$1.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports$1.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports$1.reportError = reportError;
  function reportExtraError(cxt, error2 = exports$1.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_12.default.vErrors);
    }
  }
  exports$1.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports$1.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i2}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it2.errSchemaPath}/${keyword2}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports$1.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E2 = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E2.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E2.keyword, keyword2], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E2.propertyName, propertyName]);
  }
})(errors$1);
Object.defineProperty(boolSchema$1, "__esModule", { value: true });
boolSchema$1.boolOrEmptySchema = boolSchema$1.topBoolOrEmptySchema = void 0;
const errors_1$7 = errors$1;
const codegen_1$Z = codegen$1;
const names_1$d = names$3;
const boolError$1 = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema$1(it2) {
  const { gen, schema, validateName } = it2;
  if (schema === false) {
    falseSchemaError$1(it2, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$d.default.data);
  } else {
    gen.assign((0, codegen_1$Z._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema$1.topBoolOrEmptySchema = topBoolOrEmptySchema$1;
function boolOrEmptySchema$1(it2, valid2) {
  const { gen, schema } = it2;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError$1(it2);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema$1.boolOrEmptySchema = boolOrEmptySchema$1;
function falseSchemaError$1(it2, overrideAllErrors) {
  const { gen, data } = it2;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it: it2
  };
  (0, errors_1$7.reportError)(cxt, boolError$1, void 0, overrideAllErrors);
}
var dataType$1 = {};
var rules$1 = {};
Object.defineProperty(rules$1, "__esModule", { value: true });
rules$1.getRules = rules$1.isJSONType = void 0;
const _jsonTypes$1 = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes$1 = new Set(_jsonTypes$1);
function isJSONType$1(x3) {
  return typeof x3 == "string" && jsonTypes$1.has(x3);
}
rules$1.isJSONType = isJSONType$1;
function getRules$1() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules$1.getRules = getRules$1;
var applicability$1 = {};
Object.defineProperty(applicability$1, "__esModule", { value: true });
applicability$1.shouldUseRule = applicability$1.shouldUseGroup = applicability$1.schemaHasRulesForType = void 0;
function schemaHasRulesForType$1({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup$1(schema, group);
}
applicability$1.schemaHasRulesForType = schemaHasRulesForType$1;
function shouldUseGroup$1(schema, group) {
  return group.rules.some((rule) => shouldUseRule$1(schema, rule));
}
applicability$1.shouldUseGroup = shouldUseGroup$1;
function shouldUseRule$1(schema, rule) {
  var _a;
  return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
}
applicability$1.shouldUseRule = shouldUseRule$1;
Object.defineProperty(dataType$1, "__esModule", { value: true });
dataType$1.reportTypeError = dataType$1.checkDataTypes = dataType$1.checkDataType = dataType$1.coerceAndCheckDataType = dataType$1.getJSONTypes = dataType$1.getSchemaTypes = dataType$1.DataType = void 0;
const rules_1$1 = rules$1;
const applicability_1$3 = applicability$1;
const errors_1$6 = errors$1;
const codegen_1$Y = codegen$1;
const util_1$R = util$2;
var DataType$1;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType$1 || (dataType$1.DataType = DataType$1 = {}));
function getSchemaTypes$1(schema) {
  const types2 = getJSONTypes$1(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType$1.getSchemaTypes = getSchemaTypes$1;
function getJSONTypes$1(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1$1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType$1.getJSONTypes = getJSONTypes$1;
function coerceAndCheckDataType$1(it2, types2) {
  const { gen, data, opts } = it2;
  const coerceTo = coerceToTypes$1(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$3.schemaHasRulesForType)(it2, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes$1(types2, data, opts.strictNumbers, DataType$1.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData$1(it2, types2, coerceTo);
      else
        reportTypeError$1(it2);
    });
  }
  return checkTypes;
}
dataType$1.coerceAndCheckDataType = coerceAndCheckDataType$1;
const COERCIBLE$1 = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes$1(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE$1.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData$1(it2, types2, coerceTo) {
  const { gen, data, opts } = it2;
  const dataType2 = gen.let("dataType", (0, codegen_1$Y._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$Y._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$Y._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$Y._)`${data}[0]`).assign(dataType2, (0, codegen_1$Y._)`typeof ${data}`).if(checkDataTypes$1(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$Y._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE$1.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError$1(it2);
  gen.endIf();
  gen.if((0, codegen_1$Y._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData$1(it2, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$Y._)`"" + ${data}`).elseIf((0, codegen_1$Y._)`${data} === null`).assign(coerced, (0, codegen_1$Y._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$Y._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$Y._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$Y._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$Y._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$Y._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$Y._)`[${data}]`);
    }
  }
}
function assignParentData$1({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$Y._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$Y._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType$1(dataType2, data, strictNums, correct = DataType$1.Correct) {
  const EQ = correct === DataType$1.Correct ? codegen_1$Y.operators.EQ : codegen_1$Y.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$Y._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$Y._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$Y._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$Y._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$Y._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType$1.Correct ? cond : (0, codegen_1$Y.not)(cond);
  function numCond(_cond = codegen_1$Y.nil) {
    return (0, codegen_1$Y.and)((0, codegen_1$Y._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$Y._)`isFinite(${data})` : codegen_1$Y.nil);
  }
}
dataType$1.checkDataType = checkDataType$1;
function checkDataTypes$1(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType$1(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$R.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$Y._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$Y._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$Y.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$Y.and)(cond, checkDataType$1(t2, data, strictNums, correct));
  return cond;
}
dataType$1.checkDataTypes = checkDataTypes$1;
const typeError$1 = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$Y._)`{type: ${schema}}` : (0, codegen_1$Y._)`{type: ${schemaValue}}`
};
function reportTypeError$1(it2) {
  const cxt = getTypeErrorContext$1(it2);
  (0, errors_1$6.reportError)(cxt, typeError$1);
}
dataType$1.reportTypeError = reportTypeError$1;
function getTypeErrorContext$1(it2) {
  const { gen, data, schema } = it2;
  const schemaCode = (0, util_1$R.schemaRefOrVal)(it2, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it: it2
  };
}
var defaults$1 = {};
Object.defineProperty(defaults$1, "__esModule", { value: true });
defaults$1.assignDefaults = void 0;
const codegen_1$X = codegen$1;
const util_1$Q = util$2;
function assignDefaults$1(it2, ty) {
  const { properties: properties2, items: items2 } = it2.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault$1(it2, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i2) => assignDefault$1(it2, i2, sch.default));
  }
}
defaults$1.assignDefaults = assignDefaults$1;
function assignDefault$1(it2, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it2;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$X._)`${data}${(0, codegen_1$X.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$Q.checkStrictMode)(it2, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$X._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$X._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$X._)`${childData} = ${(0, codegen_1$X.stringify)(defaultValue)}`);
}
var keyword$1 = {};
var code$2 = {};
Object.defineProperty(code$2, "__esModule", { value: true });
code$2.validateUnion = code$2.validateArray = code$2.usePattern = code$2.callValidateCode = code$2.schemaProperties = code$2.allSchemaProperties = code$2.noPropertyInData = code$2.propertyInData = code$2.isOwnProperty = code$2.hasPropFunc = code$2.reportMissingProp = code$2.checkMissingProp = code$2.checkReportMissingProp = void 0;
const codegen_1$W = codegen$1;
const util_1$P = util$2;
const names_1$c = names$3;
const util_2$3 = util$2;
function checkReportMissingProp$1(cxt, prop) {
  const { gen, data, it: it2 } = cxt;
  gen.if(noPropertyInData$1(gen, data, prop, it2.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$W._)`${prop}` }, true);
    cxt.error();
  });
}
code$2.checkReportMissingProp = checkReportMissingProp$1;
function checkMissingProp$1({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$W.or)(...properties2.map((prop) => (0, codegen_1$W.and)(noPropertyInData$1(gen, data, prop, opts.ownProperties), (0, codegen_1$W._)`${missing} = ${prop}`)));
}
code$2.checkMissingProp = checkMissingProp$1;
function reportMissingProp$1(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code$2.reportMissingProp = reportMissingProp$1;
function hasPropFunc$1(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$W._)`Object.prototype.hasOwnProperty`
  });
}
code$2.hasPropFunc = hasPropFunc$1;
function isOwnProperty$1(gen, data, property) {
  return (0, codegen_1$W._)`${hasPropFunc$1(gen)}.call(${data}, ${property})`;
}
code$2.isOwnProperty = isOwnProperty$1;
function propertyInData$1(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$W._)`${data}${(0, codegen_1$W.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$W._)`${cond} && ${isOwnProperty$1(gen, data, property)}` : cond;
}
code$2.propertyInData = propertyInData$1;
function noPropertyInData$1(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$W._)`${data}${(0, codegen_1$W.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$W.or)(cond, (0, codegen_1$W.not)(isOwnProperty$1(gen, data, property))) : cond;
}
code$2.noPropertyInData = noPropertyInData$1;
function allSchemaProperties$1(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
}
code$2.allSchemaProperties = allSchemaProperties$1;
function schemaProperties$1(it2, schemaMap) {
  return allSchemaProperties$1(schemaMap).filter((p2) => !(0, util_1$P.alwaysValidSchema)(it2, schemaMap[p2]));
}
code$2.schemaProperties = schemaProperties$1;
function callValidateCode$1({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$W._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$c.default.instancePath, (0, codegen_1$W.strConcat)(names_1$c.default.instancePath, errorPath)],
    [names_1$c.default.parentData, it2.parentData],
    [names_1$c.default.parentDataProperty, it2.parentDataProperty],
    [names_1$c.default.rootData, names_1$c.default.rootData]
  ];
  if (it2.opts.dynamicRef)
    valCxt.push([names_1$c.default.dynamicAnchors, names_1$c.default.dynamicAnchors]);
  const args = (0, codegen_1$W._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$W.nil ? (0, codegen_1$W._)`${func}.call(${context}, ${args})` : (0, codegen_1$W._)`${func}(${args})`;
}
code$2.callValidateCode = callValidateCode$1;
const newRegExp$1 = (0, codegen_1$W._)`new RegExp`;
function usePattern$1({ gen, it: { opts } }, pattern2) {
  const u2 = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u2);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$W._)`${regExp.code === "new RegExp" ? newRegExp$1 : (0, util_2$3.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
  });
}
code$2.usePattern = usePattern$1;
function validateArray$1(cxt) {
  const { gen, data, keyword: keyword2, it: it2 } = cxt;
  const valid2 = gen.name("valid");
  if (it2.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$W._)`${data}.length`);
    gen.forRange("i", 0, len, (i2) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i2,
        dataPropType: util_1$P.Type.Num
      }, valid2);
      gen.if((0, codegen_1$W.not)(valid2), notValid);
    });
  }
}
code$2.validateArray = validateArray$1;
function validateUnion$1(cxt) {
  const { gen, schema, keyword: keyword2, it: it2 } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$P.alwaysValidSchema)(it2, sch));
  if (alwaysValid && !it2.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i2) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$W._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$W.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code$2.validateUnion = validateUnion$1;
Object.defineProperty(keyword$1, "__esModule", { value: true });
keyword$1.validateKeywordUsage = keyword$1.validSchemaType = keyword$1.funcKeywordCode = keyword$1.macroKeywordCode = void 0;
const codegen_1$V = codegen$1;
const names_1$b = names$3;
const code_1$k = code$2;
const errors_1$5 = errors$1;
function macroKeywordCode$1(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
  const macroSchema = def2.macro.call(it2.self, schema, parentSchema, it2);
  const schemaRef = useKeyword$1(gen, keyword2, macroSchema);
  if (it2.opts.validateSchema !== false)
    it2.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$V.nil,
    errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword$1.macroKeywordCode = macroKeywordCode$1;
function funcKeywordCode$1(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
  checkAsyncKeyword$1(it2, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it2.self, schema, parentSchema, it2) : def2.validate;
  const validateRef = useKeyword$1(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData$1(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData$1(cxt);
      reportErrs(() => addErrs$1(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$V._)`await `), (e2) => gen.assign(valid2, false).if((0, codegen_1$V._)`${e2} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$V._)`${e2}.errors`), () => gen.throw(e2)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$V._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$V.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$V._)`await ` : codegen_1$V.nil) {
    const passCxt = it2.opts.passContext ? names_1$b.default.this : names_1$b.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$V._)`${_await}${(0, code_1$k.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$V.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword$1.funcKeywordCode = funcKeywordCode$1;
function modifyData$1(cxt) {
  const { gen, data, it: it2 } = cxt;
  gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1$V._)`${it2.parentData}[${it2.parentDataProperty}]`));
}
function addErrs$1(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$V._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$b.default.vErrors, (0, codegen_1$V._)`${names_1$b.default.vErrors} === null ? ${errs} : ${names_1$b.default.vErrors}.concat(${errs})`).assign(names_1$b.default.errors, (0, codegen_1$V._)`${names_1$b.default.vErrors}.length`);
    (0, errors_1$5.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword$1({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword$1(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$V.stringify)(result) });
}
function validSchemaType$1(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
}
keyword$1.validSchemaType = validSchemaType$1;
function validateKeywordUsage$1({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword$1.validateKeywordUsage = validateKeywordUsage$1;
var subschema$1 = {};
Object.defineProperty(subschema$1, "__esModule", { value: true });
subschema$1.extendSubschemaMode = subschema$1.extendSubschemaData = subschema$1.getSubschema = void 0;
const codegen_1$U = codegen$1;
const util_1$O = util$2;
function getSubschema$1(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it2.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$U._)`${it2.schemaPath}${(0, codegen_1$U.getProperty)(keyword2)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$U._)`${it2.schemaPath}${(0, codegen_1$U.getProperty)(keyword2)}${(0, codegen_1$U.getProperty)(schemaProp)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1$O.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema$1.getSubschema = getSubschema$1;
function extendSubschemaData$1(subschema2, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it2;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it2;
    const nextData = gen.let("data", (0, codegen_1$U._)`${it2.data}${(0, codegen_1$U.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$U.str)`${errorPath}${(0, util_1$O.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$U._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$U.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it2.dataLevel + 1;
    subschema2.dataTypes = [];
    it2.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it2.data;
    subschema2.dataNames = [...it2.dataNames, _nextData];
  }
}
subschema$1.extendSubschemaData = extendSubschemaData$1;
function extendSubschemaMode$1(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema$1.extendSubschemaMode = extendSubschemaMode$1;
var resolve$4 = {};
var fastDeepEqual = function equal(a2, b2) {
  if (a2 === b2) return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor) return false;
    var length, i2, keys;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2])) return false;
      return true;
    }
    if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal(a2[key], b2[key])) return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
var jsonSchemaTraverse$1 = { exports: {} };
var traverse$3 = jsonSchemaTraverse$1.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse$1(opts, pre, post, schema, "", schema);
};
traverse$3.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$3.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$3.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$3.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse$1(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$3.arrayKeywords) {
          for (var i2 = 0; i2 < sch.length; i2++)
            _traverse$1(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
        }
      } else if (key in traverse$3.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse$1(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr$1(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$3.keywords || opts.allKeys && !(key in traverse$3.skipKeywords)) {
        _traverse$1(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr$1(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports$1 = jsonSchemaTraverse$1.exports;
Object.defineProperty(resolve$4, "__esModule", { value: true });
resolve$4.getSchemaRefs = resolve$4.resolveUrl = resolve$4.normalizeId = resolve$4._getFullPath = resolve$4.getFullPath = resolve$4.inlineRef = void 0;
const util_1$N = util$2;
const equal$6 = fastDeepEqual;
const traverse$2 = jsonSchemaTraverseExports$1;
const SIMPLE_INLINED$1 = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef$1(schema, limit2 = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef$1(schema);
  if (!limit2)
    return false;
  return countKeys$1(schema) <= limit2;
}
resolve$4.inlineRef = inlineRef$1;
const REF_KEYWORDS$1 = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef$1(schema) {
  for (const key in schema) {
    if (REF_KEYWORDS$1.has(key))
      return true;
    const sch = schema[key];
    if (Array.isArray(sch) && sch.some(hasRef$1))
      return true;
    if (typeof sch == "object" && hasRef$1(sch))
      return true;
  }
  return false;
}
function countKeys$1(schema) {
  let count = 0;
  for (const key in schema) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED$1.has(key))
      continue;
    if (typeof schema[key] == "object") {
      (0, util_1$N.eachItem)(schema[key], (sch) => count += countKeys$1(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath$1(resolver, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId$1(id2);
  const p2 = resolver.parse(id2);
  return _getFullPath$1(resolver, p2);
}
resolve$4.getFullPath = getFullPath$1;
function _getFullPath$1(resolver, p2) {
  const serialized = resolver.serialize(p2);
  return serialized.split("#")[0] + "#";
}
resolve$4._getFullPath = _getFullPath$1;
const TRAILING_SLASH_HASH$1 = /#\/?$/;
function normalizeId$1(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH$1, "") : "";
}
resolve$4.normalizeId = normalizeId$1;
function resolveUrl$1(resolver, baseId, id2) {
  id2 = normalizeId$1(id2);
  return resolver.resolve(baseId, id2);
}
resolve$4.resolveUrl = resolveUrl$1;
const ANCHOR$1 = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs$1(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId$1(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath$1(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse$2(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId$1(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId$1(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR$1.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$6(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$4.getSchemaRefs = getSchemaRefs$1;
Object.defineProperty(validate$1, "__esModule", { value: true });
validate$1.getData = validate$1.KeywordCxt = validate$1.validateFunctionCode = void 0;
const boolSchema_1$1 = boolSchema$1;
const dataType_1$3 = dataType$1;
const applicability_1$2 = applicability$1;
const dataType_2$1 = dataType$1;
const defaults_1$1 = defaults$1;
const keyword_1$1 = keyword$1;
const subschema_1$1 = subschema$1;
const codegen_1$T = codegen$1;
const names_1$a = names$3;
const resolve_1$5 = resolve$4;
const util_1$M = util$2;
const errors_1$4 = errors$1;
function validateFunctionCode$1(it2) {
  if (isSchemaObj$1(it2)) {
    checkKeywords$1(it2);
    if (schemaCxtHasRules$1(it2)) {
      topSchemaObjCode$1(it2);
      return;
    }
  }
  validateFunction$1(it2, () => (0, boolSchema_1$1.topBoolOrEmptySchema)(it2));
}
validate$1.validateFunctionCode = validateFunctionCode$1;
function validateFunction$1({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$T._)`${names_1$a.default.data}, ${names_1$a.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$T._)`"use strict"; ${funcSourceUrl$1(schema, opts)}`);
      destructureValCxtES5$1(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$T._)`${names_1$a.default.data}, ${destructureValCxt$1(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl$1(schema, opts)).code(body));
  }
}
function destructureValCxt$1(opts) {
  return (0, codegen_1$T._)`{${names_1$a.default.instancePath}="", ${names_1$a.default.parentData}, ${names_1$a.default.parentDataProperty}, ${names_1$a.default.rootData}=${names_1$a.default.data}${opts.dynamicRef ? (0, codegen_1$T._)`, ${names_1$a.default.dynamicAnchors}={}` : codegen_1$T.nil}}={}`;
}
function destructureValCxtES5$1(gen, opts) {
  gen.if(names_1$a.default.valCxt, () => {
    gen.var(names_1$a.default.instancePath, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.instancePath}`);
    gen.var(names_1$a.default.parentData, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.parentData}`);
    gen.var(names_1$a.default.parentDataProperty, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.parentDataProperty}`);
    gen.var(names_1$a.default.rootData, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$a.default.dynamicAnchors, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$a.default.instancePath, (0, codegen_1$T._)`""`);
    gen.var(names_1$a.default.parentData, (0, codegen_1$T._)`undefined`);
    gen.var(names_1$a.default.parentDataProperty, (0, codegen_1$T._)`undefined`);
    gen.var(names_1$a.default.rootData, names_1$a.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$a.default.dynamicAnchors, (0, codegen_1$T._)`{}`);
  });
}
function topSchemaObjCode$1(it2) {
  const { schema, opts, gen } = it2;
  validateFunction$1(it2, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword$1(it2);
    checkNoDefault$1(it2);
    gen.let(names_1$a.default.vErrors, null);
    gen.let(names_1$a.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated$1(it2);
    typeAndKeywords$1(it2);
    returnResults$1(it2);
  });
  return;
}
function resetEvaluated$1(it2) {
  const { gen, validateName } = it2;
  it2.evaluated = gen.const("evaluated", (0, codegen_1$T._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$T._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$T._)`${it2.evaluated}.props`, (0, codegen_1$T._)`undefined`));
  gen.if((0, codegen_1$T._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$T._)`${it2.evaluated}.items`, (0, codegen_1$T._)`undefined`));
}
function funcSourceUrl$1(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$T._)`/*# sourceURL=${schId} */` : codegen_1$T.nil;
}
function subschemaCode$1(it2, valid2) {
  if (isSchemaObj$1(it2)) {
    checkKeywords$1(it2);
    if (schemaCxtHasRules$1(it2)) {
      subSchemaObjCode$1(it2, valid2);
      return;
    }
  }
  (0, boolSchema_1$1.boolOrEmptySchema)(it2, valid2);
}
function schemaCxtHasRules$1({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj$1(it2) {
  return typeof it2.schema != "boolean";
}
function subSchemaObjCode$1(it2, valid2) {
  const { schema, gen, opts } = it2;
  if (opts.$comment && schema.$comment)
    commentKeyword$1(it2);
  updateContext$1(it2);
  checkAsyncSchema$1(it2);
  const errsCount = gen.const("_errs", names_1$a.default.errors);
  typeAndKeywords$1(it2, errsCount);
  gen.var(valid2, (0, codegen_1$T._)`${errsCount} === ${names_1$a.default.errors}`);
}
function checkKeywords$1(it2) {
  (0, util_1$M.checkUnknownRules)(it2);
  checkRefsAndKeywords$1(it2);
}
function typeAndKeywords$1(it2, errsCount) {
  if (it2.opts.jtd)
    return schemaKeywords$1(it2, [], false, errsCount);
  const types2 = (0, dataType_1$3.getSchemaTypes)(it2.schema);
  const checkedTypes = (0, dataType_1$3.coerceAndCheckDataType)(it2, types2);
  schemaKeywords$1(it2, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords$1(it2) {
  const { schema, errSchemaPath, opts, self: self2 } = it2;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$M.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault$1(it2) {
  const { schema, opts } = it2;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$M.checkStrictMode)(it2, "default is ignored in the schema root");
  }
}
function updateContext$1(it2) {
  const schId = it2.schema[it2.opts.schemaId];
  if (schId)
    it2.baseId = (0, resolve_1$5.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
}
function checkAsyncSchema$1(it2) {
  if (it2.schema.$async && !it2.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword$1({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$T._)`${names_1$a.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$T.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$T._)`${names_1$a.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults$1(it2) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError3, opts } = it2;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$T._)`${names_1$a.default.errors} === 0`, () => gen.return(names_1$a.default.data), () => gen.throw((0, codegen_1$T._)`new ${ValidationError3}(${names_1$a.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$T._)`${validateName}.errors`, names_1$a.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated$1(it2);
    gen.return((0, codegen_1$T._)`${names_1$a.default.errors} === 0`);
  }
}
function assignEvaluated$1({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$T.Name)
    gen.assign((0, codegen_1$T._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$T.Name)
    gen.assign((0, codegen_1$T._)`${evaluated}.items`, items2);
}
function schemaKeywords$1(it2, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it2;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$M.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode$1(it2, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes$1(it2, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1$2.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2$1.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords$1(it2, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2$1.reportTypeError)(it2);
      }
      gen.endIf();
    } else {
      iterateKeywords$1(it2, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$T._)`${names_1$a.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords$1(it2, group) {
  const { gen, schema, opts: { useDefaults } } = it2;
  if (useDefaults)
    (0, defaults_1$1.assignDefaults)(it2, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1$2.shouldUseRule)(schema, rule)) {
        keywordCode$1(it2, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes$1(it2, types2) {
  if (it2.schemaEnv.meta || !it2.opts.strictTypes)
    return;
  checkContextTypes$1(it2, types2);
  if (!it2.opts.allowUnionTypes)
    checkMultipleTypes$1(it2, types2);
  checkKeywordTypes$1(it2, it2.dataTypes);
}
function checkContextTypes$1(it2, types2) {
  if (!types2.length)
    return;
  if (!it2.dataTypes.length) {
    it2.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType$1(it2.dataTypes, t2)) {
      strictTypesError$1(it2, `type "${t2}" not allowed by context "${it2.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes$1(it2, types2);
}
function checkMultipleTypes$1(it2, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError$1(it2, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes$1(it2, ts) {
  const rules2 = it2.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1$2.shouldUseRule)(it2.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType$1(ts, t2))) {
        strictTypesError$1(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType$1(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType$1(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes$1(it2, withTypes) {
  const ts = [];
  for (const t2 of it2.dataTypes) {
    if (includesType$1(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it2.dataTypes = ts;
}
function strictTypesError$1(it2, msg) {
  const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$M.checkStrictMode)(it2, msg, it2.opts.strictTypes);
}
let KeywordCxt$1 = class KeywordCxt {
  constructor(it2, def2, keyword2) {
    (0, keyword_1$1.validateKeywordUsage)(it2, def2, keyword2);
    this.gen = it2.gen;
    this.allErrors = it2.allErrors;
    this.keyword = keyword2;
    this.data = it2.data;
    this.schema = it2.schema[keyword2];
    this.$data = def2.$data && it2.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$M.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it2.schema;
    this.params = {};
    this.it = it2;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it2.gen.const("vSchema", getData$1(this.$data, it2));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1$1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it2.gen.const("_errs", names_1$a.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$T.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$T.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$T._)`${schemaCode} !== undefined && (${(0, codegen_1$T.or)(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1$4.reportExtraError : errors_1$4.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1$4.reportError)(this, this.def.$dataError || errors_1$4.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1$4.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$T.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$T.nil, $dataValid = codegen_1$T.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$T.or)((0, codegen_1$T._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$T.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$T.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it: it2 } = this;
    return (0, codegen_1$T.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$T.Name))
          throw new Error("ajv implementation error");
        const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$T._)`${(0, dataType_2$1.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2$1.DataType.Wrong)}`;
      }
      return codegen_1$T.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$T._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$T.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1$1.getSubschema)(this.it, appl);
    (0, subschema_1$1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1$1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode$1(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it: it2, gen } = this;
    if (!it2.opts.unevaluated)
      return;
    if (it2.props !== true && schemaCxt.props !== void 0) {
      it2.props = util_1$M.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
    }
    if (it2.items !== true && schemaCxt.items !== void 0) {
      it2.items = util_1$M.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it: it2, gen } = this;
    if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$T.Name));
      return true;
    }
  }
};
validate$1.KeywordCxt = KeywordCxt$1;
function keywordCode$1(it2, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt$1(it2, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1$1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1$1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1$1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData$1($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$a.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER$1.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$a.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER$1.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$T._)`${data}${(0, codegen_1$T.getProperty)((0, util_1$M.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$T._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate$1.getData = getData$1;
var validation_error$1 = {};
Object.defineProperty(validation_error$1, "__esModule", { value: true });
let ValidationError$1 = class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
};
validation_error$1.default = ValidationError$1;
var ref_error$1 = {};
Object.defineProperty(ref_error$1, "__esModule", { value: true });
const resolve_1$4 = resolve$4;
let MissingRefError$1 = class MissingRefError extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$4.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$4.normalizeId)((0, resolve_1$4.getFullPath)(resolver, this.missingRef));
  }
};
ref_error$1.default = MissingRefError$1;
var compile$1 = {};
Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
const codegen_1$S = codegen$1;
const validation_error_1$1 = validation_error$1;
const names_1$9 = names$3;
const resolve_1$3 = resolve$4;
const util_1$L = util$2;
const validate_1$3 = validate$1;
let SchemaEnv$1 = class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1$3.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
};
compile$1.SchemaEnv = SchemaEnv$1;
function compileSchema$1(sch) {
  const _sch = getCompilingSchema$1.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1$3.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$S.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1$1.default,
      code: (0, codegen_1$S._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$9.default.data,
    parentData: names_1$9.default.parentData,
    parentDataProperty: names_1$9.default.parentDataProperty,
    dataNames: [names_1$9.default.data],
    dataPathArr: [codegen_1$S.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$S.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$S.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$S._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$3.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$9.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$9.default.self}`, `${names_1$9.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$S.Name ? void 0 : props,
        items: items2 instanceof codegen_1$S.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$S.Name,
        dynamicItems: items2 instanceof codegen_1$S.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$S.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e2) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e2;
  } finally {
    this._compilations.delete(sch);
  }
}
compile$1.compileSchema = compileSchema$1;
function resolveRef$1(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$3.call(this, root, ref2);
  if (_sch === void 0) {
    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv$1({ schema, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile$1.call(this, _sch);
}
compile$1.resolveRef = resolveRef$1;
function inlineOrCompile$1(sch) {
  if ((0, resolve_1$3.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema$1.call(this, sch);
}
function getCompilingSchema$1(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv$1(sch, schEnv))
      return sch;
  }
}
compile$1.getCompilingSchema = getCompilingSchema$1;
function sameSchemaEnv$1(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$3(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema$1.call(this, root, ref2);
}
function resolveSchema$1(root, ref2) {
  const p2 = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1$3._getFullPath)(this.opts.uriResolver, p2);
  let baseId = (0, resolve_1$3.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer$1.call(this, p2, root);
  }
  const id2 = (0, resolve_1$3.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema$1.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer$1.call(this, p2, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema$1.call(this, schOrRef);
  if (id2 === (0, resolve_1$3.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv$1({ schema, schemaId, root, baseId });
  }
  return getJsonPointer$1.call(this, p2, schOrRef);
}
compile$1.resolveSchema = resolveSchema$1;
const PREVENT_SCOPE_CHANGE$1 = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer$1(parsedRef, { baseId, schema, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$L.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE$1.has(part) && schId) {
      baseId = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$L.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema$1.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv$1({ schema, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$3 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description$1 = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$3 = "object";
const required$3 = [
  "$data"
];
const properties$5 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$3 = false;
const require$$9$1 = {
  $id: $id$3,
  description: description$1,
  type: type$3,
  required: required$3,
  properties: properties$5,
  additionalProperties: additionalProperties$3
};
var uri$3 = {};
var fastUri$1 = { exports: {} };
const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
function stringArrayToHexStripped(input) {
  let acc = "";
  let code2 = 0;
  let i2 = 0;
  for (i2 = 0; i2 < input.length; i2++) {
    code2 = input[i2].charCodeAt(0);
    if (code2 === 48) {
      continue;
    }
    if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
      return "";
    }
    acc += input[i2];
    break;
  }
  for (i2 += 1; i2 < input.length; i2++) {
    code2 = input[i2].charCodeAt(0);
    if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
      return "";
    }
    acc += input[i2];
  }
  return acc;
}
const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
function consumeIsZone(buffer) {
  buffer.length = 0;
  return true;
}
function consumeHextets(buffer, address, output) {
  if (buffer.length) {
    const hex = stringArrayToHexStripped(buffer);
    if (hex !== "") {
      address.push(hex);
    } else {
      output.error = true;
      return false;
    }
    buffer.length = 0;
  }
  return true;
}
function getIPV6(input) {
  let tokenCount = 0;
  const output = { error: false, address: "", zone: "" };
  const address = [];
  const buffer = [];
  let endipv6Encountered = false;
  let endIpv6 = false;
  let consume = consumeHextets;
  for (let i2 = 0; i2 < input.length; i2++) {
    const cursor = input[i2];
    if (cursor === "[" || cursor === "]") {
      continue;
    }
    if (cursor === ":") {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume(buffer, address, output)) {
        break;
      }
      if (++tokenCount > 7) {
        output.error = true;
        break;
      }
      if (i2 > 0 && input[i2 - 1] === ":") {
        endipv6Encountered = true;
      }
      address.push(":");
      continue;
    } else if (cursor === "%") {
      if (!consume(buffer, address, output)) {
        break;
      }
      consume = consumeIsZone;
    } else {
      buffer.push(cursor);
      continue;
    }
  }
  if (buffer.length) {
    if (consume === consumeIsZone) {
      output.zone = buffer.join("");
    } else if (endIpv6) {
      address.push(buffer.join(""));
    } else {
      address.push(stringArrayToHexStripped(buffer));
    }
  }
  output.address = address.join("");
  return output;
}
function normalizeIPv6$1(host) {
  if (findToken(host, ":") < 2) {
    return { host, isIPV6: false };
  }
  const ipv6 = getIPV6(host);
  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += "%" + ipv6.zone;
      escapedHost += "%25" + ipv6.zone;
    }
    return { host: newHost, isIPV6: true, escapedHost };
  } else {
    return { host, isIPV6: false };
  }
}
function findToken(str, token) {
  let ind = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    if (str[i2] === token) ind++;
  }
  return ind;
}
function removeDotSegments$1(path2) {
  let input = path2;
  const output = [];
  let nextSlash = -1;
  let len = 0;
  while (len = input.length) {
    if (len === 1) {
      if (input === ".") {
        break;
      } else if (input === "/") {
        output.push("/");
        break;
      } else {
        output.push(input);
        break;
      }
    } else if (len === 2) {
      if (input[0] === ".") {
        if (input[1] === ".") {
          break;
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === "." || input[1] === "/") {
          output.push("/");
          break;
        }
      }
    } else if (len === 3) {
      if (input === "/..") {
        if (output.length !== 0) {
          output.pop();
        }
        output.push("/");
        break;
      }
    }
    if (input[0] === ".") {
      if (input[1] === ".") {
        if (input[2] === "/") {
          input = input.slice(3);
          continue;
        }
      } else if (input[1] === "/") {
        input = input.slice(2);
        continue;
      }
    } else if (input[0] === "/") {
      if (input[1] === ".") {
        if (input[2] === "/") {
          input = input.slice(2);
          continue;
        } else if (input[2] === ".") {
          if (input[3] === "/") {
            input = input.slice(3);
            if (output.length !== 0) {
              output.pop();
            }
            continue;
          }
        }
      }
    }
    if ((nextSlash = input.indexOf("/", 1)) === -1) {
      output.push(input);
      break;
    } else {
      output.push(input.slice(0, nextSlash));
      input = input.slice(nextSlash);
    }
  }
  return output.join("");
}
function normalizeComponentEncoding$1(component, esc) {
  const func = esc !== true ? escape : unescape;
  if (component.scheme !== void 0) {
    component.scheme = func(component.scheme);
  }
  if (component.userinfo !== void 0) {
    component.userinfo = func(component.userinfo);
  }
  if (component.host !== void 0) {
    component.host = func(component.host);
  }
  if (component.path !== void 0) {
    component.path = func(component.path);
  }
  if (component.query !== void 0) {
    component.query = func(component.query);
  }
  if (component.fragment !== void 0) {
    component.fragment = func(component.fragment);
  }
  return component;
}
function recomposeAuthority$1(component) {
  const uriTokens = [];
  if (component.userinfo !== void 0) {
    uriTokens.push(component.userinfo);
    uriTokens.push("@");
  }
  if (component.host !== void 0) {
    let host = unescape(component.host);
    if (!isIPv4$1(host)) {
      const ipV6res = normalizeIPv6$1(host);
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`;
      } else {
        host = component.host;
      }
    }
    uriTokens.push(host);
  }
  if (typeof component.port === "number" || typeof component.port === "string") {
    uriTokens.push(":");
    uriTokens.push(String(component.port));
  }
  return uriTokens.length ? uriTokens.join("") : void 0;
}
var utils = {
  nonSimpleDomain: nonSimpleDomain$1,
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  isIPv4: isIPv4$1,
  isUUID: isUUID$1,
  normalizeIPv6: normalizeIPv6$1
};
const { isUUID } = utils;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function wsIsSecure(wsComponent) {
  if (wsComponent.secure === true) {
    return true;
  } else if (wsComponent.secure === false) {
    return false;
  } else if (wsComponent.scheme) {
    return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
  } else {
    return false;
  }
}
function httpParse(component) {
  if (!component.host) {
    component.error = component.error || "HTTP URIs must have a host.";
  }
  return component;
}
function httpSerialize(component) {
  const secure = String(component.scheme).toLowerCase() === "https";
  if (component.port === (secure ? 443 : 80) || component.port === "") {
    component.port = void 0;
  }
  if (!component.path) {
    component.path = "/";
  }
  return component;
}
function wsParse(wsComponent) {
  wsComponent.secure = wsIsSecure(wsComponent);
  wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
  wsComponent.path = void 0;
  wsComponent.query = void 0;
  return wsComponent;
}
function wsSerialize(wsComponent) {
  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
    wsComponent.port = void 0;
  }
  if (typeof wsComponent.secure === "boolean") {
    wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
    wsComponent.secure = void 0;
  }
  if (wsComponent.resourceName) {
    const [path2, query] = wsComponent.resourceName.split("?");
    wsComponent.path = path2 && path2 !== "/" ? path2 : void 0;
    wsComponent.query = query;
    wsComponent.resourceName = void 0;
  }
  wsComponent.fragment = void 0;
  return wsComponent;
}
function urnParse(urnComponent, options) {
  if (!urnComponent.path) {
    urnComponent.error = "URN can not be parsed";
    return urnComponent;
  }
  const matches = urnComponent.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponent.scheme || "urn";
    urnComponent.nid = matches[1].toLowerCase();
    urnComponent.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
    const schemeHandler = getSchemeHandler$1(urnScheme);
    urnComponent.path = void 0;
    if (schemeHandler) {
      urnComponent = schemeHandler.parse(urnComponent, options);
    }
  } else {
    urnComponent.error = urnComponent.error || "URN can not be parsed.";
  }
  return urnComponent;
}
function urnSerialize(urnComponent, options) {
  if (urnComponent.nid === void 0) {
    throw new Error("URN without nid cannot be serialized");
  }
  const scheme = options.scheme || urnComponent.scheme || "urn";
  const nid = urnComponent.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = getSchemeHandler$1(urnScheme);
  if (schemeHandler) {
    urnComponent = schemeHandler.serialize(urnComponent, options);
  }
  const uriComponent = urnComponent;
  const nss = urnComponent.nss;
  uriComponent.path = `${nid || options.nid}:${nss}`;
  options.skipEscape = true;
  return uriComponent;
}
function urnuuidParse(urnComponent, options) {
  const uuidComponent = urnComponent;
  uuidComponent.uuid = uuidComponent.nss;
  uuidComponent.nss = void 0;
  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
    uuidComponent.error = uuidComponent.error || "UUID is not valid.";
  }
  return uuidComponent;
}
function urnuuidSerialize(uuidComponent) {
  const urnComponent = uuidComponent;
  urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
  return urnComponent;
}
const http = (
  /** @type {SchemeHandler} */
  {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  }
);
const https = (
  /** @type {SchemeHandler} */
  {
    scheme: "https",
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  }
);
const ws = (
  /** @type {SchemeHandler} */
  {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  }
);
const wss = (
  /** @type {SchemeHandler} */
  {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  }
);
const urn = (
  /** @type {SchemeHandler} */
  {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  }
);
const urnuuid = (
  /** @type {SchemeHandler} */
  {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  }
);
const SCHEMES$1 = (
  /** @type {Record<SchemeName, SchemeHandler>} */
  {
    http,
    https,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  }
);
Object.setPrototypeOf(SCHEMES$1, null);
function getSchemeHandler$1(scheme) {
  return scheme && (SCHEMES$1[
    /** @type {SchemeName} */
    scheme
  ] || SCHEMES$1[
    /** @type {SchemeName} */
    scheme.toLowerCase()
  ]) || void 0;
}
var schemes = {
  SCHEMES: SCHEMES$1,
  getSchemeHandler: getSchemeHandler$1
};
const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = utils;
const { SCHEMES, getSchemeHandler } = schemes;
function normalize(uri2, options) {
  if (typeof uri2 === "string") {
    uri2 = /** @type {T} */
    serialize(parse$7(uri2, options), options);
  } else if (typeof uri2 === "object") {
    uri2 = /** @type {T} */
    parse$7(serialize(uri2, options), options);
  }
  return uri2;
}
function resolve$2(baseURI, relativeURI, options) {
  const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
  const resolved = resolveComponent(parse$7(baseURI, schemelessOptions), parse$7(relativeURI, schemelessOptions), schemelessOptions, true);
  schemelessOptions.skipEscape = true;
  return serialize(resolved, schemelessOptions);
}
function resolveComponent(base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse$7(serialize(base, options), options);
    relative = parse$7(serialize(relative, options), options);
  }
  options = options || {};
  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || "");
    target.query = relative.query;
  } else {
    if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== void 0) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path[0] === "/") {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
            target.path = "/" + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }
  target.fragment = relative.fragment;
  return target;
}
function equal$5(uriA, uriB, options) {
  if (typeof uriA === "string") {
    uriA = unescape(uriA);
    uriA = serialize(normalizeComponentEncoding(parse$7(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === "object") {
    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }
  if (typeof uriB === "string") {
    uriB = unescape(uriB);
    uriB = serialize(normalizeComponentEncoding(parse$7(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === "object") {
    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }
  return uriA.toLowerCase() === uriB.toLowerCase();
}
function serialize(cmpts, opts) {
  const component = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ""
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];
  const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
  if (component.path !== void 0) {
    if (!options.skipEscape) {
      component.path = escape(component.path);
      if (component.scheme !== void 0) {
        component.path = component.path.split("%3A").join(":");
      }
    } else {
      component.path = unescape(component.path);
    }
  }
  if (options.reference !== "suffix" && component.scheme) {
    uriTokens.push(component.scheme, ":");
  }
  const authority = recomposeAuthority(component);
  if (authority !== void 0) {
    if (options.reference !== "suffix") {
      uriTokens.push("//");
    }
    uriTokens.push(authority);
    if (component.path && component.path[0] !== "/") {
      uriTokens.push("/");
    }
  }
  if (component.path !== void 0) {
    let s2 = component.path;
    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s2 = removeDotSegments(s2);
    }
    if (authority === void 0 && s2[0] === "/" && s2[1] === "/") {
      s2 = "/%2F" + s2.slice(2);
    }
    uriTokens.push(s2);
  }
  if (component.query !== void 0) {
    uriTokens.push("?", component.query);
  }
  if (component.fragment !== void 0) {
    uriTokens.push("#", component.fragment);
  }
  return uriTokens.join("");
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function parse$7(uri2, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  };
  let isIP = false;
  if (options.reference === "suffix") {
    if (options.scheme) {
      uri2 = options.scheme + ":" + uri2;
    } else {
      uri2 = "//" + uri2;
    }
  }
  const matches = uri2.match(URI_PARSE);
  if (matches) {
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || "";
    parsed.query = matches[7];
    parsed.fragment = matches[8];
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = isIPv4(parsed.host);
      if (ipv4result === false) {
        const ipv6result = normalizeIPv6(parsed.host);
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        isIP = true;
      }
    }
    if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
      parsed.reference = "same-document";
    } else if (parsed.scheme === void 0) {
      parsed.reference = "relative";
    } else if (parsed.fragment === void 0) {
      parsed.reference = "absolute";
    } else {
      parsed.reference = "uri";
    }
    if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
      parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
    }
    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e2) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
        }
      }
    }
    if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
      if (uri2.indexOf("%") !== -1) {
        if (parsed.scheme !== void 0) {
          parsed.scheme = unescape(parsed.scheme);
        }
        if (parsed.host !== void 0) {
          parsed.host = unescape(parsed.host);
        }
      }
      if (parsed.path) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || "URI can not be parsed.";
  }
  return parsed;
}
const fastUri = {
  SCHEMES,
  normalize,
  resolve: resolve$2,
  resolveComponent,
  equal: equal$5,
  serialize,
  parse: parse$7
};
fastUri$1.exports = fastUri;
fastUri$1.exports.default = fastUri;
fastUri$1.exports.fastUri = fastUri;
var fastUriExports = fastUri$1.exports;
Object.defineProperty(uri$3, "__esModule", { value: true });
const uri$2 = fastUriExports;
uri$2.code = 'require("ajv/dist/runtime/uri").default';
uri$3.default = uri$2;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
  var validate_12 = validate$1;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen$1;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error$1;
  const ref_error_12 = ref_error$1;
  const rules_12 = rules$1;
  const compile_12 = compile$1;
  const codegen_2 = codegen$1;
  const resolve_12 = resolve$4;
  const dataType_12 = dataType$1;
  const util_12 = util$2;
  const $dataRefSchema = require$$9$1;
  const uri_1 = uri$3;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _0;
    const s2 = o2.strict;
    const _optz = (_a = o2.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o2.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o2.strictSchema) !== null && _e !== void 0 ? _e : s2) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s2) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s2) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== void 0 ? _o : s2) !== null && _p !== void 0 ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o2.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o2.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t2 = o2.messages) !== null && _t2 !== void 0 ? _t2 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid2 = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e2) {
          if (!(e2 instanceof ref_error_12.default))
            throw e2;
          checkLoaded.call(this, e2);
          await loadMissingSchema.call(this, e2.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p2 = this._loading[ref2];
        if (p2)
          return p2;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t2) => addRule.call(this, k2, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i2 >= 0)
          group.rules.splice(i2, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports$1.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i2 >= 0) {
      ruleGroup.rules.splice(i2, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$5);
var draft7$1 = {};
var core$4 = {};
var id$1 = {};
Object.defineProperty(id$1, "__esModule", { value: true });
const def$V = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id$1.default = def$V;
var ref$1 = {};
Object.defineProperty(ref$1, "__esModule", { value: true });
ref$1.callRef = ref$1.getValidate = void 0;
const ref_error_1$3 = ref_error$1;
const code_1$j = code$2;
const codegen_1$R = codegen$1;
const names_1$8 = names$3;
const compile_1$3 = compile$1;
const util_1$K = util$2;
const def$U = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it: it2 } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it2;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$3.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$3.default(it2.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$3.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef$1(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef$1(cxt, (0, codegen_1$R._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v2 = getValidate$1(cxt, sch);
      callRef$1(cxt, v2, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$R.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$R.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate$1(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$R._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref$1.getValidate = getValidate$1;
function callRef$1(cxt, v2, sch, $async) {
  const { gen, it: it2 } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it2;
  const passCxt = opts.passContext ? names_1$8.default.this : codegen_1$R.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$R._)`await ${(0, code_1$j.callValidateCode)(cxt, v2, passCxt)}`);
      addEvaluatedFrom(v2);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e2) => {
      gen.if((0, codegen_1$R._)`!(${e2} instanceof ${it2.ValidationError})`, () => gen.throw(e2));
      addErrorsFrom(e2);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$j.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$R._)`${source2}.errors`;
    gen.assign(names_1$8.default.vErrors, (0, codegen_1$R._)`${names_1$8.default.vErrors} === null ? ${errs} : ${names_1$8.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$8.default.errors, (0, codegen_1$R._)`${names_1$8.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it2.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it2.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it2.props = util_1$K.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$R._)`${source2}.evaluated.props`);
        it2.props = util_1$K.mergeEvaluated.props(gen, props, it2.props, codegen_1$R.Name);
      }
    }
    if (it2.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it2.items = util_1$K.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$R._)`${source2}.evaluated.items`);
        it2.items = util_1$K.mergeEvaluated.items(gen, items2, it2.items, codegen_1$R.Name);
      }
    }
  }
}
ref$1.callRef = callRef$1;
ref$1.default = def$U;
Object.defineProperty(core$4, "__esModule", { value: true });
const id_1$1 = id$1;
const ref_1$1 = ref$1;
const core$3 = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1$1.default,
  ref_1$1.default
];
core$4.default = core$3;
var validation$3 = {};
var limitNumber$1 = {};
Object.defineProperty(limitNumber$1, "__esModule", { value: true });
const codegen_1$Q = codegen$1;
const ops$1 = codegen_1$Q.operators;
const KWDs$1 = {
  maximum: { okStr: "<=", ok: ops$1.LTE, fail: ops$1.GT },
  minimum: { okStr: ">=", ok: ops$1.GTE, fail: ops$1.LT },
  exclusiveMaximum: { okStr: "<", ok: ops$1.LT, fail: ops$1.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops$1.GT, fail: ops$1.LTE }
};
const error$B = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$Q.str)`must be ${KWDs$1[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$Q._)`{comparison: ${KWDs$1[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$T = {
  keyword: Object.keys(KWDs$1),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$B,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$Q._)`${data} ${KWDs$1[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber$1.default = def$T;
var multipleOf$1 = {};
Object.defineProperty(multipleOf$1, "__esModule", { value: true });
const codegen_1$P = codegen$1;
const error$A = {
  message: ({ schemaCode }) => (0, codegen_1$P.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$P._)`{multipleOf: ${schemaCode}}`
};
const def$S = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$A,
  code(cxt) {
    const { gen, data, schemaCode, it: it2 } = cxt;
    const prec = it2.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$P._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$P._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$P._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf$1.default = def$S;
var limitLength$1 = {};
var ucs2length$3 = {};
Object.defineProperty(ucs2length$3, "__esModule", { value: true });
function ucs2length$2(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$3.default = ucs2length$2;
ucs2length$2.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength$1, "__esModule", { value: true });
const codegen_1$O = codegen$1;
const util_1$J = util$2;
const ucs2length_1$1 = ucs2length$3;
const error$z = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$O.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$O._)`{limit: ${schemaCode}}`
};
const def$R = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$z,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$O.operators.GT : codegen_1$O.operators.LT;
    const len = it2.opts.unicode === false ? (0, codegen_1$O._)`${data}.length` : (0, codegen_1$O._)`${(0, util_1$J.useFunc)(cxt.gen, ucs2length_1$1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$O._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength$1.default = def$R;
var pattern$1 = {};
Object.defineProperty(pattern$1, "__esModule", { value: true });
const code_1$i = code$2;
const codegen_1$N = codegen$1;
const error$y = {
  message: ({ schemaCode }) => (0, codegen_1$N.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$N._)`{pattern: ${schemaCode}}`
};
const def$Q = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$y,
  code(cxt) {
    const { data, $data, schema, schemaCode, it: it2 } = cxt;
    const u2 = it2.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$N._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1$i.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$N._)`!${regExp}.test(${data})`);
  }
};
pattern$1.default = def$Q;
var limitProperties$1 = {};
Object.defineProperty(limitProperties$1, "__esModule", { value: true });
const codegen_1$M = codegen$1;
const error$x = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$M.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$M._)`{limit: ${schemaCode}}`
};
const def$P = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$x,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$M.operators.GT : codegen_1$M.operators.LT;
    cxt.fail$data((0, codegen_1$M._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties$1.default = def$P;
var required$2 = {};
Object.defineProperty(required$2, "__esModule", { value: true });
const code_1$h = code$2;
const codegen_1$L = codegen$1;
const util_1$I = util$2;
const error$w = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$L.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$L._)`{missingProperty: ${missingProperty}}`
};
const def$O = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$w,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
    const { opts } = it2;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it2.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$I.checkStrictMode)(it2, msg, it2.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$L.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$h.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$h.checkMissingProp)(cxt, schema, missing));
        (0, code_1$h.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$h.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$h.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$L.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$L.nil);
    }
  }
};
required$2.default = def$O;
var limitItems$1 = {};
Object.defineProperty(limitItems$1, "__esModule", { value: true });
const codegen_1$K = codegen$1;
const error$v = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$K.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$K._)`{limit: ${schemaCode}}`
};
const def$N = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$v,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$K.operators.GT : codegen_1$K.operators.LT;
    cxt.fail$data((0, codegen_1$K._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems$1.default = def$N;
var uniqueItems$1 = {};
var equal$4 = {};
Object.defineProperty(equal$4, "__esModule", { value: true });
const equal$3 = fastDeepEqual;
equal$3.code = 'require("ajv/dist/runtime/equal").default';
equal$4.default = equal$3;
Object.defineProperty(uniqueItems$1, "__esModule", { value: true });
const dataType_1$2 = dataType$1;
const codegen_1$J = codegen$1;
const util_1$H = util$2;
const equal_1$5 = equal$4;
const error$u = {
  message: ({ params: { i: i2, j: j2 } }) => (0, codegen_1$J.str)`must NOT have duplicate items (items ## ${j2} and ${i2} are identical)`,
  params: ({ params: { i: i2, j: j2 } }) => (0, codegen_1$J._)`{i: ${i2}, j: ${j2}}`
};
const def$M = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$u,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1$2.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$J._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i2 = gen.let("i", (0, codegen_1$J._)`${data}.length`);
      const j2 = gen.let("j");
      cxt.setParams({ i: i2, j: j2 });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$J._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j2));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i2, j2) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1$2.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1$2.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$J._)`{}`);
      gen.for((0, codegen_1$J._)`;${i2}--;`, () => {
        gen.let(item, (0, codegen_1$J._)`${data}[${i2}]`);
        gen.if(wrongType, (0, codegen_1$J._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$J._)`typeof ${item} == "string"`, (0, codegen_1$J._)`${item} += "_"`);
        gen.if((0, codegen_1$J._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j2, (0, codegen_1$J._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$J._)`${indices}[${item}] = ${i2}`);
      });
    }
    function loopN2(i2, j2) {
      const eql = (0, util_1$H.useFunc)(gen, equal_1$5.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$J._)`;${i2}--;`, () => gen.for((0, codegen_1$J._)`${j2} = ${i2}; ${j2}--;`, () => gen.if((0, codegen_1$J._)`${eql}(${data}[${i2}], ${data}[${j2}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems$1.default = def$M;
var _const$1 = {};
Object.defineProperty(_const$1, "__esModule", { value: true });
const codegen_1$I = codegen$1;
const util_1$G = util$2;
const equal_1$4 = equal$4;
const error$t = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$I._)`{allowedValue: ${schemaCode}}`
};
const def$L = {
  keyword: "const",
  $data: true,
  error: error$t,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$I._)`!${(0, util_1$G.useFunc)(gen, equal_1$4.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$I._)`${schema} !== ${data}`);
    }
  }
};
_const$1.default = def$L;
var _enum$1 = {};
Object.defineProperty(_enum$1, "__esModule", { value: true });
const codegen_1$H = codegen$1;
const util_1$F = util$2;
const equal_1$3 = equal$4;
const error$s = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$H._)`{allowedValues: ${schemaCode}}`
};
const def$K = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$s,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it2.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$F.useFunc)(gen, equal_1$3.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$H.or)(...schema.map((_x, i2) => equalCode(vSchema, i2)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1$H._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i2) {
      const sch = schema[i2];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$H._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1$H._)`${data} === ${sch}`;
    }
  }
};
_enum$1.default = def$K;
Object.defineProperty(validation$3, "__esModule", { value: true });
const limitNumber_1$1 = limitNumber$1;
const multipleOf_1$1 = multipleOf$1;
const limitLength_1$1 = limitLength$1;
const pattern_1$1 = pattern$1;
const limitProperties_1$1 = limitProperties$1;
const required_1$1 = required$2;
const limitItems_1$1 = limitItems$1;
const uniqueItems_1$1 = uniqueItems$1;
const const_1$1 = _const$1;
const enum_1$1 = _enum$1;
const validation$2 = [
  // number
  limitNumber_1$1.default,
  multipleOf_1$1.default,
  // string
  limitLength_1$1.default,
  pattern_1$1.default,
  // object
  limitProperties_1$1.default,
  required_1$1.default,
  // array
  limitItems_1$1.default,
  uniqueItems_1$1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1$1.default,
  enum_1$1.default
];
validation$3.default = validation$2;
var applicator$1 = {};
var additionalItems$1 = {};
Object.defineProperty(additionalItems$1, "__esModule", { value: true });
additionalItems$1.validateAdditionalItems = void 0;
const codegen_1$G = codegen$1;
const util_1$E = util$2;
const error$r = {
  message: ({ params: { len } }) => (0, codegen_1$G.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$G._)`{limit: ${len}}`
};
const def$J = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$r,
  code(cxt) {
    const { parentSchema, it: it2 } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$E.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems$1(cxt, items2);
  }
};
function validateAdditionalItems$1(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it: it2 } = cxt;
  it2.items = true;
  const len = gen.const("len", (0, codegen_1$G._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$G._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$E.alwaysValidSchema)(it2, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$G._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$G.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i2) => {
      cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$E.Type.Num }, valid2);
      if (!it2.allErrors)
        gen.if((0, codegen_1$G.not)(valid2), () => gen.break());
    });
  }
}
additionalItems$1.validateAdditionalItems = validateAdditionalItems$1;
additionalItems$1.default = def$J;
var prefixItems$1 = {};
var items$1 = {};
Object.defineProperty(items$1, "__esModule", { value: true });
items$1.validateTuple = void 0;
const codegen_1$F = codegen$1;
const util_1$D = util$2;
const code_1$g = code$2;
const def$I = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it: it2 } = cxt;
    if (Array.isArray(schema))
      return validateTuple$1(cxt, "additionalItems", schema);
    it2.items = true;
    if ((0, util_1$D.alwaysValidSchema)(it2, schema))
      return;
    cxt.ok((0, code_1$g.validateArray)(cxt));
  }
};
function validateTuple$1(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
  checkStrictTuple(parentSchema);
  if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
    it2.items = util_1$D.mergeEvaluated.items(gen, schArr.length, it2.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$F._)`${data}.length`);
  schArr.forEach((sch, i2) => {
    if ((0, util_1$D.alwaysValidSchema)(it2, sch))
      return;
    gen.if((0, codegen_1$F._)`${len} > ${i2}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      dataProp: i2
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it2;
    const l2 = schArr.length;
    const fullTuple = l2 === sch.minItems && (l2 === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l2}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$D.checkStrictMode)(it2, msg, opts.strictTuples);
    }
  }
}
items$1.validateTuple = validateTuple$1;
items$1.default = def$I;
Object.defineProperty(prefixItems$1, "__esModule", { value: true });
const items_1$3 = items$1;
const def$H = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$3.validateTuple)(cxt, "items")
};
prefixItems$1.default = def$H;
var items2020$1 = {};
Object.defineProperty(items2020$1, "__esModule", { value: true });
const codegen_1$E = codegen$1;
const util_1$C = util$2;
const code_1$f = code$2;
const additionalItems_1$3 = additionalItems$1;
const error$q = {
  message: ({ params: { len } }) => (0, codegen_1$E.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$E._)`{limit: ${len}}`
};
const def$G = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$q,
  code(cxt) {
    const { schema, parentSchema, it: it2 } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it2.items = true;
    if ((0, util_1$C.alwaysValidSchema)(it2, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$3.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$f.validateArray)(cxt));
  }
};
items2020$1.default = def$G;
var contains$1 = {};
Object.defineProperty(contains$1, "__esModule", { value: true });
const codegen_1$D = codegen$1;
const util_1$B = util$2;
const error$p = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$D.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$D.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$D._)`{minContains: ${min}}` : (0, codegen_1$D._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$F = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$p,
  code(cxt) {
    const { gen, schema, parentSchema, data, it: it2 } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it2.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$D._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$B.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$B.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$B.alwaysValidSchema)(it2, schema)) {
      let cond = (0, codegen_1$D._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$D._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it2.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid2, true);
      if (max !== void 0)
        gen.if((0, codegen_1$D._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i2) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i2,
          dataPropType: util_1$B.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$D._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$D._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$D._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$D._)`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains$1.default = def$F;
var dependencies$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
  const codegen_12 = codegen$1;
  const util_12 = util$2;
  const code_12 = code$2;
  exports$1.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports$1.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports$1.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it: it2 } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports$1.validateSchemaDeps = validateSchemaDeps;
  exports$1.default = def2;
})(dependencies$1);
var propertyNames$1 = {};
Object.defineProperty(propertyNames$1, "__esModule", { value: true });
const codegen_1$C = codegen$1;
const util_1$A = util$2;
const error$o = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$C._)`{propertyName: ${params.propertyName}}`
};
const def$E = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$o,
  code(cxt) {
    const { gen, schema, data, it: it2 } = cxt;
    if ((0, util_1$A.alwaysValidSchema)(it2, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$C.not)(valid2), () => {
        cxt.error(true);
        if (!it2.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames$1.default = def$E;
var additionalProperties$2 = {};
Object.defineProperty(additionalProperties$2, "__esModule", { value: true });
const code_1$e = code$2;
const codegen_1$B = codegen$1;
const names_1$7 = names$3;
const util_1$z = util$2;
const error$n = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$B._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$D = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$n,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it2;
    it2.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$z.alwaysValidSchema)(it2, schema))
      return;
    const props = (0, code_1$e.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$e.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$B._)`${errsCount} === ${names_1$7.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$z.schemaRefOrVal)(it2, parentSchema.properties, "properties");
        definedProp = (0, code_1$e.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$B.or)(...props.map((p2) => (0, codegen_1$B._)`${key} === ${p2}`));
      } else {
        definedProp = codegen_1$B.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$B.or)(definedProp, ...patProps.map((p2) => (0, codegen_1$B._)`${(0, code_1$e.usePattern)(cxt, p2)}.test(${key})`));
      }
      return (0, codegen_1$B.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$B._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$z.alwaysValidSchema)(it2, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$B.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$B.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$z.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties$2.default = def$D;
var properties$4 = {};
Object.defineProperty(properties$4, "__esModule", { value: true });
const validate_1$2 = validate$1;
const code_1$d = code$2;
const util_1$y = util$2;
const additionalProperties_1$3 = additionalProperties$2;
const def$C = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it: it2 } = cxt;
    if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$3.default.code(new validate_1$2.KeywordCxt(it2, additionalProperties_1$3.default, "additionalProperties"));
    }
    const allProps = (0, code_1$d.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it2.definedProperties.add(prop);
    }
    if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
      it2.props = util_1$y.mergeEvaluated.props(gen, (0, util_1$y.toHash)(allProps), it2.props);
    }
    const properties2 = allProps.filter((p2) => !(0, util_1$y.alwaysValidSchema)(it2, schema[p2]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$d.propertyInData)(gen, data, prop, it2.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it2.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$4.default = def$C;
var patternProperties$1 = {};
Object.defineProperty(patternProperties$1, "__esModule", { value: true });
const code_1$c = code$2;
const codegen_1$A = codegen$1;
const util_1$x = util$2;
const util_2$2 = util$2;
const def$B = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it: it2 } = cxt;
    const { opts } = it2;
    const patterns = (0, code_1$c.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p2) => (0, util_1$x.alwaysValidSchema)(it2, schema[p2]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it2.props !== true && !(it2.props instanceof codegen_1$A.Name)) {
      it2.props = (0, util_2$2.evaluatedPropsToName)(gen, it2.props);
    }
    const { props } = it2;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it2.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$x.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$A._)`${(0, code_1$c.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2$2.Type.Str
            }, valid2);
          }
          if (it2.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$A._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it2.allErrors) {
            gen.if((0, codegen_1$A.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties$1.default = def$B;
var not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: true });
const util_1$w = util$2;
const def$A = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it: it2 } = cxt;
    if ((0, util_1$w.alwaysValidSchema)(it2, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not$1.default = def$A;
var anyOf$1 = {};
Object.defineProperty(anyOf$1, "__esModule", { value: true });
const code_1$b = code$2;
const def$z = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1$b.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf$1.default = def$z;
var oneOf$1 = {};
Object.defineProperty(oneOf$1, "__esModule", { value: true });
const codegen_1$z = codegen$1;
const util_1$v = util$2;
const error$m = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$z._)`{passingSchemas: ${params.passing}}`
};
const def$y = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$m,
  code(cxt) {
    const { gen, schema, parentSchema, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it2.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i2) => {
        let schCxt;
        if ((0, util_1$v.alwaysValidSchema)(it2, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i2,
            compositeRule: true
          }, schValid);
        }
        if (i2 > 0) {
          gen.if((0, codegen_1$z._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$z._)`[${passing}, ${i2}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i2);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$z.Name);
        });
      });
    }
  }
};
oneOf$1.default = def$y;
var allOf$1 = {};
Object.defineProperty(allOf$1, "__esModule", { value: true });
const util_1$u = util$2;
const def$x = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i2) => {
      if ((0, util_1$u.alwaysValidSchema)(it2, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf$1.default = def$x;
var _if$1 = {};
Object.defineProperty(_if$1, "__esModule", { value: true });
const codegen_1$y = codegen$1;
const util_1$t = util$2;
const error$l = {
  message: ({ params }) => (0, codegen_1$y.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$y._)`{failingKeyword: ${params.ifClause}}`
};
const def$w = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$l,
  code(cxt) {
    const { gen, parentSchema, it: it2 } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$t.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema$1(it2, "then");
    const hasElse = hasSchema$1(it2, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$y.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$y._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema$1(it2, keyword2) {
  const schema = it2.schema[keyword2];
  return schema !== void 0 && !(0, util_1$t.alwaysValidSchema)(it2, schema);
}
_if$1.default = def$w;
var thenElse$1 = {};
Object.defineProperty(thenElse$1, "__esModule", { value: true });
const util_1$s = util$2;
const def$v = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it: it2 }) {
    if (parentSchema.if === void 0)
      (0, util_1$s.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse$1.default = def$v;
Object.defineProperty(applicator$1, "__esModule", { value: true });
const additionalItems_1$2 = additionalItems$1;
const prefixItems_1$1 = prefixItems$1;
const items_1$2 = items$1;
const items2020_1$1 = items2020$1;
const contains_1$1 = contains$1;
const dependencies_1$1 = dependencies$1;
const propertyNames_1$1 = propertyNames$1;
const additionalProperties_1$2 = additionalProperties$2;
const properties_1$1 = properties$4;
const patternProperties_1$1 = patternProperties$1;
const not_1$1 = not$1;
const anyOf_1$1 = anyOf$1;
const oneOf_1$1 = oneOf$1;
const allOf_1$1 = allOf$1;
const if_1$1 = _if$1;
const thenElse_1$1 = thenElse$1;
function getApplicator$1(draft2020 = false) {
  const applicator2 = [
    // any
    not_1$1.default,
    anyOf_1$1.default,
    oneOf_1$1.default,
    allOf_1$1.default,
    if_1$1.default,
    thenElse_1$1.default,
    // object
    propertyNames_1$1.default,
    additionalProperties_1$2.default,
    dependencies_1$1.default,
    properties_1$1.default,
    patternProperties_1$1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1$1.default, items2020_1$1.default);
  else
    applicator2.push(additionalItems_1$2.default, items_1$2.default);
  applicator2.push(contains_1$1.default);
  return applicator2;
}
applicator$1.default = getApplicator$1;
var format$5 = {};
var format$4 = {};
Object.defineProperty(format$4, "__esModule", { value: true });
const codegen_1$x = codegen$1;
const error$k = {
  message: ({ schemaCode }) => (0, codegen_1$x.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$x._)`{format: ${schemaCode}}`
};
const def$u = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$k,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$x._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$x._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$x._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$x._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$x._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$x.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$x.nil;
        return (0, codegen_1$x._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$x._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$x._)`${format2}(${data})`;
        const validData = (0, codegen_1$x._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$x._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$x.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$x._)`${opts.code.formats}${(0, codegen_1$x.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$x._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$x._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$x._)`${fmtRef}(${data})` : (0, codegen_1$x._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$4.default = def$u;
Object.defineProperty(format$5, "__esModule", { value: true });
const format_1$3 = format$4;
const format$3 = [format_1$3.default];
format$5.default = format$3;
var metadata$1 = {};
Object.defineProperty(metadata$1, "__esModule", { value: true });
metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
metadata$1.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata$1.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7$1, "__esModule", { value: true });
const core_1$1 = core$4;
const validation_1$1 = validation$3;
const applicator_1$1 = applicator$1;
const format_1$2 = format$5;
const metadata_1$1 = metadata$1;
const draft7Vocabularies$1 = [
  core_1$1.default,
  validation_1$1.default,
  (0, applicator_1$1.default)(),
  format_1$2.default,
  metadata_1$1.metadataVocabulary,
  metadata_1$1.contentVocabulary
];
draft7$1.default = draft7Vocabularies$1;
var discriminator$1 = {};
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.DiscrError = void 0;
var DiscrError$1;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError$1 || (types$1.DiscrError = DiscrError$1 = {}));
Object.defineProperty(discriminator$1, "__esModule", { value: true });
const codegen_1$w = codegen$1;
const types_1$1 = types$1;
const compile_1$2 = compile$1;
const ref_error_1$2 = ref_error$1;
const util_1$r = util$2;
const error$j = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1$1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$w._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def$t = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: error$j,
  code(cxt) {
    const { gen, data, schema, parentSchema, it: it2 } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it2.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1$w._)`${data}${(0, codegen_1$w.getProperty)(tagName)}`);
    gen.if((0, codegen_1$w._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1$1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1$w._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1$1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1$w.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i2 = 0; i2 < oneOf2.length; i2++) {
        let sch = oneOf2[i2];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$r.schemaHasRulesButRef)(sch, it2.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1$2.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
          if (sch instanceof compile_1$2.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1$2.default(it2.opts.uriResolver, it2.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i2);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i2) {
        if (sch.const) {
          addMapping(sch.const, i2);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i2);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i2) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i2;
      }
    }
  }
};
discriminator$1.default = def$t;
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const $id$2 = "http://json-schema.org/draft-07/schema#";
const title$1 = "Core schema meta-schema";
const definitions$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$2 = [
  "object",
  "boolean"
];
const properties$3 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3$1 = {
  $schema: $schema$1,
  $id: $id$2,
  title: title$1,
  definitions: definitions$1,
  type: type$2,
  properties: properties$3,
  "default": true
};
(function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
  const core_12 = core$5;
  const draft7_1 = draft7$1;
  const discriminator_1 = discriminator$1;
  const draft7MetaSchema = require$$3$1;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports$1.Ajv = Ajv;
  module.exports = exports$1 = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.default = Ajv;
  var validate_12 = validate$1;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen$1;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error$1;
  Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error$1;
  Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv$1, ajv$1.exports);
var ajvExports$1 = ajv$1.exports;
var dist = { exports: {} };
var formats = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.formatNames = exports$1.fastFormats = exports$1.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports$1.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports$1.fastFormats = {
    ...exports$1.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports$1.formatNames = Object.keys(exports$1.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -2147483648;
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e2) {
      return false;
    }
  }
})(formats);
var limit = {};
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports$1._CodeOrName = _CodeOrName;
  exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports$1.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports$1.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c2) => {
        if (c2 instanceof Name)
          names2[c2.str] = (names2[c2.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports$1._Code = _Code;
  exports$1.nil = new _Code("");
  function _2(strs, ...args) {
    const code2 = [strs[0]];
    let i2 = 0;
    while (i2 < args.length) {
      addCodeArg(code2, args[i2]);
      code2.push(strs[++i2]);
    }
    return new _Code(code2);
  }
  exports$1._ = _2;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i2 = 0;
    while (i2 < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i2]);
      expr.push(plus, safeStringify(strs[++i2]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports$1.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports$1.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i2 = 1;
    while (i2 < expr.length - 1) {
      if (expr[i2] === plus) {
        const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
        if (res !== void 0) {
          expr.splice(i2 - 1, 3, res);
          continue;
        }
        expr[i2++] = "+";
      }
      i2++;
    }
  }
  function mergeExprItems(a2, b2) {
    if (b2 === '""')
      return a2;
    if (a2 === '""')
      return b2;
    if (typeof a2 == "string") {
      if (b2 instanceof Name || a2[a2.length - 1] !== '"')
        return;
      if (typeof b2 != "string")
        return `${a2.slice(0, -1)}${b2}"`;
      if (b2[0] === '"')
        return a2.slice(0, -1) + b2.slice(1);
      return;
    }
    if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name))
      return `"${a2}${b2.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports$1.strConcat = strConcat;
  function interpolate(x3) {
    return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
  }
  function stringify(x3) {
    return new _Code(safeStringify(x3));
  }
  exports$1.stringify = stringify;
  function safeStringify(x3) {
    return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports$1.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
  }
  exports$1.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports$1.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports$1.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
  exports$1.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports$1.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports$1.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c2 = valueCode(name);
          if (c2) {
            const def2 = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c2};${this.opts._n}`;
          } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c2}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports$1.ValueScope = ValueScope;
})(scope);
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports$1.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i2, 1, ...n);
        else if (n)
          nodes[i2] = n;
        else
          nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e2 = this.else;
      if (e2) {
        const ns = e2.optimizeNodes();
        e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e2) {
        if (cond === false)
          return e2 instanceof If ? e2 : e2.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e2 instanceof If ? [e2] : e2.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c2) {
      if (typeof c2 == "function")
        c2();
      else if (c2 !== code_12.nil)
        this._leafNode(new AnyCode(c2));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i2) => {
          this.var(name, (0, code_12._)`${arr}[${i2}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports$1.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c2) => {
      if (c2 instanceof code_12.Name)
        c2 = replaceName(c2);
      if (c2 instanceof code_12._Code)
        items2.push(...c2._items);
      else
        items2.push(c2);
      return items2;
    }, []));
    function replaceName(n) {
      const c2 = constants2[n.str];
      if (c2 === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c2;
    }
    function canOptimize(e2) {
      return e2 instanceof code_12._Code && e2._items.some((c2) => c2 instanceof code_12.Name && names2[c2.str] === 1 && constants2[c2.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x3) {
    return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_12._)`!${par(x3)}`;
  }
  exports$1.not = not2;
  const andCode = mappend(exports$1.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports$1.and = and;
  const orCode = mappend(exports$1.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports$1.or = or;
  function mappend(op) {
    return (x3, y2) => x3 === code_12.nil ? y2 : y2 === code_12.nil ? x3 : (0, code_12._)`${par(x3)} ${op} ${par(y2)}`;
  }
  function par(x3) {
    return x3 instanceof code_12.Name ? x3 : (0, code_12._)`(${x3})`;
  }
})(codegen);
var util$1 = {};
Object.defineProperty(util$1, "__esModule", { value: true });
util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
const codegen_1$v = codegen;
const code_1$a = code$1;
function toHash(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util$1.toHash = toHash;
function alwaysValidSchema(it2, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules(it2, schema);
  return !schemaHasRules(schema, it2.self.RULES.all);
}
util$1.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it2, schema = it2.schema) {
  const { opts, self: self2 } = it2;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema) {
    if (!rules2[key])
      checkStrictMode(it2, `unknown keyword: "${key}"`);
  }
}
util$1.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (rules2[key])
      return true;
  return false;
}
util$1.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util$1.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$v._)`${schema}`;
  }
  return (0, codegen_1$v._)`${topSchemaRef}${schemaPath}${(0, codegen_1$v.getProperty)(keyword2)}`;
}
util$1.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
util$1.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
util$1.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util$1.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util$1.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f3) {
  if (Array.isArray(xs)) {
    for (const x3 of xs)
      f3(x3);
  } else {
    f3(xs);
  }
}
util$1.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
  return (gen, from, to, toName) => {
    const res = to === void 0 ? from : to instanceof codegen_1$v.Name ? (from instanceof codegen_1$v.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$v.Name ? (mergeToName(gen, to, from), from) : mergeValues2(from, to);
    return toName === codegen_1$v.Name && !(res instanceof codegen_1$v.Name) ? resultToName(gen, res) : res;
  };
}
util$1.mergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true && ${from} !== undefined`, () => {
      gen.if((0, codegen_1$v._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$v._)`${to} || {}`).code((0, codegen_1$v._)`Object.assign(${to}, ${from})`));
    }),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true`, () => {
      if (from === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$v._)`${to} || {}`);
        setEvaluated(gen, to, from);
      }
    }),
    mergeValues: (from, to) => from === true ? true : { ...from, ...to },
    resultToName: evaluatedPropsToName
  }),
  items: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$v._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$v._)`${to} > ${from} ? ${to} : ${from}`)),
    mergeValues: (from, to) => from === true ? true : Math.max(from, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$v._)`{}`);
  if (ps !== void 0)
    setEvaluated(gen, props, ps);
  return props;
}
util$1.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
  Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1$v._)`${props}${(0, codegen_1$v.getProperty)(p2)}`, true));
}
util$1.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f3) {
  return gen.scopeValue("func", {
    ref: f3,
    code: snippets[f3.code] || (snippets[f3.code] = new code_1$a._Code(f3.code))
  });
}
util$1.useFunc = useFunc;
var Type;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type || (util$1.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$v.Name) {
    const isNumber = dataPropType === Type.Num;
    return jsPropertySyntax ? isNumber ? (0, codegen_1$v._)`"[" + ${dataProp} + "]"` : (0, codegen_1$v._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$v._)`"/" + ${dataProp}` : (0, codegen_1$v._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$v.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util$1.getErrorPath = getErrorPath;
function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it2.self.logger.warn(msg);
}
util$1.checkStrictMode = checkStrictMode;
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$u = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$u.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$u.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$u.Name("instancePath"),
  parentData: new codegen_1$u.Name("parentData"),
  parentDataProperty: new codegen_1$u.Name("parentDataProperty"),
  rootData: new codegen_1$u.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$u.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$u.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$u.Name("errors"),
  // counter of validation errors
  this: new codegen_1$u.Name("this"),
  // "globals"
  self: new codegen_1$u.Name("self"),
  scope: new codegen_1$u.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$u.Name("json"),
  jsonPos: new codegen_1$u.Name("jsonPos"),
  jsonLen: new codegen_1$u.Name("jsonLen"),
  jsonPart: new codegen_1$u.Name("jsonPart")
};
names$1.default = names;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util$1;
  const names_12 = names$1;
  exports$1.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports$1.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports$1.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports$1.reportError = reportError;
  function reportExtraError(cxt, error2 = exports$1.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_12.default.vErrors);
    }
  }
  exports$1.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports$1.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i2}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it2.errSchemaPath}/${keyword2}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports$1.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E2 = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E2.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E2.keyword, keyword2], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E2.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors;
const codegen_1$t = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it2) {
  const { gen, schema, validateName } = it2;
  if (schema === false) {
    falseSchemaError(it2, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign((0, codegen_1$t._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it2, valid2) {
  const { gen, schema } = it2;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError(it2);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it2, overrideAllErrors) {
  const { gen, data } = it2;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it: it2
  };
  (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x3) {
  return typeof x3 == "string" && jsonTypes.has(x3);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
  return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
  var _a;
  return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const util_1$q = util$1;
var DataType;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema) {
  const types2 = getJSONTypes(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it2, types2) {
  const { gen, data, opts } = it2;
  const coerceTo = coerceToTypes(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it2, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData(it2, types2, coerceTo);
      else
        reportTypeError(it2);
    });
  }
  return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData(it2, types2, coerceTo) {
  const { gen, data, opts } = it2;
  const dataType2 = gen.let("dataType", (0, codegen_1$s._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$s._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$s._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$s._)`${data}[0]`).assign(dataType2, (0, codegen_1$s._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError(it2);
  gen.endIf();
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData(it2, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$s._)`"" + ${data}`).elseIf((0, codegen_1$s._)`${data} === null`).assign(coerced, (0, codegen_1$s._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$s._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$s._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$s._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$s._)`[${data}]`);
    }
  }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$s._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$s._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
  const EQ = correct === DataType.Correct ? codegen_1$s.operators.EQ : codegen_1$s.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$s._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$s._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$s._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$s._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$s._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType.Correct ? cond : (0, codegen_1$s.not)(cond);
  function numCond(_cond = codegen_1$s.nil) {
    return (0, codegen_1$s.and)((0, codegen_1$s._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$s._)`isFinite(${data})` : codegen_1$s.nil);
  }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$q.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$s._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$s._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$s.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$s.and)(cond, checkDataType(t2, data, strictNums, correct));
  return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$s._)`{type: ${schema}}` : (0, codegen_1$s._)`{type: ${schemaValue}}`
};
function reportTypeError(it2) {
  const cxt = getTypeErrorContext(it2);
  (0, errors_1$2.reportError)(cxt, typeError);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it2) {
  const { gen, data, schema } = it2;
  const schemaCode = (0, util_1$q.schemaRefOrVal)(it2, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it: it2
  };
}
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$p = util$1;
function assignDefaults(it2, ty) {
  const { properties: properties2, items: items2 } = it2.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it2, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i2) => assignDefault(it2, i2, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it2, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it2;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$p.checkStrictMode)(it2, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$r._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$r._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$r._)`${childData} = ${(0, codegen_1$r.stringify)(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$o = util$1;
const names_1$5 = names$1;
const util_2$1 = util$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it: it2 } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$q._)`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$q.or)(...properties2.map((prop) => (0, codegen_1$q.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$q._)`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$q._)`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return (0, codegen_1$q._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$q._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$q.or)(cond, (0, codegen_1$q.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it2, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1$o.alwaysValidSchema)(it2, schemaMap[p2]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$q._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, (0, codegen_1$q.strConcat)(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it2.parentData],
    [names_1$5.default.parentDataProperty, it2.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it2.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = (0, codegen_1$q._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? (0, codegen_1$q._)`${func}.call(${context}, ${args})` : (0, codegen_1$q._)`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$q._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u2 = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u2);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$q._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it: it2 } = cxt;
  const valid2 = gen.name("valid");
  if (it2.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$q._)`${data}.length`);
    gen.forRange("i", 0, len, (i2) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i2,
        dataPropType: util_1$o.Type.Num
      }, valid2);
      gen.if((0, codegen_1$q.not)(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema, keyword: keyword2, it: it2 } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$o.alwaysValidSchema)(it2, sch));
  if (alwaysValid && !it2.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i2) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$q._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$q.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
  const macroSchema = def2.macro.call(it2.self, schema, parentSchema, it2);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it2.opts.validateSchema !== false)
    it2.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
  checkAsyncKeyword(it2, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it2.self, schema, parentSchema, it2) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$p._)`await `), (e2) => gen.assign(valid2, false).if((0, codegen_1$p._)`${e2} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$p._)`${e2}.errors`), () => gen.throw(e2)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$p._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$p._)`await ` : codegen_1$p.nil) {
    const passCxt = it2.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$p._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$p.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it: it2 } = cxt;
  gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1$p._)`${it2.parentData}[${it2.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$p._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$p.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$n = util$1;
function getSubschema(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it2.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$o._)`${it2.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$o._)`${it2.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}${(0, codegen_1$o.getProperty)(schemaProp)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1$n.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it2;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it2;
    const nextData = gen.let("data", (0, codegen_1$o._)`${it2.data}${(0, codegen_1$o.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$o.str)`${errorPath}${(0, util_1$n.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$o._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it2.dataLevel + 1;
    subschema2.dataTypes = [];
    it2.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it2.data;
    subschema2.dataNames = [...it2.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i2 = 0; i2 < sch.length; i2++)
            _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$m = util$1;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema, limit2 = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema);
  if (!limit2)
    return false;
  return countKeys(schema) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema) {
  for (const key in schema) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema) {
  let count = 0;
  for (const key in schema) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema[key] == "object") {
      (0, util_1$m.eachItem)(schema[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(resolver, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId(id2);
  const p2 = resolver.parse(id2);
  return _getFullPath(resolver, p2);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(resolver, p2) {
  const serialized = resolver.serialize(p2);
  return serialized.split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$l = util$1;
const errors_1 = errors;
function validateFunctionCode(it2) {
  if (isSchemaObj(it2)) {
    checkKeywords(it2);
    if (schemaCxtHasRules(it2)) {
      topSchemaObjCode(it2);
      return;
    }
  }
  validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$n._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$n._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$n._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`""`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`{}`);
  });
}
function topSchemaObjCode(it2) {
  const { schema, opts, gen } = it2;
  validateFunction(it2, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    checkNoDefault(it2);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it2);
    typeAndKeywords(it2);
    returnResults(it2);
  });
  return;
}
function resetEvaluated(it2) {
  const { gen, validateName } = it2;
  it2.evaluated = gen.const("evaluated", (0, codegen_1$n._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$n._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$n._)`${it2.evaluated}.props`, (0, codegen_1$n._)`undefined`));
  gen.if((0, codegen_1$n._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$n._)`${it2.evaluated}.items`, (0, codegen_1$n._)`undefined`));
}
function funcSourceUrl(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$n._)`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it2, valid2) {
  if (isSchemaObj(it2)) {
    checkKeywords(it2);
    if (schemaCxtHasRules(it2)) {
      subSchemaObjCode(it2, valid2);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it2, valid2);
}
function schemaCxtHasRules({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it2) {
  return typeof it2.schema != "boolean";
}
function subSchemaObjCode(it2, valid2) {
  const { schema, gen, opts } = it2;
  if (opts.$comment && schema.$comment)
    commentKeyword(it2);
  updateContext(it2);
  checkAsyncSchema(it2);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it2, errsCount);
  gen.var(valid2, (0, codegen_1$n._)`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it2) {
  (0, util_1$l.checkUnknownRules)(it2);
  checkRefsAndKeywords(it2);
}
function typeAndKeywords(it2, errsCount) {
  if (it2.opts.jtd)
    return schemaKeywords(it2, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it2.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it2, types2);
  schemaKeywords(it2, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it2) {
  const { schema, errSchemaPath, opts, self: self2 } = it2;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$l.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it2) {
  const { schema, opts } = it2;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$l.checkStrictMode)(it2, "default is ignored in the schema root");
  }
}
function updateContext(it2) {
  const schId = it2.schema[it2.opts.schemaId];
  if (schId)
    it2.baseId = (0, resolve_1$2.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
}
function checkAsyncSchema(it2) {
  if (it2.schema.$async && !it2.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$n.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it2) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError3, opts } = it2;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$n._)`new ${ValidationError3}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$n._)`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it2);
    gen.return((0, codegen_1$n._)`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.items`, items2);
}
function schemaKeywords(it2, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it2;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$l.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it2, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it2, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it2);
      }
      gen.endIf();
    } else {
      iterateKeywords(it2, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it2, group) {
  const { gen, schema, opts: { useDefaults } } = it2;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it2, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema, rule)) {
        keywordCode(it2, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it2, types2) {
  if (it2.schemaEnv.meta || !it2.opts.strictTypes)
    return;
  checkContextTypes(it2, types2);
  if (!it2.opts.allowUnionTypes)
    checkMultipleTypes(it2, types2);
  checkKeywordTypes(it2, it2.dataTypes);
}
function checkContextTypes(it2, types2) {
  if (!types2.length)
    return;
  if (!it2.dataTypes.length) {
    it2.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it2.dataTypes, t2)) {
      strictTypesError(it2, `type "${t2}" not allowed by context "${it2.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it2, types2);
}
function checkMultipleTypes(it2, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it2, ts) {
  const rules2 = it2.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes(it2, withTypes) {
  const ts = [];
  for (const t2 of it2.dataTypes) {
    if (includesType(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it2.dataTypes = ts;
}
function strictTypesError(it2, msg) {
  const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$l.checkStrictMode)(it2, msg, it2.opts.strictTypes);
}
class KeywordCxt2 {
  constructor(it2, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it2, def2, keyword2);
    this.gen = it2.gen;
    this.allErrors = it2.allErrors;
    this.keyword = keyword2;
    this.data = it2.data;
    this.schema = it2.schema[keyword2];
    this.$data = def2.$data && it2.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$l.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it2.schema;
    this.params = {};
    this.it = it2;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it2.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$n._)`${schemaCode} !== undefined && (${(0, codegen_1$n.or)(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$n.or)((0, codegen_1$n._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it: it2 } = this;
    return (0, codegen_1$n.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$n._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$n._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it: it2, gen } = this;
    if (!it2.opts.unevaluated)
      return;
    if (it2.props !== true && schemaCxt.props !== void 0) {
      it2.props = util_1$l.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
    }
    if (it2.items !== true && schemaCxt.items !== void 0) {
      it2.items = util_1$l.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it: it2, gen } = this;
    if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt2;
function keywordCode(it2, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt2(it2, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$n._)`${data}${(0, codegen_1$n.getProperty)((0, util_1$l.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$n._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError2 extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError2;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError2 extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
  }
}
ref_error.default = MissingRefError2;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$k = util$1;
const validate_1$1 = validate;
class SchemaEnv2 {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv2;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$m._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$m._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$m.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e2) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e2;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root, ref2);
  if (_sch === void 0) {
    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv2({ schema, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p2 = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p2, root);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p2, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv2({ schema, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p2, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$k.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv2({ schema, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
var uri$1 = {};
Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = fastUriExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_12 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util$1;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$1;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _0;
    const s2 = o2.strict;
    const _optz = (_a = o2.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o2.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o2.strictSchema) !== null && _e !== void 0 ? _e : s2) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s2) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s2) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== void 0 ? _o : s2) !== null && _p !== void 0 ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o2.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o2.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t2 = o2.messages) !== null && _t2 !== void 0 ? _t2 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid2 = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e2) {
          if (!(e2 instanceof ref_error_12.default))
            throw e2;
          checkLoaded.call(this, e2);
          await loadMissingSchema.call(this, e2.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p2 = this._loading[ref2];
        if (p2)
          return p2;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t2) => addRule.call(this, k2, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i2 >= 0)
          group.rules.splice(i2, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports$1.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i2 >= 0) {
      ruleGroup.rules.splice(i2, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1$1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1$1 = compile;
const util_1$j = util$1;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it: it2 } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it2;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$1.default(it2.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, (0, codegen_1$l._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v2 = getValidate(cxt, sch);
      callRef(cxt, v2, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$l._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v2, sch, $async) {
  const { gen, it: it2 } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it2;
  const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$l._)`await ${(0, code_1$8.callValidateCode)(cxt, v2, passCxt)}`);
      addEvaluatedFrom(v2);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e2) => {
      gen.if((0, codegen_1$l._)`!(${e2} instanceof ${it2.ValidationError})`, () => gen.throw(e2));
      addErrorsFrom(e2);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$8.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$l._)`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, (0, codegen_1$l._)`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it2.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it2.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it2.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$l._)`${source2}.evaluated.props`);
        it2.props = util_1$j.mergeEvaluated.props(gen, props, it2.props, codegen_1$l.Name);
      }
    }
    if (it2.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it2.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$l._)`${source2}.evaluated.items`);
        it2.items = util_1$j.mergeEvaluated.items(gen, items2, it2.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$k._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => (0, codegen_1$j.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$j._)`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it: it2 } = cxt;
    const prec = it2.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$j._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$j._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$j._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$i = util$1;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it2.opts.unicode === false ? (0, codegen_1$i._)`${data}.length` : (0, codegen_1$i._)`${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$i._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => (0, codegen_1$h.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$h._)`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema, schemaCode, it: it2 } = cxt;
    const u2 = it2.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$h._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1$7.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$h._)`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$g.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$g._)`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data((0, codegen_1$g._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$h = util$1;
const error$d = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$f.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$f._)`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
    const { opts } = it2;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it2.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$h.checkStrictMode)(it2, msg, it2.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$6.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
        (0, code_1$6.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$f.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$e.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$e._)`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data((0, codegen_1$e._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$g = util$1;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i: i2, j: j2 } }) => (0, codegen_1$d.str)`must NOT have duplicate items (items ## ${j2} and ${i2} are identical)`,
  params: ({ params: { i: i2, j: j2 } }) => (0, codegen_1$d._)`{i: ${i2}, j: ${j2}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$d._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i2 = gen.let("i", (0, codegen_1$d._)`${data}.length`);
      const j2 = gen.let("j");
      cxt.setParams({ i: i2, j: j2 });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$d._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j2));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i2, j2) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$d._)`{}`);
      gen.for((0, codegen_1$d._)`;${i2}--;`, () => {
        gen.let(item, (0, codegen_1$d._)`${data}[${i2}]`);
        gen.if(wrongType, (0, codegen_1$d._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$d._)`typeof ${item} == "string"`, (0, codegen_1$d._)`${item} += "_"`);
        gen.if((0, codegen_1$d._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j2, (0, codegen_1$d._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$d._)`${indices}[${item}] = ${i2}`);
      });
    }
    function loopN2(i2, j2) {
      const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$d._)`;${i2}--;`, () => gen.for((0, codegen_1$d._)`${j2} = ${i2}; ${j2}--;`, () => gen.if((0, codegen_1$d._)`${eql}(${data}[${i2}], ${data}[${j2}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$f = util$1;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$c._)`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$c._)`!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$c._)`${schema} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util$1;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$b._)`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it2.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$e.useFunc)(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$b.or)(...schema.map((_x, i2) => equalCode(vSchema, i2)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1$b._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i2) {
      const sch = schema[i2];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$b._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1$b._)`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$d = util$1;
const error$8 = {
  message: ({ params: { len } }) => (0, codegen_1$a.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$a._)`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it: it2 } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$d.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it: it2 } = cxt;
  it2.items = true;
  const len = gen.const("len", (0, codegen_1$a._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$a._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$d.alwaysValidSchema)(it2, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$a._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$a.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i2) => {
      cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$d.Type.Num }, valid2);
      if (!it2.allErrors)
        gen.if((0, codegen_1$a.not)(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$c = util$1;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it: it2 } = cxt;
    if (Array.isArray(schema))
      return validateTuple(cxt, "additionalItems", schema);
    it2.items = true;
    if ((0, util_1$c.alwaysValidSchema)(it2, schema))
      return;
    cxt.ok((0, code_1$5.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
  checkStrictTuple(parentSchema);
  if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
    it2.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it2.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
  schArr.forEach((sch, i2) => {
    if ((0, util_1$c.alwaysValidSchema)(it2, sch))
      return;
    gen.if((0, codegen_1$9._)`${len} > ${i2}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      dataProp: i2
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it2;
    const l2 = schArr.length;
    const fullTuple = l2 === sch.minItems && (l2 === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l2}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$c.checkStrictMode)(it2, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$b = util$1;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => (0, codegen_1$8.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$8._)`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema, parentSchema, it: it2 } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it2.items = true;
    if ((0, util_1$b.alwaysValidSchema)(it2, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$4.validateArray)(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$a = util$1;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$7.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7._)`{minContains: ${min}}` : (0, codegen_1$7._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema, parentSchema, data, it: it2 } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it2.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$7._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$a.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$a.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$a.alwaysValidSchema)(it2, schema)) {
      let cond = (0, codegen_1$7._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$7._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it2.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid2, true);
      if (max !== void 0)
        gen.if((0, codegen_1$7._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i2) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i2,
          dataPropType: util_1$a.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$7._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$7._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util$1;
  const code_12 = code;
  exports$1.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports$1.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports$1.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it: it2 } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports$1.validateSchemaDeps = validateSchemaDeps;
  exports$1.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$9 = util$1;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$6._)`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema, data, it: it2 } = cxt;
    if ((0, util_1$9.alwaysValidSchema)(it2, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$6.not)(valid2), () => {
        cxt.error(true);
        if (!it2.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$8 = util$1;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$5._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it2;
    it2.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it2, schema))
      return;
    const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$5._)`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$8.schemaRefOrVal)(it2, parentSchema.properties, "properties");
        definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$5.or)(...props.map((p2) => (0, codegen_1$5._)`${key} === ${p2}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p2) => (0, codegen_1$5._)`${(0, code_1$3.usePattern)(cxt, p2)}.test(${key})`));
      }
      return (0, codegen_1$5.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$5._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it2, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$5.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$5.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$8.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$7 = util$1;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it: it2 } = cxt;
    if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$2.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it2.definedProperties.add(prop);
    }
    if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
      it2.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it2.props);
    }
    const properties2 = allProps.filter((p2) => !(0, util_1$7.alwaysValidSchema)(it2, schema[p2]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$2.propertyInData)(gen, data, prop, it2.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it2.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$6 = util$1;
const util_2 = util$1;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it: it2 } = cxt;
    const { opts } = it2;
    const patterns = (0, code_1$1.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p2) => (0, util_1$6.alwaysValidSchema)(it2, schema[p2]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it2.props !== true && !(it2.props instanceof codegen_1$4.Name)) {
      it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
    }
    const { props } = it2;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it2.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$6.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$4._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it2.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$4._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it2.allErrors) {
            gen.if((0, codegen_1$4.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util$1;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it: it2 } = cxt;
    if ((0, util_1$5.alwaysValidSchema)(it2, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$4 = util$1;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$3._)`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema, parentSchema, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it2.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i2) => {
        let schCxt;
        if ((0, util_1$4.alwaysValidSchema)(it2, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i2,
            compositeRule: true
          }, schValid);
        }
        if (i2 > 0) {
          gen.if((0, codegen_1$3._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$3._)`[${passing}, ${i2}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i2);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util$1;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i2) => {
      if ((0, util_1$3.alwaysValidSchema)(it2, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$2 = util$1;
const error$2 = {
  message: ({ params }) => (0, codegen_1$2.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$2._)`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it: it2 } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$2.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it2, "then");
    const hasElse = hasSchema(it2, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$2._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it2, keyword2) {
  const schema = it2.schema[keyword2];
  return schema !== void 0 && !(0, util_1$2.alwaysValidSchema)(it2, schema);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util$1;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it: it2 }) {
    if (parentSchema.if === void 0)
      (0, util_1$1.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => (0, codegen_1$1.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$1._)`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$1._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$1.nil;
        return (0, codegen_1$1._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$1._)`${format2}(${data})`;
        const validData = (0, codegen_1$1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$1._)`${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$1._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$1._)`${fmtRef}(${data})` : (0, codegen_1$1._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
types.DiscrError = void 0;
var DiscrError;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError || (types.DiscrError = DiscrError = {}));
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const compile_1 = compile;
const ref_error_1 = ref_error;
const util_1 = util$1;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema, parentSchema, it: it2 } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it2.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
    gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i2 = 0; i2 < oneOf2.length; i2++) {
        let sch = oneOf2[i2];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
          if (sch instanceof compile_1.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i2);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i2) {
        if (sch.const) {
          addMapping(sch.const, i2);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i2);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i2) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i2;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports$1.Ajv = Ajv;
  module.exports = exports$1 = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.formatLimitDefinition = void 0;
  const ajv_1 = ajvExports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports$1.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it: it2 } = cxt;
      const { opts, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports$1.formatLimitDefinition);
    return ajv2;
  };
  exports$1.default = formatLimitPlugin;
})(limit);
(function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv2, opts, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f3 = formats2[name];
    if (!f3)
      throw new Error(`Unknown format "${name}"`);
    return f3;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f3 of list)
      ajv2.addFormat(f3, fs2[f3]);
  }
  module.exports = exports$1 = formatsPlugin;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.default = formatsPlugin;
})(dist, dist.exports);
var distExports = dist.exports;
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module, exports$1) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports$1 = module.exports = {};
  const re2 = exports$1.re = [];
  const safeRe = exports$1.safeRe = [];
  const src = exports$1.src = [];
  const safeSrc = exports$1.safeSrc = [];
  const t2 = exports$1.t = {};
  let R2 = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R2++;
    debug2(name, index, value);
    t2[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports$1.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports$1.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports$1.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a2, b2) => {
  if (typeof a2 === "number" && typeof b2 === "number") {
    return a2 === b2 ? 0 : a2 < b2 ? -1 : 1;
  }
  const anum = numeric.test(a2);
  const bnum = numeric.test(b2);
  if (anum && bnum) {
    a2 = +a2;
    b2 = +b2;
  }
  return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
};
const rcompareIdentifiers = (a2, b2) => compareIdentifiers$1(b2, a2);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.major < other.major) {
      return -1;
    }
    if (this.major > other.major) {
      return 1;
    }
    if (this.minor < other.minor) {
      return -1;
    }
    if (this.minor > other.minor) {
      return 1;
    }
    if (this.patch < other.patch) {
      return -1;
    }
    if (this.patch > other.patch) {
      return 1;
    }
    return 0;
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a2 = this.prerelease[i2];
      const b2 = other.prerelease[i2];
      debug("prerelease compare", i2, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i2 = 0;
    do {
      const a2 = this.build[i2];
      const b2 = other.build[i2];
      debug("build compare", i2, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i2);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
      }
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$1 = SemVer$d;
const SemVer$c = semver$1;
const parse$6 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version;
  }
  try {
    return new SemVer$c(version, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version, options) => {
  const v2 = parse$5(version, options);
  return v2 ? v2.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version, options) => {
  const s2 = parse$4(version.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$1;
const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version instanceof SemVer$b ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return "minor";
      }
      return "patch";
    }
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$1;
const major$1 = (a2, loose) => new SemVer$a(a2, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$1;
const minor$1 = (a2, loose) => new SemVer$9(a2, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$1;
const patch$1 = (a2, loose) => new SemVer$8(a2, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version, options) => {
  const parsed = parse$2(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$1;
const compare$b = (a2, b2, loose) => new SemVer$7(a2, loose).compare(new SemVer$7(b2, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a2, b2, loose) => compare$a(b2, a2, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a2, b2) => compare$9(a2, b2, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$1;
const compareBuild$3 = (a2, b2, loose) => {
  const versionA = new SemVer$6(a2, loose);
  const versionB = new SemVer$6(b2, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$2(a2, b2, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$1(b2, a2, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a2, b2, loose) => compare$8(a2, b2, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a2, b2, loose) => compare$7(a2, b2, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a2, b2, loose) => compare$6(a2, b2, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a2, b2, loose) => compare$5(a2, b2, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a2, b2, loose) => compare$4(a2, b2, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a2, b2, loose) => compare$3(a2, b2, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a2, op, b2, loose) => {
  switch (op) {
    case "===":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 === b2;
    case "!==":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 !== b2;
    case "":
    case "=":
    case "==":
      return eq$1(a2, b2, loose);
    case "!=":
      return neq$1(a2, b2, loose);
    case ">":
      return gt$3(a2, b2, loose);
    case ">=":
      return gte$2(a2, b2, loose);
    case "<":
      return lt$2(a2, b2, loose);
    case "<=":
      return lte$2(a2, b2, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$1;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.map.get(key);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
  set(key, value) {
    const deleted = this.delete(key);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (i2 > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i2];
          for (let k2 = 0; k2 < comps.length; k2++) {
            if (k2 > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k2].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c2) => c2.value === "<0.0.0-0";
  const isAny = (c2) => c2.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    comp = comp.replace(re2[t2.BUILD], "");
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r3 = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r3, (_2, M2, m2, p2, pr) => {
      debug2("tilde", comp, _2, M2, m2, p2, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX(p2)) {
        ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m2}.${p2} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r3 = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r3, (_2, M2, m2, p2, pr) => {
      debug2("caret", comp, _2, M2, m2, p2, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
      } else if (isX(p2)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p2} <${+M2 + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r3 = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r3, (ret, gtlt, M2, m2, p2, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m2, p2, pr);
      const xM = isX(M2);
      const xm = xM || isX(m2);
      const xp = xm || isX(p2);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p2 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p2 = 0;
          } else {
            m2 = +m2 + 1;
            p2 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M2}.${m2}.${p2}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version, options) => {
    for (let i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i2 = 0; i2 < set.length; i2++) {
        debug2(set[i2].semver);
        if (set[i2].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          const allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r3 = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m2 = comp.match(r3);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY2 || version === ANY2) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$1;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v2) => {
    if (rangeObj.test(v2)) {
      if (!max || maxSV.compare(v2) === -1) {
        max = v2;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v2) => {
    if (rangeObj.test(v2)) {
      if (!min || minSV.compare(v2) === 1) {
        min = v2;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$1;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version, range2, hilo, options) => {
  version = new SemVer$1(version, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version, range2, options) => outside$2(version, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version, range2, options) => outside$1(version, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r22, options) => {
  r1 = new Range$2(r1, options);
  r22 = new Range$2(r22, options);
  return r1.intersects(r22, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let first = null;
  let prev = null;
  const v2 = versions.sort((a2, b2) => compare$2(a2, b2, options));
  for (const version of v2) {
    const included = satisfies$2(version, range2, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set.push([first, null]);
  }
  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v2[0]) {
      ranges.push("*");
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v2[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c2 of sub) {
    if (c2.operator === ">" || c2.operator === ">=") {
      gt2 = higherGT(gt2, c2, options);
    } else if (c2.operator === "<" || c2.operator === "<=") {
      lt2 = lowerLT(lt2, c2, options);
    } else {
      eqSet.add(c2.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c2 of dom) {
      if (!satisfies$1(eq2, String(c2), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c2 of dom) {
    hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
    hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c2.operator === ">" || c2.operator === ">=") {
        higher = higherGT(gt2, c2, options);
        if (higher === c2 && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c2.operator === "<" || c2.operator === "<=") {
        lower = lowerLT(lt2, c2, options);
        if (lower === c2 && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a2, b2, options) => {
  if (!a2) {
    return b2;
  }
  const comp = compare$1(a2.semver, b2.semver, options);
  return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
};
const lowerLT = (a2, b2, options) => {
  if (!a2) {
    return b2;
  }
  const comp = compare$1(a2.semver, b2.semver, options);
  return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$1;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
var mimicFnExports = mimicFn$2.exports;
const mimicFn = mimicFnExports;
const calledFunctions = /* @__PURE__ */ new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$1.exports;
(function(module, exports$1) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f3) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f3) {
    if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  const util_12 = require$$1$1;
  const fs2 = require$$0;
  const path2 = require$$0$1;
  const crypto2 = crypto$1;
  const assert = require$$4;
  const events_1 = require$$5;
  const dotProp$1 = dotProp;
  const pkgUp2 = pkgUpExports;
  const envPaths2 = envPathsExports;
  const atomically = dist$1;
  const ajv_1 = ajvExports$1;
  const ajv_formats_1 = distExports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetimeExports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return /* @__PURE__ */ Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = /* @__PURE__ */ new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = {
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true,
        configFileMode: 438,
        ...partialOptions
      };
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp2.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        (0, ajv_formats_1.default)(ajv2);
        const schema = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, {
          ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
          ...options.defaults
        }, "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store);
      try {
        assert.deepEqual(fileStore, store);
      } catch (_b2) {
        this.store = store;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store } = this;
      return key in store ? store[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store } = this;
      const set = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store, key2, value2);
        } else {
          store[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set(key2, value2);
        }
      } else {
        set(key, value);
      }
      this.store = store;
    }
    /**
        Check if an item exists.
    
        @param key - The key of the item to check.
        */
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    /**
        Reset items to their default values, as defined by the `defaults` or `schema` option.
    
        @see `clear()` to reset all items.
    
        @param keys - The keys of the items to reset.
        */
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    /**
        Delete an item.
    
        @param key - The key of the item to delete.
        */
    delete(key) {
      const { store } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store, key);
      } else {
        delete store[key];
      }
      this.store = store;
    }
    /**
        Delete all items.
    
        This resets known items to their default values, if defined by the `defaults` or `schema` option.
        */
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    /**
        Watches the given `key`, calling `callback` on any changes.
    
        @param key - The key wo watch.
        @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
        @returns A function, that when called, will unsubscribe.
        */
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    /**
        Watches the whole config object, calling `callback` on any changes.
    
        @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
        @returns A function, that when called, will unsubscribe.
        */
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto2.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto2.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto2.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if ((0, util_12.isDeepStrictEqual)(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto2.randomBytes(16);
        const password = crypto2.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto2.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      if (process.env.SNAP) {
        fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
      } else {
        try {
          atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
        } catch (error2) {
          if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "EXDEV") {
            fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate, beforeEachMigration) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = { ...this.store };
      for (const version of newerVersions) {
        try {
          if (beforeEachMigration) {
            beforeEachMigration(this, {
              fromVersion: previousMigratedVersion,
              toVersion: version,
              finalVersion: versionToMigrate,
              versions: newerVersions
            });
          }
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = { ...this.store };
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store } = this;
      dotProp$1.set(store, key, value);
      this.store = store;
    }
  }
  exports$1.default = Conf2;
  module.exports = Conf2;
  module.exports.default = Conf2;
})(source, source.exports);
var sourceExports = source.exports;
const path = require$$0$1;
const { app, ipcMain, ipcRenderer, shell } = require$$1$2;
const Conf = sourceExports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = {
      name: "config",
      ...options
    };
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  async openInEditor() {
    const error2 = await shell.openPath(this.path);
    if (error2) {
      throw new Error(error2);
    }
  }
}
var electronStore = ElectronStore;
const Store = /* @__PURE__ */ getDefaultExportFromCjs(electronStore);
class MidiNote {
  constructor(_note, _velocity, _channel) {
    this._note = _note;
    this._velocity = _velocity;
    this._channel = _channel;
    if (_note < 0 || _note > 127) {
      throw new Error(`Invalid MIDI note: ${_note}. Must be between 0 and 127.`);
    }
    if (_velocity < 0 || _velocity > 127) {
      throw new Error(`Invalid velocity: ${_velocity}. Must be between 0 and 127.`);
    }
    if (_channel < 1 || _channel > 16) {
      throw new Error(`Invalid MIDI channel: ${_channel}. Must be between 1 and 16.`);
    }
  }
  static create(note, velocity, channel) {
    return new MidiNote(note, velocity, channel);
  }
  get note() {
    return this._note;
  }
  get velocity() {
    return this._velocity;
  }
  get channel() {
    return this._channel;
  }
  isNoteOn() {
    return this._velocity > 0;
  }
  isNoteOff() {
    return this._velocity === 0;
  }
  equals(other) {
    return this._note === other._note && this._velocity === other._velocity && this._channel === other._channel;
  }
  matchesNote(note, channel) {
    if (channel !== void 0 && this._channel !== channel) {
      return false;
    }
    return this._note === note;
  }
  toString() {
    const noteName = this.getNoteName();
    return `${noteName} (${this._note}) vel:${this._velocity} ch:${this._channel}`;
  }
  getNoteName() {
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(this._note / 12) - 1;
    const noteName = noteNames[this._note % 12];
    return `${noteName}${octave}`;
  }
  toJSON() {
    return {
      note: this._note,
      velocity: this._velocity,
      channel: this._channel
    };
  }
}
class MidiCC {
  constructor(_controller, _value, _channel) {
    this._controller = _controller;
    this._value = _value;
    this._channel = _channel;
    if (_controller < 0 || _controller > 127) {
      throw new Error(`Invalid MIDI CC controller: ${_controller}. Must be between 0 and 127.`);
    }
    if (_value < 0 || _value > 127) {
      throw new Error(`Invalid CC value: ${_value}. Must be between 0 and 127.`);
    }
    if (_channel < 1 || _channel > 16) {
      throw new Error(`Invalid MIDI channel: ${_channel}. Must be between 1 and 16.`);
    }
  }
  static create(controller, value, channel) {
    return new MidiCC(controller, value, channel);
  }
  get controller() {
    return this._controller;
  }
  get value() {
    return this._value;
  }
  get channel() {
    return this._channel;
  }
  /**
   * Normalize CC value to 0.0-1.0 range
   */
  get normalizedValue() {
    return this._value / 127;
  }
  equals(other) {
    return this._controller === other._controller && this._value === other._value && this._channel === other._channel;
  }
  matchesController(controller, channel) {
    if (channel !== void 0 && this._channel !== channel) {
      return false;
    }
    return this._controller === controller;
  }
  toString() {
    return `CC${this._controller}:${this._value} ch:${this._channel}`;
  }
  toJSON() {
    return {
      controller: this._controller,
      value: this._value,
      channel: this._channel
    };
  }
}
class MidiProgramChange {
  constructor(_program, _channel) {
    this._program = _program;
    this._channel = _channel;
    if (_program < 0 || _program > 127) {
      throw new Error(`Invalid MIDI program: ${_program}. Must be between 0 and 127.`);
    }
    if (_channel < 1 || _channel > 16) {
      throw new Error(`Invalid MIDI channel: ${_channel}. Must be between 1 and 16.`);
    }
  }
  static create(program, channel) {
    return new MidiProgramChange(program, channel);
  }
  get program() {
    return this._program;
  }
  get channel() {
    return this._channel;
  }
  equals(other) {
    return this._program === other._program && this._channel === other._channel;
  }
  matchesProgram(program, channel) {
    if (channel !== void 0 && this._channel !== channel) {
      return false;
    }
    return this._program === program;
  }
  toString() {
    return `PC${this._program} ch:${this._channel}`;
  }
  toJSON() {
    return {
      program: this._program,
      channel: this._channel
    };
  }
}
var MidiMessageType = /* @__PURE__ */ ((MidiMessageType2) => {
  MidiMessageType2["NOTE"] = "note";
  MidiMessageType2["CC"] = "cc";
  MidiMessageType2["PROGRAM_CHANGE"] = "program_change";
  return MidiMessageType2;
})(MidiMessageType || {});
const MidiMessage = {
  note(note, velocity, channel) {
    return {
      type: "note",
      data: MidiNote.create(note, velocity, channel)
    };
  },
  cc(controller, value, channel) {
    return {
      type: "cc",
      data: MidiCC.create(controller, value, channel)
    };
  },
  programChange(program, channel) {
    return {
      type: "program_change",
      data: MidiProgramChange.create(program, channel)
    };
  },
  toString(message) {
    switch (message.type) {
      case "note":
        return `Note: ${message.data.toString()}`;
      case "cc":
        return `CC: ${message.data.toString()}`;
      case "program_change":
        return `PC: ${message.data.toString()}`;
    }
  },
  getChannel(message) {
    return message.data.channel;
  }
};
var ParameterSubstitution = /* @__PURE__ */ ((ParameterSubstitution2) => {
  ParameterSubstitution2["NONE"] = "none";
  ParameterSubstitution2["VELOCITY"] = "velocity";
  ParameterSubstitution2["VELOCITY_NORMALIZED"] = "velocity_normalized";
  ParameterSubstitution2["TRACK_NAME"] = "track_name";
  ParameterSubstitution2["TRACK_INDEX"] = "track_index";
  return ParameterSubstitution2;
})(ParameterSubstitution || {});
class Mapping {
  constructor(_id, _name, _trigger, _command, _parameterMappings, _enabled) {
    this._id = _id;
    this._name = _name;
    this._trigger = _trigger;
    this._command = _command;
    this._parameterMappings = _parameterMappings;
    this._enabled = _enabled;
  }
  static create(id2, name, trigger, command, parameterMappings = [], enabled = true) {
    return new Mapping(id2, name, trigger, command, parameterMappings, enabled);
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get trigger() {
    return this._trigger;
  }
  get command() {
    return this._command;
  }
  get parameterMappings() {
    return this._parameterMappings;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Check if a MIDI message matches this mapping's trigger
   */
  matches(message) {
    if (!this._enabled) {
      return false;
    }
    if (message.type !== this._trigger.type) {
      return false;
    }
    if (!this._trigger.channel.matches(message.data.channel)) {
      return false;
    }
    switch (message.type) {
      case MidiMessageType.NOTE:
        if (this._trigger.type !== MidiMessageType.NOTE) return false;
        if (message.data.note !== this._trigger.note) return false;
        if (this._trigger.velocityRange) {
          const [min, max] = this._trigger.velocityRange;
          if (message.data.velocity < min || message.data.velocity > max) return false;
        }
        return true;
      case MidiMessageType.CC:
        if (this._trigger.type !== MidiMessageType.CC) return false;
        if (message.data.controller !== this._trigger.controller) return false;
        if (this._trigger.valueRange) {
          const [min, max] = this._trigger.valueRange;
          if (message.data.value < min || message.data.value > max) return false;
        }
        return true;
      case MidiMessageType.PROGRAM_CHANGE:
        if (this._trigger.type !== MidiMessageType.PROGRAM_CHANGE) return false;
        return message.data.program === this._trigger.program;
    }
  }
  /**
   * Create a new mapping with enabled/disabled state toggled
   */
  withEnabled(enabled) {
    return new Mapping(
      this._id,
      this._name,
      this._trigger,
      this._command,
      this._parameterMappings,
      enabled
    );
  }
  /**
   * Create a new mapping with updated name
   */
  withName(name) {
    return new Mapping(
      this._id,
      name,
      this._trigger,
      this._command,
      this._parameterMappings,
      this._enabled
    );
  }
  toString() {
    const triggerStr = this.triggerToString();
    return `${this._name}: ${triggerStr}  ${this._command.toString()}`;
  }
  triggerToString() {
    switch (this._trigger.type) {
      case MidiMessageType.NOTE:
        return `Note ${this._trigger.note} ${this._trigger.channel.toString()}`;
      case MidiMessageType.CC:
        return `CC ${this._trigger.controller} ${this._trigger.channel.toString()}`;
      case MidiMessageType.PROGRAM_CHANGE:
        return `PC ${this._trigger.program} ${this._trigger.channel.toString()}`;
    }
  }
  toJSON() {
    return {
      id: this._id,
      name: this._name,
      trigger: this._trigger,
      command: this._command.toJSON(),
      parameterMappings: [...this._parameterMappings],
      enabled: this._enabled
    };
  }
}
class MidiChannel {
  constructor(_value) {
    this._value = _value;
  }
  static all() {
    return new MidiChannel("all");
  }
  static channel(num) {
    if (num < 1 || num > 16) {
      throw new Error(`Invalid MIDI channel: ${num}. Must be between 1 and 16.`);
    }
    return new MidiChannel(num);
  }
  static fromValue(value) {
    if (value === "all") {
      return MidiChannel.all();
    }
    return MidiChannel.channel(value);
  }
  get value() {
    return this._value;
  }
  isAll() {
    return this._value === "all";
  }
  matches(channel) {
    return this._value === "all" || this._value === channel;
  }
  equals(other) {
    return this._value === other._value;
  }
  toString() {
    return this._value === "all" ? "All Channels" : `Channel ${this._value}`;
  }
  toJSON() {
    return this._value;
  }
}
class OscAddress {
  constructor(_path) {
    this._path = _path;
    if (!_path.startsWith("/")) {
      throw new Error(`Invalid OSC address: ${_path}. Must start with '/'.`);
    }
    if (_path.includes("//")) {
      throw new Error(`Invalid OSC address: ${_path}. Cannot contain '//'.`);
    }
    if (!/^[a-zA-Z0-9/_-]+$/.test(_path)) {
      throw new Error(
        `Invalid OSC address: ${_path}. Can only contain alphanumeric, '/', '_', and '-' characters.`
      );
    }
  }
  static create(path2) {
    return new OscAddress(path2);
  }
  get path() {
    return this._path;
  }
  equals(other) {
    return this._path === other._path;
  }
  /**
   * Check if this address matches a pattern with wildcards
   */
  matchesPattern(pattern2) {
    const regexPattern = pattern2.replace(/\*/g, "[^/]+").replace(/\?/g, ".");
    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(this._path);
  }
  /**
   * Get the category (first part) of the address
   * e.g., /live/song/get/tempo -> "song"
   */
  getCategory() {
    const parts = this._path.split("/").filter((p2) => p2.length > 0);
    return parts.length >= 2 ? parts[1] : null;
  }
  /**
   * Get the action (get/set/fire/etc) from the address
   */
  getAction() {
    const parts = this._path.split("/").filter((p2) => p2.length > 0);
    return parts.length >= 3 ? parts[2] : null;
  }
  toString() {
    return this._path;
  }
  toJSON() {
    return this._path;
  }
}
class OscCommand {
  constructor(_address, _parameters) {
    this._address = _address;
    this._parameters = _parameters;
  }
  static create(address, parameters = []) {
    const oscAddress = typeof address === "string" ? OscAddress.create(address) : address;
    return new OscCommand(oscAddress, parameters);
  }
  get address() {
    return this._address;
  }
  get parameters() {
    return this._parameters;
  }
  /**
   * Create a new command with substituted parameters
   */
  withParameters(parameters) {
    return new OscCommand(this._address, parameters);
  }
  /**
   * Create a new command with a parameter value replaced
   */
  withParameter(index, value) {
    if (index < 0 || index >= this._parameters.length) {
      throw new Error(`Parameter index ${index} out of bounds`);
    }
    const newParams = [...this._parameters];
    newParams[index] = value;
    return new OscCommand(this._address, newParams);
  }
  equals(other) {
    if (!this._address.equals(other._address)) {
      return false;
    }
    if (this._parameters.length !== other._parameters.length) {
      return false;
    }
    return this._parameters.every((param, i2) => param === other._parameters[i2]);
  }
  toString() {
    const params = this._parameters.length > 0 ? ` ${this._parameters.join(" ")}` : "";
    return `${this._address.path}${params}`;
  }
  toJSON() {
    return {
      address: this._address.path,
      parameters: [...this._parameters]
    };
  }
}
class Success {
  success = true;
  value;
  constructor(value) {
    this.value = value;
  }
  isSuccess() {
    return true;
  }
  isFailure() {
    return false;
  }
}
class Failure {
  success = false;
  error;
  constructor(error2) {
    this.error = error2;
  }
  isSuccess() {
    return false;
  }
  isFailure() {
    return true;
  }
}
const success = (value) => new Success(value);
const failure = (error2) => new Failure(error2);
var __getOwnPropDesc$g = Object.getOwnPropertyDescriptor;
var __decorateClass$g = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$g(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
let InMemoryMappingRepository = class {
  mappings = /* @__PURE__ */ new Map();
  store;
  constructor() {
    this.store = new Store({
      defaults: {
        mappings: []
      }
    });
    this.loadFromStore();
  }
  async getAll() {
    try {
      return success(Array.from(this.mappings.values()));
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to get all mappings: ${errorMessage}`));
    }
  }
  async getById(id2) {
    try {
      const mapping = this.mappings.get(id2) || null;
      return success(mapping);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to get mapping by ID: ${errorMessage}`));
    }
  }
  async save(mapping) {
    try {
      this.mappings.set(mapping.id, mapping);
      await this.persistToStore();
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to save mapping: ${errorMessage}`));
    }
  }
  async update(mapping) {
    try {
      if (!this.mappings.has(mapping.id)) {
        return failure(new Error(`Mapping with ID ${mapping.id} not found`));
      }
      this.mappings.set(mapping.id, mapping);
      await this.persistToStore();
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to update mapping: ${errorMessage}`));
    }
  }
  async delete(id2) {
    try {
      if (!this.mappings.has(id2)) {
        return failure(new Error(`Mapping with ID ${id2} not found`));
      }
      this.mappings.delete(id2);
      await this.persistToStore();
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to delete mapping: ${errorMessage}`));
    }
  }
  async clear() {
    try {
      this.mappings.clear();
      await this.persistToStore();
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to clear mappings: ${errorMessage}`));
    }
  }
  async exists(id2) {
    try {
      return success(this.mappings.has(id2));
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to check mapping existence: ${errorMessage}`));
    }
  }
  loadFromStore() {
    try {
      const serializedMappings = this.store.get("mappings", []);
      for (const serialized of serializedMappings) {
        try {
          const mapping = this.deserializeMapping(serialized);
          this.mappings.set(mapping.id, mapping);
        } catch (error2) {
          console.error(`Failed to load mapping ${serialized.id}:`, error2);
        }
      }
      console.log(`Loaded ${this.mappings.size} mappings from store`);
    } catch (error2) {
      console.error("Failed to load mappings from store:", error2);
    }
  }
  async persistToStore() {
    try {
      const serializedMappings = Array.from(this.mappings.values()).map(
        (mapping) => this.serializeMapping(mapping)
      );
      this.store.set("mappings", serializedMappings);
    } catch (error2) {
      console.error("Failed to persist mappings to store:", error2);
      throw error2;
    }
  }
  serializeMapping(mapping) {
    return {
      id: mapping.id,
      name: mapping.name,
      trigger: {
        ...mapping.trigger,
        channel: mapping.trigger.channel.toJSON()
      },
      command: mapping.command.toJSON(),
      parameterMappings: [...mapping.parameterMappings],
      enabled: mapping.enabled
    };
  }
  deserializeMapping(serialized) {
    const channel = MidiChannel.fromValue(serialized.trigger.channel);
    const trigger = { ...serialized.trigger, channel };
    const command = OscCommand.create(serialized.command.address, serialized.command.parameters);
    return Mapping.create(
      serialized.id,
      serialized.name,
      trigger,
      command,
      serialized.parameterMappings,
      serialized.enabled
    );
  }
};
InMemoryMappingRepository = __decorateClass$g([
  Kt()
], InMemoryMappingRepository);
var util;
(function(util2) {
  util2.assertEqual = (_2) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items2) => {
    const obj = {};
    for (const item of items2) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x3) => x3.status === "aborted";
const isDirty = (x3) => x3.status === "dirty";
const isValid = (x3) => x3.status === "valid";
const isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation2, message) {
    return this.refinement((data) => regex.test(data), {
      validation: validation2,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items2 = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items2).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items2);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const booleanType = ZodBoolean.create;
ZodNever.create;
ZodArray.create;
const objectType = ZodObject.create;
const unionType = ZodUnion.create;
ZodIntersection.create;
ZodTuple.create;
const literalType = ZodLiteral.create;
ZodEnum.create;
ZodPromise.create;
ZodOptional.create;
ZodNullable.create;
var __getOwnPropDesc$f = Object.getOwnPropertyDescriptor;
var __decorateClass$f = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$f(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
const AppConfigSchema = objectType({
  selectedMidiDevice: stringType().nullable(),
  selectedMidiChannel: unionType([numberType().min(1).max(16), literalType("all")]),
  oscHost: stringType(),
  oscPort: numberType().min(1).max(65535),
  autoReconnect: booleanType(),
  lastOpened: stringType()
});
const DEFAULT_CONFIG = {
  selectedMidiDevice: null,
  selectedMidiChannel: "all",
  oscHost: "127.0.0.1",
  oscPort: 11e3,
  autoReconnect: true,
  lastOpened: (/* @__PURE__ */ new Date()).toISOString()
};
let ElectronStoreConfigRepository = class {
  store;
  constructor() {
    this.store = new Store({
      defaults: DEFAULT_CONFIG,
      schema: AppConfigSchema
    });
  }
  async get() {
    try {
      const config = this.store.store;
      const parseResult = AppConfigSchema.safeParse(config);
      if (!parseResult.success) {
        await this.reset();
        return success(DEFAULT_CONFIG);
      }
      return success(config);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to get config: ${errorMessage}`));
    }
  }
  async update(config) {
    try {
      const currentResult = await this.get();
      if (currentResult.isFailure()) {
        return failure(currentResult.error);
      }
      const updatedConfig = { ...currentResult.value, ...config };
      const parseResult = AppConfigSchema.safeParse(updatedConfig);
      if (!parseResult.success) {
        return failure(new Error(`Invalid config: ${parseResult.error.message}`));
      }
      this.store.store = updatedConfig;
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to update config: ${errorMessage}`));
    }
  }
  async reset() {
    try {
      this.store.clear();
      this.store.store = DEFAULT_CONFIG;
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to reset config: ${errorMessage}`));
    }
  }
  async getValue(key) {
    try {
      const value = this.store.get(key);
      return success(value);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to get config value: ${errorMessage}`));
    }
  }
  async setValue(key, value) {
    try {
      this.store.set(key, value);
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to set config value: ${errorMessage}`));
    }
  }
};
ElectronStoreConfigRepository = __decorateClass$f([
  Kt()
], ElectronStoreConfigRepository);
var JZZ$1 = { exports: {} };
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jazzMidi = { exports: {} };
var hasRequiredJazzMidi;
function requireJazzMidi() {
  if (hasRequiredJazzMidi) return jazzMidi.exports;
  hasRequiredJazzMidi = 1;
  var path2 = "./bin/";
  var v2 = process.versions.node.split(".");
  if (v2[0] <= 10) path2 += "10_15/";
  else if (v2[0] <= 11) path2 += "11_15/";
  if (process.platform == "win32" && process.arch == "ia32") path2 += "win32/jazz";
  else if (process.platform == "win32" && process.arch == "x64") path2 += "win64/jazz";
  else if (process.platform == "darwin" && process.arch == "x64") path2 += "macos64/jazz";
  else if (process.platform == "darwin" && process.arch == "arm64") path2 += "macosa64/jazz";
  else if (process.platform == "linux" && process.arch == "x64") path2 += "linux64/jazz";
  else if (process.platform == "linux" && process.arch == "arm") path2 += "linuxa7/jazz";
  else throw process.arch + " on " + process.platform + " is not yet supported";
  jazzMidi.exports = commonjsRequire(path2);
  jazzMidi.exports.package = commonjsRequire(__dirname + "/package.json");
  return jazzMidi.exports;
}
(function(module, exports$1) {
  (function(global2, factory) {
    {
      module.exports = factory();
    }
  })(commonjsGlobal, function() {
    var _scope = typeof window === "undefined" ? commonjsGlobal : window;
    var _version = "1.9.6";
    var i2, j2, k2, m2, n;
    var _time = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    var _startTime = _time();
    var _now = typeof performance != "undefined" && performance.now ? function() {
      return performance.now();
    } : function() {
      return _time() - _startTime;
    };
    var _schedule = function(f3) {
      setTimeout(f3, 0);
    };
    function _nop() {
    }
    function _func(f3) {
      return typeof f3 == "function";
    }
    function _R() {
      this._orig = this;
      this._ready = false;
      this._queue = [];
      this._log = [];
    }
    _R.prototype._exec = function() {
      while (this._ready && this._queue.length) {
        var x3 = this._queue.shift();
        x3[0].apply(this, x3[1]);
      }
    };
    _R.prototype._push = function(func, arg) {
      this._queue.push([func, arg]);
      _R.prototype._exec.apply(this);
    };
    _R.prototype._slip = function(func, arg) {
      this._queue.unshift([func, arg]);
    };
    _R.prototype._pause = function() {
      this._ready = false;
    };
    _R.prototype._resume = function() {
      this._ready = true;
      _R.prototype._exec.apply(this);
    };
    _R.prototype._break = function(err) {
      this._orig._bad = true;
      this._orig._log.push(err || "Unknown JZZ error");
    };
    _R.prototype._repair = function() {
      this._orig._bad = false;
    };
    _R.prototype._crash = function(err) {
      this._break(err);
      this._resume();
    };
    _R.prototype._err = function() {
      return this._log[this._log.length - 1];
    };
    _R.prototype.log = function() {
      return _clone(this._log);
    };
    _R.prototype._dup = function() {
      var F2 = function() {
      };
      F2.prototype = this._orig;
      var ret = new F2();
      ret._ready = false;
      ret._queue = [];
      return ret;
    };
    _R.prototype._image = function() {
      return this._dup();
    };
    _R.prototype._thenable = function() {
      if (this.then) return this;
      var self2 = this;
      var F2 = function() {
      };
      F2.prototype = self2;
      var ret = new F2();
      ret.then = function(good, bad) {
        self2._push(_then, [good, bad]);
        return this;
      };
      return ret;
    };
    function _then(good, bad) {
      if (this._bad) {
        if (_func(bad)) bad.apply(this, [new Error(this._err())]);
      } else {
        if (_func(good)) good.apply(this, [this]);
      }
    }
    function _wait(obj, delay) {
      if (this._bad) obj._crash(this._err());
      else setTimeout(function() {
        obj._resume();
      }, delay);
    }
    _R.prototype.wait = function(delay) {
      if (!delay) return this;
      var ret = this._image();
      this._push(_wait, [ret, delay]);
      return ret._thenable();
    };
    function _kick(obj) {
      if (this._bad) obj._break(this._err());
      obj._resume();
    }
    function _rechain(self2, obj, name) {
      self2[name] = function() {
        var arg = arguments;
        var ret = obj._image();
        this._push(_kick, [ret]);
        return ret[name].apply(ret, arg);
      };
    }
    function _and(q2) {
      if (!this._bad) {
        if (_func(q2)) q2.apply(this);
        else console.log(q2);
      }
    }
    _R.prototype.and = function(func) {
      this._push(_and, [func]);
      return this._thenable();
    };
    function _or(q2) {
      if (this._bad) {
        if (_func(q2)) q2.apply(this);
        else console.log(q2);
      }
    }
    _R.prototype.or = function(func) {
      this._push(_or, [func]);
      return this._thenable();
    };
    _R.prototype._info = {};
    _R.prototype.info = function() {
      var info = _clone(this._orig._info);
      if (typeof info.engine == "undefined") info.engine = "none";
      if (typeof info.sysex == "undefined") info.sysex = true;
      return info;
    };
    _R.prototype.name = function() {
      return this.info().name;
    };
    function _close(obj) {
      if (this._bad) obj._crash(this._err());
      else {
        this._break("Closed");
        obj._resume();
      }
    }
    _R.prototype.close = function() {
      var ret = new _R();
      if (this._close) this._push(this._close, []);
      this._push(_close, [ret]);
      return ret._thenable();
    };
    function _tryAny(arr) {
      if (!arr.length) {
        this._break();
        return;
      }
      var func = arr.shift();
      if (arr.length) {
        var self2 = this;
        this._slip(_or, [function() {
          _tryAny.apply(self2, [arr]);
        }]);
      }
      try {
        this._repair();
        func.apply(this);
      } catch (err) {
        this._break(err.toString());
      }
    }
    function _push(arr, obj) {
      for (var i3 = 0; i3 < arr.length; i3++) if (arr[i3] === obj) return;
      arr.push(obj);
    }
    function _pop(arr, obj) {
      for (var i3 = 0; i3 < arr.length; i3++) if (arr[i3] === obj) {
        arr.splice(i3, 1);
        return;
      }
    }
    function _J() {
      _R.apply(this);
    }
    _J.prototype = new _R();
    function _for(x3, f3) {
      for (var k3 in x3) if (x3.hasOwnProperty(k3)) f3.call(this, k3);
    }
    function _clone(obj, key, val) {
      if (typeof key == "undefined") return _clone(obj, [], []);
      if (obj instanceof Object) {
        for (var i3 = 0; i3 < key.length; i3++) if (key[i3] === obj) return val[i3];
        var ret;
        if (obj instanceof Array) ret = [];
        else ret = {};
        key.push(obj);
        val.push(ret);
        _for(obj, function(k3) {
          ret[k3] = _clone(obj[k3], key, val);
        });
        return ret;
      }
      return obj;
    }
    _J.prototype._info = { name: "JZZ.js", ver: _version, version: _version, inputs: [], outputs: [] };
    var _outs = [];
    var _ins = [];
    var _outsW = [];
    var _insW = [];
    var _outsM = {};
    var _insM = {};
    function _postRefresh() {
      _jzz._info.engine = _engine._type;
      _jzz._info.version = _engine._version;
      _jzz._info.sysex = _engine._sysex;
      _jzz._info.inputs = [];
      _jzz._info.outputs = [];
      _outs = [];
      _ins = [];
      _engine._allOuts = {};
      _engine._allIns = {};
      var i3, x3;
      for (i3 = 0; i3 < _engine._outs.length; i3++) {
        x3 = _engine._outs[i3];
        if (_outsM[x3.name]) continue;
        x3.engine = _engine;
        _engine._allOuts[x3.name] = x3;
        _jzz._info.outputs.push({
          id: x3.name,
          name: x3.name,
          manufacturer: x3.manufacturer,
          version: x3.version,
          engine: _engine._type
        });
        _outs.push(x3);
      }
      for (i3 = 0; i3 < _virtual._outs.length; i3++) {
        x3 = _virtual._outs[i3];
        if (_outsM[x3.name]) continue;
        _jzz._info.outputs.push({
          id: x3.name,
          name: x3.name,
          manufacturer: x3.manufacturer,
          version: x3.version,
          engine: x3.type
        });
        _outs.push(x3);
      }
      for (i3 = 0; i3 < _engine._ins.length; i3++) {
        x3 = _engine._ins[i3];
        if (_insM[x3.name]) continue;
        x3.engine = _engine;
        _engine._allIns[x3.name] = x3;
        _jzz._info.inputs.push({
          id: x3.name,
          name: x3.name,
          manufacturer: x3.manufacturer,
          version: x3.version,
          engine: _engine._type
        });
        _ins.push(x3);
      }
      for (i3 = 0; i3 < _virtual._ins.length; i3++) {
        x3 = _virtual._ins[i3];
        if (_insM[x3.name]) continue;
        _jzz._info.inputs.push({
          id: x3.name,
          name: x3.name,
          manufacturer: x3.manufacturer,
          version: x3.version,
          engine: x3.type
        });
        _ins.push(x3);
      }
      if (_jzz._watcher && _jzz._watcher._handles.length) {
        var diff2 = _diff(_insW, _outsW, _jzz._info.inputs, _jzz._info.outputs);
        if (diff2) {
          for (j2 = 0; j2 < diff2.inputs.removed.length; j2++) {
            x3 = _engine._inMap[diff2.inputs.removed[j2].name];
            if (x3) x3._closeAll();
          }
          for (j2 = 0; j2 < diff2.outputs.removed.length; j2++) {
            x3 = _engine._outMap[diff2.outputs.removed[j2].name];
            if (x3) x3._closeAll();
          }
          _schedule(function() {
            _fireW(diff2);
          });
        }
      }
      _insW = _jzz._info.inputs;
      _outsW = _jzz._info.outputs;
    }
    function _refresh() {
      if (!this._bad) _engine._refresh(this);
    }
    _J.prototype.refresh = function() {
      this._push(_refresh, []);
      return this._thenable();
    };
    function _filterList(q2, arr) {
      var i3, n2;
      if (_func(q2)) q2 = q2(arr);
      if (!(q2 instanceof Array)) q2 = [q2];
      var before = [];
      var after = [];
      var etc = arr.slice();
      var a2 = before;
      for (i3 = 0; i3 < q2.length; i3++) {
        if (typeof q2[i3] == "undefined") a2 = after;
        else if (q2[i3] instanceof RegExp) for (n2 = 0; n2 < etc.length; n2++) {
          if (q2[i3].test(etc[n2].name)) {
            a2.push(etc[n2]);
            etc.splice(n2, 1);
            n2--;
          }
        }
        else {
          for (n2 = 0; n2 < etc.length; n2++) if (q2[i3] + "" === n2 + "" || q2[i3] === etc[n2].name || q2[i3] instanceof Object && q2[i3].name === etc[n2].name) {
            a2.push(etc[n2]);
            etc.splice(n2, 1);
            n2--;
          }
        }
      }
      return a2 == before ? before : before.concat(etc).concat(after);
    }
    function _notFound(port, q2) {
      var msg;
      if (q2 instanceof RegExp) msg = "Port matching " + q2 + " not found";
      else if (q2 instanceof Object || typeof q2 == "undefined") msg = "Port not found";
      else msg = 'Port "' + q2 + '" not found';
      port._crash(msg);
    }
    function _openMidiOut(port, arg) {
      if (this._bad) port._crash(this._err());
      else {
        var arr = _filterList(arg, _outs);
        if (!arr.length) {
          _notFound(port, arg);
          return;
        }
        var pack = function(x3) {
          return function() {
            x3.engine._openOut(this, x3.name);
          };
        };
        for (var i3 = 0; i3 < arr.length; i3++) arr[i3] = pack(arr[i3]);
        port._slip(_tryAny, [arr]);
        port._resume();
      }
    }
    _J.prototype.openMidiOut = function(arg) {
      var port = new _M();
      this._push(_refresh, []);
      this._push(_openMidiOut, [port, arg]);
      return port._thenable();
    };
    _J.prototype._openMidiOutNR = function(arg) {
      var port = new _M();
      this._push(_openMidiOut, [port, arg]);
      return port._thenable();
    };
    function _openMidiIn(port, arg) {
      if (this._bad) port._crash(this._err());
      else {
        var arr = _filterList(arg, _ins);
        if (!arr.length) {
          _notFound(port, arg);
          return;
        }
        var pack = function(x3) {
          return function() {
            x3.engine._openIn(this, x3.name);
          };
        };
        for (var i3 = 0; i3 < arr.length; i3++) arr[i3] = pack(arr[i3]);
        port._slip(_tryAny, [arr]);
        port._resume();
      }
    }
    _J.prototype.openMidiIn = function(arg) {
      var port = new _M();
      this._push(_refresh, []);
      this._push(_openMidiIn, [port, arg]);
      return port._thenable();
    };
    _J.prototype._openMidiInNR = function(arg) {
      var port = new _M();
      this._push(_openMidiIn, [port, arg]);
      return port._thenable();
    };
    function _onChange(watcher, arg) {
      if (this._bad) watcher._crash();
      else {
        watcher._slip(_connectW, [arg]);
        watcher._resume();
      }
    }
    _J.prototype.onChange = function(arg) {
      if (!this._orig._watcher) this._orig._watcher = new _W();
      var watcher = this._orig._watcher._image();
      this._push(_onChange, [watcher, arg]);
      return watcher._thenable();
    };
    _J.prototype._close = function() {
      _engine._close();
      var a2 = _plugged.slice();
      for (var i3 = 0; i3 < a2.length; i3++) if (a2[i3]) {
        if (a2[i3]._close) a2[i3]._close();
        else if (a2[i3].close) a2[i3].close();
      }
    };
    function _M() {
      _R.apply(this);
      this._handles = [];
      this._outs = [];
    }
    _M.prototype = new _R();
    _M.prototype._filter = function(msg) {
      if (this._orig._mpe) {
        var out;
        var outs = 0;
        if (this._handles && this._handles.length) {
          outs = this._handles.length;
          out = this._handles[0];
        }
        if (this._outs && this._outs.length) {
          outs = this._outs.length;
          out = this._outs[0];
        }
        if (outs == 1 && !out._mpe) {
          msg = this._orig._mpe.filter(msg);
        }
      }
      return msg;
    };
    _M.prototype._receive = function(msg) {
      this._emit(this._filter(msg));
    };
    function _receive(msg) {
      if (!this._bad) this._receive(msg);
    }
    _M.prototype.send = function() {
      this._push(_receive, [_midi.apply(null, arguments)]);
      return this._thenable();
    };
    _M.prototype.note = function(c2, n2, v2, t2) {
      this.noteOn(c2, n2, v2);
      if (typeof this._ch == "undefined" && typeof this._master == "undefined") {
        if (t2 > 0) this.wait(t2).noteOff(c2, n2);
      } else {
        if (v2 > 0) this.wait(v2).noteOff(c2);
      }
      return this._thenable();
    };
    function _midi(msg) {
      return msg.isMidi2 ? new UMP(msg) : MIDI.apply(null, arguments);
    }
    _M.prototype._emit = function(msg) {
      var i3, m3;
      for (i3 = 0; i3 < this._handles.length; i3++) {
        m3 = _midi(msg);
        this._handles[i3].apply(this, [m3._stamp(this)]);
      }
      for (i3 = 0; i3 < this._outs.length; i3++) {
        m3 = _midi(msg);
        if (!m3._stamped(this._outs[i3])) this._outs[i3].send(m3._stamp(this));
      }
    };
    function _emit(msg) {
      this._emit(msg);
    }
    _M.prototype.emit = function(msg) {
      this._push(_emit, [msg]);
      return this._thenable();
    };
    function _connect(arg) {
      if (_func(arg)) _push(this._orig._handles, arg);
      else _push(this._orig._outs, arg);
    }
    function _disconnect(arg) {
      if (typeof arg == "undefined") {
        this._orig._handles = [];
        this._orig._outs = [];
      } else if (_func(arg)) _pop(this._orig._handles, arg);
      else _pop(this._orig._outs, arg);
    }
    _M.prototype.connect = function(arg) {
      this._push(_connect, [arg]);
      return this._thenable();
    };
    _M.prototype.disconnect = function(arg) {
      this._push(_disconnect, [arg]);
      return this._thenable();
    };
    _M.prototype.connected = function() {
      return this._orig._handles.length + this._orig._outs.length;
    };
    _M.prototype._image = function() {
      var dup = this._dup();
      dup._gr = this._gr;
      dup._ch = this._ch;
      dup._sxid = this._sxid;
      dup._master = this._master;
      dup._band = this._band;
      return dup;
    };
    _M.prototype._sxid = 127;
    _M.prototype.sxId = function(id2) {
      if (typeof id2 == "undefined") id2 = _M.prototype._sxid;
      if (id2 == this._sxid) return this._thenable();
      id2 = _7b(id2);
      var img = this._image();
      img._sxid = id2;
      this._push(_kick, [img]);
      return img._thenable();
    };
    _M.prototype.ch = function(c2) {
      if (c2 == this._ch || typeof c2 == "undefined" && typeof this._ch == "undefined") return this._thenable();
      var img = this._image();
      if (typeof c2 != "undefined") c2 = _ch(c2);
      img._ch = c2;
      img._master = void 0;
      img._band = void 0;
      this._push(_kick, [img]);
      return img._thenable();
    };
    _M.prototype.MIDI1 = function() {
      var img = this._image();
      img._ch = void 0;
      img._sxid = _M.prototype._sxid;
      img._master = void 0;
      img._band = void 0;
      this._push(_kick, [img]);
      return img._thenable();
    };
    _M.prototype.MIDI2 = function() {
      var img = this._image();
      img._ch = void 0;
      img._sxid = _M.prototype._sxid;
      img._master = void 0;
      img._band = void 0;
      var m22 = new _M2(img);
      this._push(_kick, [m22]);
      return m22._thenable();
    };
    function _mpe(m3, n2) {
      if (!this._orig._mpe) this._orig._mpe = new MPE();
      this._orig._mpe.setup(m3, n2);
    }
    _M.prototype.mpe = function(m3, n2) {
      if (m3 == this._master && n2 == this._band || typeof m3 == "undefined" && typeof this._master == "undefined") return this._thenable();
      if (typeof m3 != "undefined") MPE.validate(m3, n2);
      if (!n2) return this.ch(m3);
      var img = this._image();
      img._ch = void 0;
      img._master = m3;
      img._band = n2;
      this._push(_mpe, [m3, n2]);
      this._push(_kick, [img]);
      return img._thenable();
    };
    function _validateChannel(c2) {
      if (c2 != parseInt(c2) || c2 < 0 || c2 > 15)
        throw RangeError("Bad channel value (must not be less than 0 or more than 15): " + c2);
    }
    function _M2(sink) {
      _R.apply(this);
      this._sink = sink;
    }
    _M2.prototype = new _R();
    _M2.prototype._sxid = _M.prototype._sxid;
    _M2.prototype._receive = function(msg) {
      this._sink._receive(msg);
    };
    function _midi2(msg) {
      return msg.isMidi && !msg.isMidi2 ? new MIDI(msg) : UMP.apply(null, arguments);
    }
    _M2.prototype.send = function() {
      this._push(_receive, [_midi2.apply(null, arguments)]);
      return this._thenable();
    };
    _M2.prototype._image = _M.prototype._image;
    _M2.prototype.connect = function(arg) {
      this._sink.connect(arg);
      this._push(_kick, [this._sink]);
      return this._thenable();
    };
    _M2.prototype.disconnect = function(arg) {
      this._sink.disconnect(arg);
      this._push(_kick, [this._sink]);
      return this._thenable();
    };
    _M2.prototype.connected = function() {
      return this._sink.connected();
    };
    _M2.prototype.sxId = _M.prototype.sxId;
    _M2.prototype.ch = _M.prototype.ch;
    _M2.prototype.gr = function(g2) {
      if (g2 == this._gr || typeof g2 == "undefined" && typeof this._gr == "undefined") return this._thenable();
      var img = this._image();
      if (typeof g2 != "undefined") g2 = _7b(g2);
      img._gr = g2;
      this._push(_kick, [img]);
      return img._thenable();
    };
    _M2.prototype.MIDI1 = function() {
      var img = this._sink._image();
      this._push(_kick, [img]);
      return img._thenable();
    };
    _M2.prototype.MIDI2 = function() {
      var img = this._image();
      img._gr = void 0;
      img._ch = void 0;
      img._sxid = _M.prototype._sxid;
      this._push(_kick, [img]);
      return img._thenable();
    };
    function _W() {
      _R.apply(this);
      this._handles = [];
      _rechain(this, _jzz, "refresh");
      _rechain(this, _jzz, "openMidiOut");
      _rechain(this, _jzz, "openMidiIn");
      _rechain(this, _jzz, "onChange");
      _rechain(this, _jzz, "close");
    }
    _W.prototype = new _R();
    function _connectW(arg) {
      if (_func(arg)) {
        if (!this._orig._handles.length) _engine._watch();
        _push(this._orig._handles, arg);
      }
    }
    function _disconnectW(arg) {
      if (typeof arg == "undefined") this._orig._handles = [];
      else _pop(this._orig._handles, arg);
      if (!this._orig._handles.length) _engine._unwatch();
    }
    _W.prototype.connect = function(arg) {
      this._push(_connectW, [arg]);
      return this._thenable();
    };
    _W.prototype.disconnect = function(arg) {
      this._push(_disconnectW, [arg]);
      return this._thenable();
    };
    function _changed(x0, y0, x1, y1) {
      var i3;
      if (x0.length != x1.length || y0.length != y1.length) return true;
      for (i3 = 0; i3 < x0.length; i3++) if (x0[i3].name != x1[i3].name) return true;
      for (i3 = 0; i3 < y0.length; i3++) if (y0[i3].name != y1[i3].name) return true;
      return false;
    }
    function _diff(x0, y0, x1, y1) {
      if (!_changed(x0, y0, x1, y1)) return;
      var ax = [];
      var ay = [];
      var rx = [];
      var ry = [];
      var i3;
      var h2 = {};
      for (i3 = 0; i3 < x0.length; i3++) h2[x0[i3].name] = true;
      for (i3 = 0; i3 < x1.length; i3++) if (!h2[x1[i3].name]) ax.push(x1[i3]);
      h2 = {};
      for (i3 = 0; i3 < x1.length; i3++) h2[x1[i3].name] = true;
      for (i3 = 0; i3 < x0.length; i3++) if (!h2[x0[i3].name]) rx.push(x0[i3]);
      h2 = {};
      for (i3 = 0; i3 < y0.length; i3++) h2[y0[i3].name] = true;
      for (i3 = 0; i3 < y1.length; i3++) if (!h2[y1[i3].name]) ay.push(y1[i3]);
      h2 = {};
      for (i3 = 0; i3 < y1.length; i3++) h2[y1[i3].name] = true;
      for (i3 = 0; i3 < y0.length; i3++) if (!h2[y0[i3].name]) ry.push(y0[i3]);
      return { inputs: { added: ax, removed: rx }, outputs: { added: ay, removed: ry } };
    }
    function _fireW(arg) {
      for (i2 = 0; i2 < _jzz._watcher._handles.length; i2++) _jzz._watcher._handles[i2].apply(_jzz, [arg]);
    }
    var _jzz;
    var _engine = { _outs: [], _ins: [], _close: _nop };
    var _virtual = { _outs: [], _ins: [] };
    var _plugged = [];
    function _tryNODE() {
      if (module.exports) {
        var jazzmidi = requireJazzMidi();
        if (jazzmidi) {
          _initNode(jazzmidi);
          return;
        }
      }
      this._break();
    }
    function _tryJazzPlugin() {
      var div = document.createElement("div");
      div.style.visibility = "hidden";
      document.body.appendChild(div);
      var obj = document.createElement("object");
      obj.style.visibility = "hidden";
      obj.style.width = "0px";
      obj.style.height = "0px";
      obj.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90";
      obj.type = "audio/x-jazz";
      document.body.appendChild(obj);
      if (obj.isJazz) {
        _initJazzPlugin(obj);
        return;
      }
      this._break();
    }
    var _navigator;
    var _requestMIDIAccess;
    function _findMidiAccess() {
      if (typeof navigator !== "undefined" && navigator.requestMIDIAccess) {
        _navigator = navigator;
        _requestMIDIAccess = navigator.requestMIDIAccess;
        try {
          if (_requestMIDIAccess.toString().indexOf("JZZ(") != -1) _requestMIDIAccess = void 0;
        } catch (err) {
        }
      }
    }
    function _tryWebMIDI() {
      _findMidiAccess();
      if (_requestMIDIAccess) {
        var self2 = this;
        var onGood = function(midi) {
          _initWebMIDI(midi);
          self2._resume();
        };
        var onBad = function(msg) {
          self2._crash(msg);
        };
        var opt = {};
        _requestMIDIAccess.call(_navigator, opt).then(onGood, onBad);
        this._pause();
        return;
      }
      this._break();
    }
    function _tryWebMIDIsysex() {
      _findMidiAccess();
      if (_requestMIDIAccess) {
        var self2 = this;
        var onGood = function(midi) {
          _initWebMIDI(midi, true);
          self2._resume();
        };
        var onBad = function(msg) {
          self2._crash(msg);
        };
        var opt = { sysex: true };
        _requestMIDIAccess.call(_navigator, opt).then(onGood, onBad);
        this._pause();
        return;
      }
      this._break();
    }
    function _tryCRX() {
      var self2 = this;
      var inst;
      var msg;
      function eventHandle(evt) {
        inst = true;
        var a2 = evt.detail;
        if (!a2) {
          if (!msg) msg = document.getElementById("jazz-midi-msg");
          if (!msg) return;
          try {
            a2 = JSON.parse(msg.innerText);
          } catch (err) {
          }
          msg.innerText = "";
        }
        document.removeEventListener("jazz-midi-msg", eventHandle);
        if (a2 && a2[0] === "version") {
          _initCRX(msg, a2[2]);
          self2._resume();
        } else {
          self2._crash();
        }
      }
      this._pause();
      try {
        document.addEventListener("jazz-midi-msg", eventHandle);
        document.dispatchEvent(new Event("jazz-midi"));
      } catch (err) {
      }
      setTimeout(function() {
        if (!inst) self2._crash();
      }, 50);
    }
    function _zeroBreak() {
      this._pause();
      var self2 = this;
      _schedule(function() {
        self2._crash();
      });
    }
    function _filterEngines(opt) {
      var ret = [];
      var arr = _filterEngineNames(opt);
      for (var i3 = 0; i3 < arr.length; i3++) {
        if (arr[i3] == "webmidi") {
          if (opt && opt.sysex === true) ret.push(_tryWebMIDIsysex);
          if (!opt || opt.sysex !== true || opt.degrade === true) ret.push(_tryWebMIDI);
        } else if (arr[i3] == "node") {
          ret.push(_tryNODE);
          ret.push(_zeroBreak);
        } else if (arr[i3] == "extension") ret.push(_tryCRX);
        else if (arr[i3] == "plugin") ret.push(_tryJazzPlugin);
      }
      ret.push(_initNONE);
      return ret;
    }
    function _filterEngineNames(opt) {
      var web = ["node", "extension", "plugin", "webmidi"];
      if (!opt || !opt.engine) return web;
      var arr = opt.engine instanceof Array ? opt.engine : [opt.engine];
      var dup = {};
      var none;
      var etc;
      var head = [];
      var tail = [];
      var i3;
      for (i3 = 0; i3 < arr.length; i3++) {
        var name = arr[i3].toString().toLowerCase();
        if (dup[name]) continue;
        dup[name] = true;
        if (name === "none") none = true;
        if (name === "etc" || typeof name == "undefined") etc = true;
        if (etc) tail.push(name);
        else head.push(name);
        _pop(web, name);
      }
      if (etc || head.length || tail.length) none = false;
      return none ? [] : head.concat(etc ? web : tail);
    }
    function _initJZZ(opt) {
      _jzz = new _J();
      _jzz._options = opt;
      _jzz._push(_tryAny, [_filterEngines(opt)]);
      _jzz.refresh();
      _jzz._resume();
    }
    function _initNONE() {
      _engine._type = "none";
      _engine._version = _version;
      _engine._sysex = true;
      _engine._outs = [];
      _engine._ins = [];
      _engine._outMap = {};
      _engine._inMap = {};
      _engine._refresh = function() {
        _postRefresh();
      };
      _engine._watch = _nop;
      _engine._unwatch = _nop;
      _engine._close = _nop;
    }
    function _initEngineJP() {
      _engine._inArr = [];
      _engine._outArr = [];
      _engine._inMap = {};
      _engine._outMap = {};
      _engine._outsW = [];
      _engine._insW = [];
      _engine._version = _engine._main.version;
      _engine._sysex = true;
      var watcher;
      function _closeAll() {
        for (var i3 = 0; i3 < this.clients.length; i3++) this._close(this.clients[i3]);
      }
      _engine._refresh = function() {
        _engine._outs = [];
        _engine._ins = [];
        var i3, x3;
        for (i3 = 0; (x3 = _engine._main.MidiOutInfo(i3)).length; i3++) {
          _engine._outs.push({ type: _engine._type, name: x3[0], manufacturer: x3[1], version: x3[2] });
        }
        for (i3 = 0; (x3 = _engine._main.MidiInInfo(i3)).length; i3++) {
          _engine._ins.push({ type: _engine._type, name: x3[0], manufacturer: x3[1], version: x3[2] });
        }
        _postRefresh();
      };
      _engine._openOut = function(port, name) {
        var impl = _engine._outMap[name];
        if (!impl) {
          if (_engine._pool.length <= _engine._outArr.length) _engine._pool.push(_engine._newPlugin());
          impl = {
            name,
            clients: [],
            info: {
              name,
              manufacturer: _engine._allOuts[name].manufacturer,
              version: _engine._allOuts[name].version,
              type: "MIDI-out",
              sysex: _engine._sysex,
              engine: _engine._type
            },
            _close: function(port2) {
              _engine._closeOut(port2);
            },
            _closeAll,
            _receive: function(a2) {
              if (a2.length) this.plugin.MidiOutRaw(a2.slice());
            }
          };
          var plugin = _engine._pool[_engine._outArr.length];
          impl.plugin = plugin;
          _engine._outArr.push(impl);
          _engine._outMap[name] = impl;
        }
        if (!impl.open) {
          var s2 = impl.plugin.MidiOutOpen(name);
          if (s2 !== name) {
            if (s2) impl.plugin.MidiOutClose();
            port._break();
            return;
          }
          impl.open = true;
        }
        port._orig._impl = impl;
        _push(impl.clients, port._orig);
        port._info = impl.info;
        port._receive = function(arg) {
          impl._receive(arg);
        };
        port._close = function() {
          impl._close(this);
        };
      };
      _engine._openIn = function(port, name) {
        var impl = _engine._inMap[name];
        if (!impl) {
          if (_engine._pool.length <= _engine._inArr.length) _engine._pool.push(_engine._newPlugin());
          impl = {
            name,
            clients: [],
            info: {
              name,
              manufacturer: _engine._allIns[name].manufacturer,
              version: _engine._allIns[name].version,
              type: "MIDI-in",
              sysex: _engine._sysex,
              engine: _engine._type
            },
            _close: function(port2) {
              _engine._closeIn(port2);
            },
            _closeAll,
            handle: function(t2, a2) {
              for (var i3 = 0; i3 < this.clients.length; i3++) {
                var msg = MIDI(a2);
                this.clients[i3]._emit(msg);
              }
            }
          };
          var makeHandle = function(x3) {
            return function(t2, a2) {
              x3.handle(t2, a2);
            };
          };
          impl.onmidi = makeHandle(impl);
          var plugin = _engine._pool[_engine._inArr.length];
          impl.plugin = plugin;
          _engine._inArr.push(impl);
          _engine._inMap[name] = impl;
        }
        if (!impl.open) {
          var s2 = impl.plugin.MidiInOpen(name, impl.onmidi);
          if (s2 !== name) {
            if (s2) impl.plugin.MidiInClose();
            port._break();
            return;
          }
          impl.open = true;
        }
        port._orig._impl = impl;
        _push(impl.clients, port._orig);
        port._info = impl.info;
        port._close = function() {
          impl._close(this);
        };
      };
      _engine._closeOut = function(port) {
        var impl = port._impl;
        _pop(impl.clients, port._orig);
        if (!impl.clients.length && impl.open) {
          impl.open = false;
          impl.plugin.MidiOutClose();
        }
      };
      _engine._closeIn = function(port) {
        var impl = port._impl;
        _pop(impl.clients, port._orig);
        if (!impl.clients.length && impl.open) {
          impl.open = false;
          impl.plugin.MidiInClose();
        }
      };
      _engine._close = function() {
        for (var i3 = 0; i3 < _engine._inArr.length; i3++) if (_engine._inArr[i3].open) _engine._inArr[i3].plugin.MidiInClose();
        _engine._unwatch();
      };
      _engine._watch = function() {
        if (!watcher) watcher = setInterval(function() {
          _engine._refresh();
        }, 250);
      };
      _engine._unwatch = function() {
        if (watcher) clearInterval(watcher);
        watcher = void 0;
      };
    }
    function _initNode(obj) {
      _engine._type = "node";
      _engine._main = obj;
      _engine._pool = [];
      _engine._newPlugin = function() {
        return new obj.MIDI();
      };
      _initEngineJP();
    }
    function _initJazzPlugin(obj) {
      _engine._type = "plugin";
      _engine._main = obj;
      _engine._pool = [obj];
      _engine._newPlugin = function() {
        var plg = document.createElement("object");
        plg.style.visibility = "hidden";
        plg.style.width = "0px";
        obj.style.height = "0px";
        plg.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90";
        plg.type = "audio/x-jazz";
        document.body.appendChild(plg);
        return plg.isJazz ? plg : void 0;
      };
      _initEngineJP();
    }
    function _initWebMIDI(access, sysex) {
      _engine._type = "webmidi";
      _engine._version = 43;
      _engine._sysex = !!sysex;
      _engine._access = access;
      _engine._inMap = {};
      _engine._outMap = {};
      _engine._outsW = [];
      _engine._insW = [];
      var watcher;
      function _closeAll() {
        for (var i3 = 0; i3 < this.clients.length; i3++) this._close(this.clients[i3]);
      }
      _engine._refresh = function() {
        _engine._outs = [];
        _engine._ins = [];
        _engine._access.outputs.forEach(function(port) {
          _engine._outs.push({ type: _engine._type, name: port.name, manufacturer: port.manufacturer, version: port.version });
        });
        _engine._access.inputs.forEach(function(port) {
          _engine._ins.push({ type: _engine._type, name: port.name, manufacturer: port.manufacturer, version: port.version });
        });
        _postRefresh();
      };
      _engine._openOut = function(port, name) {
        var impl = _engine._outMap[name];
        if (!impl) {
          impl = {
            name,
            clients: [],
            info: {
              name,
              manufacturer: _engine._allOuts[name].manufacturer,
              version: _engine._allOuts[name].version,
              type: "MIDI-out",
              sysex: _engine._sysex,
              engine: _engine._type
            },
            _close: function(port2) {
              _engine._closeOut(port2);
            },
            _closeAll,
            _receive: function(a2) {
              if (impl.dev && a2.length) this.dev.send(a2.slice());
            }
          };
        }
        var found;
        _engine._access.outputs.forEach(function(dev) {
          if (dev.name === name) found = dev;
        });
        if (found) {
          impl.dev = found;
          _engine._outMap[name] = impl;
          port._orig._impl = impl;
          _push(impl.clients, port._orig);
          port._info = impl.info;
          port._receive = function(arg) {
            impl._receive(arg);
          };
          port._close = function() {
            impl._close(this);
          };
          if (impl.dev.open) {
            port._pause();
            impl.dev.open().then(function() {
              port._resume();
            }, function() {
              port._crash();
            });
          }
        } else port._break();
      };
      _engine._openIn = function(port, name) {
        var impl = _engine._inMap[name];
        if (!impl) {
          impl = {
            name,
            clients: [],
            info: {
              name,
              manufacturer: _engine._allIns[name].manufacturer,
              version: _engine._allIns[name].version,
              type: "MIDI-in",
              sysex: _engine._sysex,
              engine: _engine._type
            },
            _close: function(port2) {
              _engine._closeIn(port2);
            },
            _closeAll,
            handle: function(evt) {
              for (var i3 = 0; i3 < this.clients.length; i3++) {
                var msg = MIDI([].slice.call(evt.data));
                this.clients[i3]._emit(msg);
              }
            }
          };
        }
        var found;
        _engine._access.inputs.forEach(function(dev) {
          if (dev.name === name) found = dev;
        });
        if (found) {
          impl.dev = found;
          var makeHandle = function(x3) {
            return function(evt) {
              x3.handle(evt);
            };
          };
          impl.dev.onmidimessage = makeHandle(impl);
          _engine._inMap[name] = impl;
          port._orig._impl = impl;
          _push(impl.clients, port._orig);
          port._info = impl.info;
          port._close = function() {
            impl._close(this);
          };
          if (impl.dev.open) {
            port._pause();
            impl.dev.open().then(function() {
              port._resume();
            }, function() {
              port._crash();
            });
          }
        } else port._break();
      };
      _engine._closeOut = function(port) {
        var impl = port._impl;
        _pop(impl.clients, port._orig);
        if (!impl.clients.length) {
          if (impl.dev && impl.dev.close) impl.dev.close();
          impl.dev = void 0;
        }
      };
      _engine._closeIn = function(port) {
        var impl = port._impl;
        _pop(impl.clients, port._orig);
        if (!impl.clients.length) {
          if (impl.dev) {
            impl.dev.onmidimessage = null;
            if (impl.dev.close) impl.dev.close();
          }
          impl.dev = void 0;
        }
      };
      _engine._close = function() {
        _engine._unwatch();
      };
      _engine._watch = function() {
        _engine._access.onstatechange = function() {
          watcher = true;
          _schedule(function() {
            if (watcher) {
              _engine._refresh();
              watcher = false;
            }
          });
        };
      };
      _engine._unwatch = function() {
        _engine._access.onstatechange = void 0;
      };
    }
    function _initCRX(msg, ver) {
      _engine._type = "extension";
      _engine._version = ver;
      _engine._sysex = true;
      _engine._pool = [];
      _engine._outs = [];
      _engine._ins = [];
      _engine._inArr = [];
      _engine._outArr = [];
      _engine._inMap = {};
      _engine._outMap = {};
      _engine._outsW = [];
      _engine._insW = [];
      _engine.refreshClients = [];
      _engine._msg = msg;
      _engine._newPlugin = function() {
        var plugin = { id: _engine._pool.length };
        _engine._pool.push(plugin);
        if (!plugin.id) plugin.ready = true;
        else document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["new"] }));
      };
      _engine._newPlugin();
      _engine._refresh = function(client) {
        _engine.refreshClients.push(client);
        client._pause();
        _schedule(function() {
          document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["refresh"] }));
        });
      };
      function _closeAll() {
        for (var i3 = 0; i3 < this.clients.length; i3++) this._close(this.clients[i3]);
      }
      _engine._openOut = function(port, name) {
        var impl = _engine._outMap[name];
        if (!impl) {
          if (_engine._pool.length <= _engine._outArr.length) _engine._newPlugin();
          var plugin = _engine._pool[_engine._outArr.length];
          impl = {
            name,
            clients: [],
            info: {
              name,
              manufacturer: _engine._allOuts[name].manufacturer,
              version: _engine._allOuts[name].version,
              type: "MIDI-out",
              sysex: _engine._sysex,
              engine: _engine._type
            },
            _start: function() {
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["openout", plugin.id, name] }));
            },
            _close: function(port2) {
              _engine._closeOut(port2);
            },
            _closeAll,
            _receive: function(a2) {
              if (a2.length) {
                var v2 = a2.slice();
                v2.splice(0, 0, "play", plugin.id);
                document.dispatchEvent(new CustomEvent("jazz-midi", { detail: v2 }));
              }
            }
          };
          impl.plugin = plugin;
          plugin.output = impl;
          _engine._outArr.push(impl);
          _engine._outMap[name] = impl;
        }
        port._orig._impl = impl;
        _push(impl.clients, port._orig);
        port._info = impl.info;
        port._receive = function(arg) {
          impl._receive(arg);
        };
        port._close = function() {
          impl._close(this);
        };
        if (!impl.open) {
          port._pause();
          if (impl.plugin.ready) impl._start();
        }
      };
      _engine._openIn = function(port, name) {
        var impl = _engine._inMap[name];
        if (!impl) {
          if (_engine._pool.length <= _engine._inArr.length) _engine._newPlugin();
          var plugin = _engine._pool[_engine._inArr.length];
          impl = {
            name,
            clients: [],
            info: {
              name,
              manufacturer: _engine._allIns[name].manufacturer,
              version: _engine._allIns[name].version,
              type: "MIDI-in",
              sysex: _engine._sysex,
              engine: _engine._type
            },
            _start: function() {
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["openin", plugin.id, name] }));
            },
            _close: function(port2) {
              _engine._closeIn(port2);
            },
            _closeAll
          };
          impl.plugin = plugin;
          plugin.input = impl;
          _engine._inArr.push(impl);
          _engine._inMap[name] = impl;
        }
        port._orig._impl = impl;
        _push(impl.clients, port._orig);
        port._info = impl.info;
        port._close = function() {
          impl._close(this);
        };
        if (!impl.open) {
          port._pause();
          if (impl.plugin.ready) impl._start();
        }
      };
      _engine._closeOut = function(port) {
        var impl = port._impl;
        _pop(impl.clients, port._orig);
        if (!impl.clients.length && impl.open) {
          impl.open = false;
          document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["closeout", impl.plugin.id] }));
        }
      };
      _engine._closeIn = function(port) {
        var impl = port._impl;
        _pop(impl.clients, port._orig);
        if (!impl.clients.length && impl.open) {
          impl.open = false;
          document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["closein", impl.plugin.id] }));
        }
      };
      _engine._close = function() {
        _engine._unwatch();
      };
      var watcher;
      _engine._watch = function() {
        _engine._insW = _engine._ins;
        _engine._outsW = _engine._outs;
        watcher = setInterval(function() {
          document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["refresh"] }));
        }, 250);
      };
      _engine._unwatch = function() {
        clearInterval(watcher);
        watcher = void 0;
      };
      document.addEventListener("jazz-midi-msg", function(evt) {
        var i3, j3, impl;
        var v2 = evt.detail ? [evt.detail] : void 0;
        if (!v2) {
          v2 = _engine._msg.innerText.split("\n");
          _engine._msg.innerText = "";
          for (i3 = 0; i3 < v2.length; i3++) try {
            v2[i3] = JSON.parse(v2[i3]);
          } catch (err) {
            v2[i3] = [];
          }
        }
        for (i3 = 0; i3 < v2.length; i3++) {
          var a2 = v2[i3];
          if (!a2.length) continue;
          if (a2[0] === "refresh") {
            if (a2[1].ins) {
              for (j3 = 0; j3 < a2[1].ins.length; j3++) a2[1].ins[j3].type = _engine._type;
              _engine._ins = a2[1].ins;
            }
            if (a2[1].outs) {
              for (j3 = 0; j3 < a2[1].outs.length; j3++) a2[1].outs[j3].type = _engine._type;
              _engine._outs = a2[1].outs;
            }
            _postRefresh();
            for (j3 = 0; j3 < _engine.refreshClients.length; j3++) _engine.refreshClients[j3]._resume();
            _engine.refreshClients = [];
          } else if (a2[0] === "version") {
            var plugin = _engine._pool[a2[1]];
            if (plugin) {
              plugin.ready = true;
              if (plugin.input) plugin.input._start();
              if (plugin.output) plugin.output._start();
            }
          } else if (a2[0] === "openout") {
            impl = _engine._pool[a2[1]].output;
            if (impl) {
              if (a2[2] == impl.name) {
                impl.open = true;
                if (impl.clients) for (j3 = 0; j3 < impl.clients.length; j3++) impl.clients[j3]._resume();
              } else if (impl.clients) for (j3 = 0; j3 < impl.clients.length; j3++) impl.clients[j3]._crash();
            }
          } else if (a2[0] === "openin") {
            impl = _engine._pool[a2[1]].input;
            if (impl) {
              if (a2[2] == impl.name) {
                impl.open = true;
                if (impl.clients) for (j3 = 0; j3 < impl.clients.length; j3++) impl.clients[j3]._resume();
              } else if (impl.clients) for (j3 = 0; j3 < impl.clients.length; j3++) impl.clients[j3]._crash();
            }
          } else if (a2[0] === "midi") {
            impl = _engine._pool[a2[1]].input;
            if (impl && impl.clients) {
              for (j3 = 0; j3 < impl.clients.length; j3++) {
                var msg2 = MIDI(a2.slice(3));
                impl.clients[j3]._emit(msg2);
              }
            }
          }
        }
      });
    }
    var JZZ2 = function(opt) {
      if (!_jzz) _initJZZ(opt);
      return _jzz._thenable();
    };
    JZZ2.JZZ = JZZ2;
    JZZ2.version = _version;
    JZZ2.info = function() {
      return _J.prototype.info();
    };
    function Widget(arg) {
      var self2 = new _M();
      if (arg instanceof Object) _for(arg, function(k3) {
        self2[k3] = arg[k3];
      });
      self2._resume();
      return self2;
    }
    JZZ2.Widget = Widget;
    _J.prototype.Widget = JZZ2.Widget;
    JZZ2.addMidiIn = function(name, widget) {
      var info = _clone(widget._info || {});
      info.name = name;
      info.type = info.type || "javascript";
      info.manufacturer = info.manufacturer || "virtual";
      info.version = info.version || "0.0";
      var engine = {
        _info: function() {
          return info;
        },
        _openIn: function(port) {
          port._pause();
          port._info = _clone(info);
          port._close = function() {
            widget.disconnect(port);
          };
          widget.connect(port);
          port._resume();
        }
      };
      return JZZ2.lib.registerMidiIn(name, engine);
    };
    _J.prototype.addMidiIn = JZZ2.addMidiIn;
    JZZ2.addMidiOut = function(name, widget) {
      var info = _clone(widget._info || {});
      info.name = name;
      info.type = info.type || "javascript";
      info.manufacturer = info.manufacturer || "virtual";
      info.version = info.version || "0.0";
      var engine = {
        _info: function() {
          return info;
        },
        _openOut: function(port) {
          port._pause();
          port._info = _clone(info);
          port._close = function() {
            port.disconnect();
          };
          _connect.apply(port, [widget]);
          port._resume();
        }
      };
      return JZZ2.lib.registerMidiOut(name, engine);
    };
    _J.prototype.addMidiOut = JZZ2.addMidiOut;
    JZZ2.removeMidiOut = function(name) {
      return JZZ2.lib.unregisterMidiOut(name);
    };
    _J.prototype.removeMidiOut = JZZ2.removeMidiOut;
    JZZ2.removeMidiIn = function(name) {
      return JZZ2.lib.unregisterMidiIn(name);
    };
    _J.prototype.removeMidiIn = JZZ2.removeMidiIn;
    JZZ2.maskMidiIn = function(name) {
      _insM[name] = true;
    };
    _J.prototype.maskMidiIn = JZZ2.maskMidiIn;
    JZZ2.unmaskMidiIn = function(name) {
      delete _insM[name];
    };
    _J.prototype.unmaskMidiIn = JZZ2.unmaskMidiIn;
    JZZ2.maskMidiOut = function(name) {
      _outsM[name] = true;
    };
    _J.prototype.maskMidiOut = JZZ2.maskMidiOut;
    JZZ2.unmaskMidiOut = function(name) {
      delete _outsM[name];
    };
    _J.prototype.unmaskMidiOut = JZZ2.unmaskMidiOut;
    function SMPTE() {
      var self2 = this instanceof SMPTE ? this : self2 = new SMPTE();
      SMPTE.prototype.reset.apply(self2, arguments);
      return self2;
    }
    SMPTE.prototype.reset = function(arg) {
      if (arg instanceof SMPTE) {
        this.setType(arg.getType());
        this.setHour(arg.getHour());
        this.setMinute(arg.getMinute());
        this.setSecond(arg.getSecond());
        this.setFrame(arg.getFrame());
        this.setQuarter(arg.getQuarter());
        return this;
      }
      var arr = arg instanceof Array ? arg : arguments;
      this.setType(arr[0]);
      this.setHour(arr[1]);
      this.setMinute(arr[2]);
      this.setSecond(arr[3]);
      this.setFrame(arr[4]);
      this.setQuarter(arr[5]);
      return this;
    };
    function _fixDropFrame() {
      if (this.type == 29.97 && !this.second && this.frame < 2 && this.minute % 10) this.frame = 2;
    }
    SMPTE.prototype.isFullFrame = function() {
      return this.quarter == 0 || this.quarter == 4;
    };
    SMPTE.prototype.getType = function() {
      return this.type;
    };
    SMPTE.prototype.getHour = function() {
      return this.hour;
    };
    SMPTE.prototype.getMinute = function() {
      return this.minute;
    };
    SMPTE.prototype.getSecond = function() {
      return this.second;
    };
    SMPTE.prototype.getFrame = function() {
      return this.frame;
    };
    SMPTE.prototype.getQuarter = function() {
      return this.quarter;
    };
    SMPTE.prototype.setType = function(x3) {
      if (typeof x3 == "undefined" || x3 == 24) this.type = 24;
      else if (x3 == 25) this.type = 25;
      else if (x3 == 29.97) {
        this.type = 29.97;
        _fixDropFrame.apply(this);
      } else if (x3 == 30) this.type = 30;
      else throw RangeError("Bad SMPTE frame rate: " + x3);
      if (this.frame >= this.type) this.frame = this.type - 1;
      return this;
    };
    SMPTE.prototype.setHour = function(x3) {
      if (typeof x3 == "undefined") x3 = 0;
      if (x3 != parseInt(x3) || x3 < 0 || x3 >= 24) throw RangeError("Bad SMPTE hours value: " + x3);
      this.hour = x3;
      return this;
    };
    SMPTE.prototype.setMinute = function(x3) {
      if (typeof x3 == "undefined") x3 = 0;
      if (x3 != parseInt(x3) || x3 < 0 || x3 >= 60) throw RangeError("Bad SMPTE minutes value: " + x3);
      this.minute = x3;
      _fixDropFrame.apply(this);
      return this;
    };
    SMPTE.prototype.setSecond = function(x3) {
      if (typeof x3 == "undefined") x3 = 0;
      if (x3 != parseInt(x3) || x3 < 0 || x3 >= 60) throw RangeError("Bad SMPTE seconds value: " + x3);
      this.second = x3;
      _fixDropFrame.apply(this);
      return this;
    };
    SMPTE.prototype.setFrame = function(x3) {
      if (typeof x3 == "undefined") x3 = 0;
      if (x3 != parseInt(x3) || x3 < 0 || x3 >= this.type) throw RangeError("Bad SMPTE frame number: " + x3);
      this.frame = x3;
      _fixDropFrame.apply(this);
      return this;
    };
    SMPTE.prototype.setQuarter = function(x3) {
      if (typeof x3 == "undefined") x3 = 0;
      if (x3 != parseInt(x3) || x3 < 0 || x3 >= 8) throw RangeError("Bad SMPTE quarter frame: " + x3);
      this.quarter = x3;
      return this;
    };
    SMPTE.prototype.incrFrame = function() {
      this.frame++;
      if (this.frame >= this.type) {
        this.frame = 0;
        this.second++;
        if (this.second >= 60) {
          this.second = 0;
          this.minute++;
          if (this.minute >= 60) {
            this.minute = 0;
            this.hour = this.hour >= 23 ? 0 : this.hour + 1;
          }
        }
      }
      _fixDropFrame.apply(this);
      return this;
    };
    SMPTE.prototype.decrFrame = function() {
      if (!this.second && this.frame == 2 && this.type == 29.97 && this.minute % 10) this.frame = 0;
      this.frame--;
      if (this.frame < 0) {
        this.frame = this.type == 29.97 ? 29 : this.type - 1;
        this.second--;
        if (this.second < 0) {
          this.second = 59;
          this.minute--;
          if (this.minute < 0) {
            this.minute = 59;
            this.hour = this.hour ? this.hour - 1 : 23;
          }
        }
      }
      return this;
    };
    SMPTE.prototype.incrQF = function() {
      this.backwards = false;
      this.quarter = this.quarter + 1 & 7;
      if (this.quarter == 0 || this.quarter == 4) this.incrFrame();
      return this;
    };
    SMPTE.prototype.decrQF = function() {
      this.backwards = true;
      this.quarter = this.quarter + 7 & 7;
      if (this.quarter == 3 || this.quarter == 7) this.decrFrame();
      return this;
    };
    function _825(a2) {
      return [[24, 25, 29.97, 30][a2[7] >> 1 & 3], (a2[7] & 1) << 4 | a2[6], a2[5] << 4 | a2[4], a2[3] << 4 | a2[2], a2[1] << 4 | a2[0]];
    }
    SMPTE.prototype.read = function(m3) {
      if (!(m3 instanceof MIDI)) m3 = MIDI.apply(null, arguments);
      if (m3[0] == 240 && m3[1] == 127 && m3[3] == 1 && m3[4] == 1 && m3[9] == 247) {
        this.type = [24, 25, 29.97, 30][m3[5] >> 5 & 3];
        this.hour = m3[5] & 31;
        this.minute = m3[6];
        this.second = m3[7];
        this.frame = m3[8];
        this.quarter = 0;
        this._ = void 0;
        this._b = void 0;
        this._f = void 0;
        return true;
      }
      if (m3[0] == 241 && typeof m3[1] != "undefined") {
        var q2 = m3[1] >> 4;
        var n2 = m3[1] & 15;
        if (q2 == 0) {
          if (this._ == 7) {
            if (this._f == 7) {
              this.reset(_825(this._a));
              this.incrFrame();
            }
            this.incrFrame();
          }
        } else if (q2 == 3) {
          if (this._ == 4) {
            this.decrFrame();
          }
        } else if (q2 == 4) {
          if (this._ == 3) {
            this.incrFrame();
          }
        } else if (q2 == 7) {
          if (this._ === 0) {
            if (this._b === 0) {
              this.reset(_825(this._a));
              this.decrFrame();
            }
            this.decrFrame();
          }
        }
        if (!this._a) this._a = [];
        this._a[q2] = n2;
        this._f = this._f === q2 - 1 || q2 == 0 ? q2 : void 0;
        this._b = this._b === q2 + 1 || q2 == 7 ? q2 : void 0;
        this._ = q2;
        this.quarter = q2;
        return true;
      }
      return false;
    };
    function _mtc(t2) {
      if (!t2.backwards && t2.quarter >= 4) t2.decrFrame();
      else if (t2.backwards && t2.quarter < 4) t2.incrFrame();
      var ret;
      switch (t2.quarter >> 1) {
        case 0:
          ret = t2.frame;
          break;
        case 1:
          ret = t2.second;
          break;
        case 2:
          ret = t2.minute;
          break;
        default:
          ret = t2.hour;
      }
      if (t2.quarter & 1) ret >>= 4;
      else ret &= 15;
      if (t2.quarter == 7) {
        if (t2.type == 25) ret |= 2;
        else if (t2.type == 29.97) ret |= 4;
        else if (t2.type == 30) ret |= 6;
      }
      if (!t2.backwards && t2.quarter >= 4) t2.incrFrame();
      else if (t2.backwards && t2.quarter < 4) t2.decrFrame();
      return ret | t2.quarter << 4;
    }
    function _hrtype(t2) {
      if (t2.type == 25) return t2.hour | 32;
      if (t2.type == 29.97) return t2.hour | 64;
      if (t2.type == 30) return t2.hour | 96;
      return t2.hour;
    }
    function _dec(x3) {
      return x3 < 10 ? "0" + x3 : x3;
    }
    function _smptetxt(x3) {
      var arr = [];
      for (var i3 = 0; i3 < x3.length; i3++) arr[i3] = _dec(i3 ? x3[i3] : x3[i3] & 31);
      return arr.join(":");
    }
    SMPTE.prototype.toString = function() {
      return _smptetxt([this.hour, this.minute, this.second, this.frame]);
    };
    JZZ2.SMPTE = SMPTE;
    _J.prototype.SMPTE = SMPTE;
    function MIDI(arg) {
      var self2 = this instanceof MIDI ? this : self2 = new MIDI();
      var i3;
      if (arg instanceof MIDI) {
        self2._from = arg._from.slice();
        _for(arg, function(i4) {
          if (i4 != "_from") self2[i4] = arg[i4];
        });
        return self2;
      } else self2._from = [];
      if (typeof arg == "undefined") return self2;
      var arr = arg instanceof Array ? arg : arguments;
      for (i3 = 0; i3 < arr.length; i3++) {
        n = arr[i3];
        if (i3 == 1) {
          if (self2[0] >= 128 && self2[0] <= 175) n = MIDI.noteValue(n);
          if (self2[0] >= 192 && self2[0] <= 207) n = MIDI.programValue(n);
        }
        if (n != parseInt(n) || n < 0 || n > 255) _throw(arr[i3]);
        self2.push(n);
      }
      return self2;
    }
    MIDI.prototype = [];
    MIDI.prototype.constructor = MIDI;
    MIDI.prototype.isMidi = function() {
      return 1;
    };
    var _noteNum = {};
    MIDI.noteValue = function(x3) {
      return typeof x3 == "undefined" ? void 0 : _noteNum[x3.toString().toLowerCase()];
    };
    MIDI.programValue = function(x3) {
      return x3;
    };
    MIDI.octaveValue = function(x3) {
      var n2 = _noteNum[x3.toString().toLowerCase()];
      if (typeof n2 == "undefined") n2 = _noteNum[x3.toString().toLowerCase() + "1"];
      return typeof n2 == "undefined" ? void 0 : n2 % 12;
    };
    MIDI.freq = function(n2, a2) {
      if (typeof a2 == "undefined") a2 = 440;
      _float(a2);
      if (n2 != parseFloat(n2)) n2 = _7bn(n2);
      return a2 * Math.pow(2, (n2 - 69) / 12);
    };
    function _float(x3) {
      if (x3 != parseFloat(x3)) throw TypeError("Not a number: " + x3);
    }
    MIDI.shift = function(f3, f0) {
      if (typeof f0 == "undefined") f0 = 440;
      _float(f3);
      _float(f0);
      return Math.log2(f3 / f0) * 12;
    };
    MIDI.midi = function(f3, f0) {
      if (f3 != parseFloat(f3)) return _7bn(f3);
      return MIDI.shift(f3, f0) + 69;
    };
    MIDI.to7b = function(x3) {
      _float(x3);
      return x3 <= 0 ? 0 : x3 >= 1 ? 127 : Math.floor(x3 * 128);
    };
    MIDI.to14b = function(x3) {
      _float(x3);
      return x3 <= 0 ? 0 : x3 >= 1 ? 16383 : Math.floor(x3 * 16384);
    };
    MIDI.to21b = function(x3) {
      if (typeof x3 == "undefined") return 2097151;
      _float(x3);
      if (x3 <= 0) return 0;
      x3 = (Math.floor(x3) << 14) + MIDI.to14b(x3 - Math.floor(x3));
      return x3 < 2097151 ? x3 : 2097150;
    };
    MIDI.to32b = function(x3) {
      _float(x3);
      return x3 <= 0 ? 0 : x3 >= 1 ? 4294967295 : Math.floor(x3 * 4294967296);
    };
    function _MIDI() {
    }
    _MIDI.prototype = MIDI;
    MIDI._sxid = 127;
    MIDI.sxId = function(id2) {
      if (typeof id2 == "undefined") id2 = MIDI._sxid;
      if (id2 == this._sxid) return this;
      id2 = _7b(id2);
      var ret = new _MIDI();
      ret._ch = this._ch;
      ret._sxid = id2;
      return ret;
    };
    MIDI.ch = function(c2) {
      if (c2 == this._ch || typeof c2 == "undefined" && typeof this._ch == "undefined") return this;
      var ret = new _MIDI();
      if (typeof c2 != "undefined") c2 = _ch(c2);
      ret._ch = c2;
      ret._sxid = this._sxid;
      return ret;
    };
    var _noteMap = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11, h: 11 };
    _for(_noteMap, function(k3) {
      for (n = 0; n < 12; n++) {
        m2 = _noteMap[k3] + n * 12;
        if (m2 > 127) break;
        _noteNum[k3 + n] = m2;
        _noteNum[k3 + "" + n] = m2;
        if (m2 > 0) {
          _noteNum[k3 + "b" + n] = m2 - 1;
          _noteNum[k3 + "" + n] = m2 - 1;
          _noteNum[k3 + "bb" + n] = m2 - 2;
          _noteNum[k3 + "" + n] = m2 - 2;
          _noteNum[k3 + "" + n] = m2 - 2;
        }
        if (m2 < 127) {
          _noteNum[k3 + "#" + n] = m2 + 1;
          _noteNum[k3 + "" + n] = m2 + 1;
          _noteNum[k3 + "##" + n] = m2 + 2;
          _noteNum[k3 + "" + n] = m2 + 2;
          _noteNum[k3 + "" + n] = m2 + 2;
        }
      }
    });
    for (n = 0; n < 128; n++) _noteNum[n] = n;
    function _throw(x3) {
      throw RangeError("Bad MIDI value: " + x3);
    }
    function _bad(x3) {
      throw TypeError("Invalid value: " + x3);
    }
    function _oor(x3) {
      throw RangeError("Out of range: " + x3);
    }
    function _ch(c2) {
      _validateChannel(c2);
      return parseInt(c2);
    }
    function _4b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 15) throw RangeError("Expected a 4-bit value: " + n2);
      return parseInt(n2);
    }
    function _7b(n2, m3) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 127) _throw(typeof m3 == "undefined" ? n2 : m3);
      return parseInt(n2);
    }
    function _8b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 255) _throw(n2);
      return parseInt(n2);
    }
    function _14b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 16383) _throw(n2);
      return parseInt(n2);
    }
    function _16b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 65535) throw RangeError("Expected a 16-bit value: " + n2);
      return parseInt(n2);
    }
    function _20b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 1048575) throw RangeError("Expected a 20-bit value: " + n2);
      return parseInt(n2);
    }
    function _21b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 2097151) _throw(n2);
      return parseInt(n2);
    }
    function _32b(n2) {
      if (n2 != parseInt(n2) || n2 < 0 || n2 > 4294967295) _throw(n2);
      return parseInt(n2);
    }
    function _7bn(n2) {
      return _7b(MIDI.noteValue(n2), n2);
    }
    function _lsb(n2) {
      return _14b(n2) & 127;
    }
    function _msb(n2) {
      return _14b(n2) >> 7;
    }
    function _8bs(s2) {
      s2 = "" + s2;
      for (var i3 = 0; i3 < s2.length; i3++) if (s2.charCodeAt(i3) > 255) _throw(s2[i3]);
      return s2;
    }
    function _to777(n2) {
      return [n2 >> 14, n2 >> 7 & 127, n2 & 127];
    }
    function _01(x3, y2) {
      if (x3 != parseFloat(x3)) _bad(typeof y2 == "undefined" ? x3 : y2);
      if (x3 < 0 || x3 > 1) _oor(typeof y2 == "undefined" ? x3 : y2);
      return parseFloat(x3);
    }
    function _rt(b2) {
      return typeof b2 != "undefined" && !b2 ? 126 : 127;
    }
    function _ntu(x3) {
      var k3, m3;
      var kkk = [];
      var vvv = {};
      _for(x3, function(k4) {
        m3 = _21b(x3[k4]);
        k4 = _7bn(k4);
        if (k4 in vvv) throw RangeError("Duplicate MIDI value: " + k4);
        kkk.push(k4);
        vvv[k4] = m3;
      });
      kkk.sort();
      var out = [kkk.length];
      for (k3 = 0; k3 < kkk.length; k3++) out = out.concat([kkk[k3]], _to777(vvv[kkk[k3]]));
      return out;
    }
    function _f2ntu(x3) {
      var out = {};
      _for(x3, function(k3) {
        out[k3] = MIDI.to21b(x3[k3] == parseFloat(x3[k3]) ? x3[k3] : _7bn(x3[k3]));
      });
      return out;
    }
    function _hz2ntu(x3) {
      var out = {};
      _for(x3, function(k3) {
        out[k3] = MIDI.to21b(MIDI.midi(x3[k3]));
      });
      return out;
    }
    function _12x7(a2) {
      var out = [];
      if (!(a2 instanceof Array) || a2.length != 12) throw TypeError("Expected an array of size 12");
      for (var i3 = 0; i3 < 12; i3++) out.push(_7b(a2[i3]));
      return out;
    }
    function _12x14(a2) {
      var out = [];
      if (!(a2 instanceof Array) || a2.length != 12) throw TypeError("Expected an array of size 12");
      for (var i3 = 0; i3 < 12; i3++) {
        out.push(_msb(a2[i3]));
        out.push(_lsb(a2[i3]));
      }
      return out;
    }
    var _helperMPE = {
      noteOff: function(c2, n2, v2) {
        if (typeof v2 == "undefined") v2 = 64;
        return [128 + _ch(c2), _7bn(n2), _7b(v2)];
      },
      noteOn: function(c2, n2, v2) {
        if (typeof v2 == "undefined") v2 = 127;
        return [144 + _ch(c2), _7bn(n2), _7b(v2)];
      },
      aftertouch: function(c2, n2, v2) {
        return [160 + _ch(c2), _7bn(n2), _7b(v2)];
      }
    };
    var _helperCH = {
      control: function(c2, n2, v2) {
        return [176 + _ch(c2), _7b(n2), _7b(v2)];
      },
      program: function(c2, n2) {
        return [192 + _ch(c2), _7b(MIDI.programValue(n2), n2)];
      },
      pressure: function(c2, n2) {
        return [208 + _ch(c2), _7b(n2)];
      },
      pitchBend: function(c2, n2, l2) {
        return typeof l2 == "undefined" ? [224 + _ch(c2), _lsb(n2), _msb(n2)] : [224 + _ch(c2), _7b(l2), _7b(n2)];
      },
      pitchBendF: function(c2, x3) {
        return _helperCH.pitchBend(c2, MIDI.to14b((x3 + 1) / 2));
      },
      bankMSB: function(c2, n2) {
        return [176 + _ch(c2), 0, _7b(n2)];
      },
      bankLSB: function(c2, n2) {
        return [176 + _ch(c2), 32, _7b(n2)];
      },
      modMSB: function(c2, n2) {
        return [176 + _ch(c2), 1, _7b(n2)];
      },
      modLSB: function(c2, n2) {
        return [176 + _ch(c2), 33, _7b(n2)];
      },
      breathMSB: function(c2, n2) {
        return [176 + _ch(c2), 2, _7b(n2)];
      },
      breathLSB: function(c2, n2) {
        return [176 + _ch(c2), 34, _7b(n2)];
      },
      footMSB: function(c2, n2) {
        return [176 + _ch(c2), 4, _7b(n2)];
      },
      footLSB: function(c2, n2) {
        return [176 + _ch(c2), 36, _7b(n2)];
      },
      portamentoMSB: function(c2, n2) {
        return [176 + _ch(c2), 5, _7b(n2)];
      },
      portamentoLSB: function(c2, n2) {
        return [176 + _ch(c2), 37, _7b(n2)];
      },
      dataMSB: function(c2, n2) {
        return [176 + _ch(c2), 6, _7b(n2)];
      },
      dataLSB: function(c2, n2) {
        return [176 + _ch(c2), 38, _7b(n2)];
      },
      volumeMSB: function(c2, n2) {
        return [176 + _ch(c2), 7, _7b(n2)];
      },
      volumeLSB: function(c2, n2) {
        return [176 + _ch(c2), 39, _7b(n2)];
      },
      balanceMSB: function(c2, n2) {
        return [176 + _ch(c2), 8, _7b(n2)];
      },
      balanceLSB: function(c2, n2) {
        return [176 + _ch(c2), 40, _7b(n2)];
      },
      panMSB: function(c2, n2) {
        return [176 + _ch(c2), 10, _7b(n2)];
      },
      panLSB: function(c2, n2) {
        return [176 + _ch(c2), 42, _7b(n2)];
      },
      expressionMSB: function(c2, n2) {
        return [176 + _ch(c2), 11, _7b(n2)];
      },
      expressionLSB: function(c2, n2) {
        return [176 + _ch(c2), 43, _7b(n2)];
      },
      damper: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 64, b2 ? 127 : 0];
      },
      portamento: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 65, b2 ? 127 : 0];
      },
      sostenuto: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 66, b2 ? 127 : 0];
      },
      soft: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 67, b2 ? 127 : 0];
      },
      legato: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 68, b2 ? 127 : 0];
      },
      hold2: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 69, b2 ? 127 : 0];
      },
      soundVariation: function(c2, n2) {
        return [176 + _ch(c2), 70, _7bn(n2)];
      },
      filterResonance: function(c2, n2) {
        return [176 + _ch(c2), 71, _7bn(n2)];
      },
      releaseTime: function(c2, n2) {
        return [176 + _ch(c2), 72, _7bn(n2)];
      },
      attackTime: function(c2, n2) {
        return [176 + _ch(c2), 73, _7bn(n2)];
      },
      brightness: function(c2, n2) {
        return [176 + _ch(c2), 74, _7bn(n2)];
      },
      decayTime: function(c2, n2) {
        return [176 + _ch(c2), 75, _7bn(n2)];
      },
      vibratoRate: function(c2, n2) {
        return [176 + _ch(c2), 76, _7bn(n2)];
      },
      vibratoDepth: function(c2, n2) {
        return [176 + _ch(c2), 77, _7bn(n2)];
      },
      vibratoDelay: function(c2, n2) {
        return [176 + _ch(c2), 78, _7bn(n2)];
      },
      ptc: function(c2, n2) {
        return [176 + _ch(c2), 84, _7bn(n2)];
      },
      dataIncr: function(c2) {
        return [176 + _ch(c2), 96, 0];
      },
      dataDecr: function(c2) {
        return [176 + _ch(c2), 97, 0];
      },
      nrpnLSB: function(c2, n2) {
        return [176 + _ch(c2), 98, _7b(n2)];
      },
      nrpnMSB: function(c2, n2) {
        return [176 + _ch(c2), 99, _7b(n2)];
      },
      rpnLSB: function(c2, n2) {
        return [176 + _ch(c2), 100, _7b(n2)];
      },
      rpnMSB: function(c2, n2) {
        return [176 + _ch(c2), 101, _7b(n2)];
      },
      allSoundOff: function(c2) {
        return [176 + _ch(c2), 120, 0];
      },
      resetAllControllers: function(c2) {
        return [176 + _ch(c2), 121, 0];
      },
      localControl: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), 122, b2 ? 127 : 0];
      },
      allNotesOff: function(c2) {
        return [176 + _ch(c2), 123, 0];
      },
      omni: function(c2, b2) {
        if (typeof b2 == "undefined") b2 = true;
        return [176 + _ch(c2), b2 ? 125 : 124, 0];
      },
      mono: function(c2, n2) {
        if (typeof n2 == "undefined") n2 = 1;
        return [176 + _ch(c2), 126, _7b(n2)];
      },
      poly: function(c2) {
        return [176 + _ch(c2), 127, 0];
      }
    };
    function _splitMasterTuning(a2, b2, c2, d2) {
      if (typeof b2 != "undefined") return [_7b(a2), _7b(b2), _7b(c2), _7b(d2)];
      if (a2 != parseInt(a2) || a2 < 0 || a2 > 65535) _bad(a2);
      a2 = parseInt(a2);
      return [a2 >> 12 & 15, a2 >> 8 & 15, a2 >> 4 & 15, a2 & 15];
    }
    function _gsxg16b(x3) {
      _float(x3);
      x3 = Math.round(x3 * 65536 + 16384);
      return x3 < 0 ? 0 : x3 > 65535 ? 65535 : x3;
    }
    var _helperNC = {
      // no channel
      mtc: function(t2) {
        return [241, _mtc(t2)];
      },
      songPosition: function(n2, l2) {
        return typeof l2 == "undefined" ? [242, _lsb(n2), _msb(n2)] : [242, _7b(l2), _7b(n2)];
      },
      songSelect: function(n2) {
        return [243, _7b(n2)];
      },
      tune: function() {
        return [246];
      },
      clock: function() {
        return [248];
      },
      start: function() {
        return [250];
      },
      continue: function() {
        return [251];
      },
      stop: function() {
        return [252];
      },
      active: function() {
        return [254];
      },
      reset: function() {
        return [255];
      }
    };
    var _helperSX = {
      // SysEx
      sxIdRequest: function() {
        return [240, 126, this._sxid, 6, 1, 247];
      },
      sxTuningDumpRequest: function(n2, k3) {
        return typeof k3 == "undefined" ? [240, 126, this._sxid, 8, 0, _7b(n2), 247] : [240, 126, this._sxid, 8, 3, _7b(n2), _7b(k3), 247];
      },
      sxFullFrame: function(t2) {
        return [240, 127, this._sxid, 1, 1, _hrtype(t2), t2.getMinute(), t2.getSecond(), t2.getFrame(), 247];
      },
      sxMasterVolume: function(n2, l2) {
        return typeof l2 == "undefined" ? [240, 127, this._sxid, 4, 1, _lsb(n2), _msb(n2), 247] : [240, 127, this._sxid, 4, 1, _7b(l2), _7b(n2), 247];
      },
      sxMasterVolumeF: function(x3) {
        return _helperSX.sxMasterVolume.call(this, MIDI.to14b(_01(x3)));
      },
      sxMasterFineTuning: function(n2, l2) {
        return typeof l2 == "undefined" ? [240, 127, this._sxid, 4, 3, _lsb(n2), _msb(n2), 247] : [240, 127, this._sxid, 4, 3, _7b(l2), _7b(n2), 247];
      },
      sxMasterFineTuningF: function(x3) {
        return _helperSX.sxMasterFineTuning.call(this, MIDI.to14b(_01((x3 % 1 + 1) / 2, x3)));
      },
      sxMasterCoarseTuning: function(n2) {
        return [240, 127, this._sxid, 4, 4, 0, _7b(n2), 247];
      },
      sxMasterCoarseTuningF: function(x3) {
        return _helperSX.sxMasterCoarseTuning.call(this, 64 + (x3 - x3 % 1));
      },
      sxNoteTuning: function(a2, b2, c2, d2) {
        return b2 == parseInt(b2) ? [240, _rt(d2), this._sxid, 8, 7, _7b(a2), _7b(b2)].concat(_ntu(c2), [247]) : [240, 127, this._sxid, 8, 2, _7b(a2)].concat(_ntu(b2), [247]);
      },
      sxNoteTuningF: function(a2, b2, c2, d2) {
        return b2 == parseInt(b2) ? _helperSX.sxNoteTuning.call(this, a2, b2, _f2ntu(c2), d2) : _helperSX.sxNoteTuning.call(this, a2, _f2ntu(b2));
      },
      sxNoteTuningHZ: function(a2, b2, c2, d2) {
        return b2 == parseInt(b2) ? _helperSX.sxNoteTuning.call(this, a2, b2, _hz2ntu(c2), d2) : _helperSX.sxNoteTuning.call(this, a2, _hz2ntu(b2));
      },
      sxScaleTuning1: function(a2, b2, c2) {
        return a2 == parseInt(a2) ? [240, _rt(c2), this._sxid, 8, 8].concat(_to777(_16b(a2)), _12x7(b2), [247]) : _helperSX.sxScaleTuning1.call(this, 65535, a2, b2);
      },
      sxScaleTuning1F: function(a2, b2, c2) {
        if (a2 != parseInt(a2)) return _helperSX.sxScaleTuning1F.call(this, 65535, a2, b2);
        var v2 = [];
        for (var i3 = 0; i3 < b2.length; i3++) {
          if (b2[i3] < -0.64 || b2[i3] > 0.63) throw RangeError("Out of range: " + b2[i3]);
          v2.push(Math.floor(b2[i3] * 100 + 64));
        }
        return _helperSX.sxScaleTuning1.call(this, a2, v2, c2);
      },
      sxScaleTuning2: function(a2, b2, c2) {
        return a2 == parseInt(a2) ? [240, _rt(c2), this._sxid, 8, 9].concat(_to777(_16b(a2)), _12x14(b2), [247]) : _helperSX.sxScaleTuning2.call(this, 65535, a2, b2);
      },
      sxScaleTuning2F: function(a2, b2, c2) {
        if (a2 != parseInt(a2)) return _helperSX.sxScaleTuning2F.call(this, 65535, a2, b2);
        var v2 = [];
        for (var i3 = 0; i3 < b2.length; i3++) {
          var x3 = (b2[i3] + 1) / 2;
          if (x3 < -1 || x3 > 1) throw RangeError("Out of range: " + b2[i3]);
          v2.push(MIDI.to14b((b2[i3] + 1) / 2));
        }
        return _helperSX.sxScaleTuning2.call(this, a2, v2, c2);
      },
      sxGM: function(gm) {
        if (typeof gm == "undefined") gm = 1;
        return [240, 126, this._sxid, 9, gm ? gm == 2 ? 3 : 1 : 2, 247];
      },
      sxGS: function(arg) {
        var arr = typeof arg == "undefined" ? [64, 0, 127, 0] : arg instanceof Array ? arg : arguments;
        var c2 = 0;
        var a2 = [240, 65, this._sxid, 66, 18];
        for (var i3 = 0; i3 < arr.length; i3++) {
          var x3 = _7b(arr[i3]);
          a2.push(x3);
          c2 += x3;
        }
        c2 %= 128;
        a2.push(c2 ? 128 - c2 : 0);
        a2.push(247);
        return a2;
      },
      sxXG: function(arg) {
        var arr = typeof arg == "undefined" ? [0, 0, 126, 0] : arg instanceof Array ? arg : arguments;
        var sxid = this._sxid == 127 ? 0 : this._sxid;
        if (sxid > 15) _throw("Bad Yamaha device number: " + sxid);
        var a2 = [240, 67, 16 + sxid, 76];
        for (var i3 = 0; i3 < arr.length; i3++) a2.push(_7b(arr[i3]));
        a2.push(247);
        return a2;
      },
      sxMidiSoft: function(n2, s2) {
        var a2 = [240, 0, 32, 36, 0, _7b(n2 || 0)];
        s2 = typeof s2 == "undefined" ? "" : "" + s2;
        for (var i3 = 0; i3 < s2.length; i3++) a2.push(_7b(s2.charCodeAt(i3)));
        a2.push(247);
        return a2;
      },
      gsMasterVolume: function(n2) {
        return _helperSX.sxGS.call(this, [64, 0, 4, _7b(n2)]);
      },
      gsMasterVolumeF: function(x3) {
        return _helperSX.gsMasterVolume.call(this, MIDI.to7b(_01(x3)));
      },
      gsMasterFineTuning: function(a2, b2, c2, d2) {
        a2 = _splitMasterTuning(a2, b2, c2, d2);
        return _helperSX.sxGS.call(this, [64, 0, 0, a2[0], a2[1], a2[2], a2[3]]);
      },
      gsMasterFineTuningF: function(x3) {
        return _helperSX.gsMasterFineTuning.call(this, _gsxg16b(x3 % 1));
      },
      gsMasterCoarseTuning: function(n2) {
        return _helperSX.sxGS.call(this, [64, 0, 5, _7b(n2)]);
      },
      gsMasterCoarseTuningF: function(x3) {
        return _helperSX.gsMasterCoarseTuning.call(this, 64 + (x3 - x3 % 1));
      },
      gsOctaveTuning: function(c2, n2, x3) {
        return _helperSX.sxGS.call(this, [64, 16 + [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15][_ch(c2)], 64 + MIDI.octaveValue(n2), _7b(x3)]);
      },
      gsOctaveTuningF: function(c2, n2, x3) {
        if (x3 < -0.64 || x3 > 0.63) throw RangeError("Out of range: " + x3);
        return _helperSX.gsOctaveTuning.call(this, c2, n2, Math.floor(x3 * 100 + 64));
      },
      xgMasterVolume: function(n2) {
        return _helperSX.sxXG.call(this, [0, 0, 4, _7b(n2)]);
      },
      xgMasterVolumeF: function(x3) {
        return _helperSX.xgMasterVolume.call(this, MIDI.to7b(_01(x3)));
      },
      xgMasterFineTuning: function(a2, b2, c2, d2) {
        a2 = _splitMasterTuning(a2, b2, c2, d2);
        return _helperSX.sxXG.call(this, [0, 0, 0, a2[0], a2[1], a2[2], a2[3]]);
      },
      xgMasterFineTuningF: function(x3) {
        return _helperSX.xgMasterFineTuning.call(this, _gsxg16b(x3 % 1));
      },
      xgMasterCoarseTuning: function(n2) {
        return _helperSX.sxXG.call(this, [0, 0, 6, _7b(n2)]);
      },
      xgMasterCoarseTuningF: function(x3) {
        return _helperSX.xgMasterCoarseTuning.call(this, 64 + (x3 - x3 % 1));
      },
      xgOctaveTuning: function(c2, n2, x3) {
        return _helperSX.sxXG.call(this, [8, _ch(c2), 65 + MIDI.octaveValue(n2), _7b(x3)]);
      },
      xgOctaveTuningF: function(c2, n2, x3) {
        if (x3 < -0.64 || x3 > 0.63) throw RangeError("Out of range: " + x3);
        return _helperSX.xgOctaveTuning.call(this, c2, n2, Math.floor(x3 * 100 + 64));
      }
    };
    _helperSX.sxScaleTuning = _helperSX.sxScaleTuning2;
    _helperSX.sxScaleTuningF = _helperSX.sxScaleTuning2F;
    _helperSX.sxMasterTranspose = _helperSX.sxMasterCoarseTuning;
    _helperSX.sxMasterTransposeF = _helperSX.sxMasterCoarseTuningF;
    _helperSX.gsMasterTranspose = _helperSX.gsMasterCoarseTuning;
    _helperSX.gsMasterTransposeF = _helperSX.gsMasterCoarseTuningF;
    _helperSX.xgMasterTranspose = _helperSX.xgMasterCoarseTuning;
    _helperSX.xgMasterTransposeF = _helperSX.xgMasterCoarseTuningF;
    var _helperGCH = {
      // compound messages
      bank: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.bankMSB(c2, _msb(m3)), _helperCH.bankLSB(c2, _lsb(m3))] : [_helperCH.bankMSB(c2, m3), _helperCH.bankLSB(c2, l2)];
      },
      modF: function(c2, x3) {
        return _helperGCH.mod(c2, MIDI.to14b(x3));
      },
      mod: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.modMSB(c2, _msb(m3)), _helperCH.modLSB(c2, _lsb(m3))] : [_helperCH.modMSB(c2, m3), _helperCH.modLSB(c2, l2)];
      },
      breathF: function(c2, x3) {
        return _helperGCH.breath(c2, MIDI.to14b(x3));
      },
      breath: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.breathMSB(c2, _msb(m3)), _helperCH.breathLSB(c2, _lsb(m3))] : [_helperCH.breathMSB(c2, m3), _helperCH.breathLSB(c2, l2)];
      },
      footF: function(c2, x3) {
        return _helperGCH.foot(c2, MIDI.to14b(x3));
      },
      foot: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.footMSB(c2, _msb(m3)), _helperCH.footLSB(c2, _lsb(m3))] : [_helperCH.footMSB(c2, m3), _helperCH.footLSB(c2, l2)];
      },
      portamentoTimeF: function(c2, x3) {
        return _helperGCH.portamentoTime(c2, MIDI.to14b(x3));
      },
      portamentoTime: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.portamentoMSB(c2, _msb(m3)), _helperCH.portamentoLSB(c2, _lsb(m3))] : [_helperCH.portamentoMSB(c2, m3), _helperCH.portamentoLSB(c2, l2)];
      },
      dataF: function(c2, x3) {
        return _helperGCH.data(c2, MIDI.to14b(x3));
      },
      data: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.dataMSB(c2, _msb(m3)), _helperCH.dataLSB(c2, _lsb(m3))] : [_helperCH.dataMSB(c2, m3), _helperCH.dataLSB(c2, l2)];
      },
      volumeF: function(c2, x3) {
        return _helperGCH.volume(c2, MIDI.to14b(x3));
      },
      volume: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.volumeMSB(c2, _msb(m3)), _helperCH.volumeLSB(c2, _lsb(m3))] : [_helperCH.volumeMSB(c2, m3), _helperCH.volumeLSB(c2, l2)];
      },
      balanceF: function(c2, x3) {
        return _helperGCH.balance(c2, MIDI.to14b((x3 + 1) / 2));
      },
      balance: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.balanceMSB(c2, _msb(m3)), _helperCH.balanceLSB(c2, _lsb(m3))] : [_helperCH.balanceMSB(c2, m3), _helperCH.balanceLSB(c2, l2)];
      },
      panF: function(c2, x3) {
        return _helperGCH.pan(c2, MIDI.to14b((x3 + 1) / 2));
      },
      pan: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.panMSB(c2, _msb(m3)), _helperCH.panLSB(c2, _lsb(m3))] : [_helperCH.panMSB(c2, m3), _helperCH.panLSB(c2, l2)];
      },
      expressionF: function(c2, x3) {
        return _helperGCH.expression(c2, MIDI.to14b(x3));
      },
      expression: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.expressionMSB(c2, _msb(m3)), _helperCH.expressionLSB(c2, _lsb(m3))] : [_helperCH.expressionMSB(c2, m3), _helperCH.expressionLSB(c2, l2)];
      },
      nrpn: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.nrpnMSB(c2, _msb(m3)), _helperCH.nrpnLSB(c2, _lsb(m3))] : [_helperCH.nrpnMSB(c2, m3), _helperCH.nrpnLSB(c2, l2)];
      },
      rpn: function(c2, m3, l2) {
        return typeof l2 == "undefined" ? [_helperCH.rpnMSB(c2, _msb(m3)), _helperCH.rpnLSB(c2, _lsb(m3))] : [_helperCH.rpnMSB(c2, m3), _helperCH.rpnLSB(c2, l2)];
      },
      rpnPitchBendRange: function(c2, m3, l2) {
        return _helperGCH.rpn(c2, 0, 0).concat(_helperGCH.data(c2, m3, l2));
      },
      rpnPitchBendRangeF: function(c2, x3) {
        return _helperGCH.rpnPitchBendRange(c2, _7b(x3 - x3 % 1), Math.floor(x3 % 1 * 100));
      },
      rpnFineTuning: function(c2, m3, l2) {
        return _helperGCH.rpn(c2, 0, 1).concat(_helperGCH.data(c2, m3, l2));
      },
      rpnFineTuningF: function(c2, x3) {
        return _helperGCH.rpn(c2, 0, 1).concat(_helperGCH.dataF(c2, (x3 % 1 + 1) / 2));
      },
      rpnCoarseTuning: function(c2, m3) {
        return _helperGCH.rpn(c2, 0, 2).concat([_helperCH.dataMSB(c2, m3)]);
      },
      rpnCoarseTuningF: function(c2, x3) {
        return _helperGCH.rpn(c2, 0, 2).concat([_helperCH.dataMSB(c2, 64 + (x3 - x3 % 1))]);
      },
      rpnTuning: function(c2, n2, m3, l2) {
        return _helperGCH.rpnCoarseTuning(c2, n2).concat(_helperGCH.rpnFineTuning(c2, m3, l2));
      },
      rpnTuningF: function(c2, x3) {
        return _helperGCH.rpnCoarseTuningF(c2, x3).concat(_helperGCH.rpnFineTuningF(c2, x3));
      },
      rpnTuningA: function(c2, a2) {
        return _helperGCH.rpnTuningF(c2, MIDI.shift(a2));
      },
      rpnSelectTuningProgram: function(c2, n2) {
        return _helperGCH.rpn(c2, 0, 3).concat([_helperCH.dataMSB(c2, n2)]);
      },
      rpnSelectTuningBank: function(c2, n2) {
        return _helperGCH.rpn(c2, 0, 4).concat([_helperCH.dataMSB(c2, n2)]);
      },
      rpnSelectTuning: function(c2, n2, k3) {
        return typeof k3 == "undefined" ? _helperGCH.rpnSelectTuningProgram(c2, n2) : _helperGCH.rpnSelectTuningBank(c2, n2).concat(_helperGCH.rpnSelectTuningProgram(c2, k3));
      },
      rpnModulationDepthRange: function(c2, m3, l2) {
        return _helperGCH.rpn(c2, 0, 5).concat(_helperGCH.data(c2, m3, l2));
      },
      rpnModulationDepthRangeF: function(c2, x3) {
        return _helperGCH.rpnModulationDepthRange(c2, _7b(x3 - x3 % 1), Math.floor(x3 % 1 * 128));
      },
      rpnNull: function(c2) {
        return _helperGCH.rpn(c2, 127, 127);
      },
      mode1: function(c2) {
        return [_helperCH.omni(c2, true), _helperCH.poly(c2)];
      },
      mode2: function(c2) {
        return [_helperCH.omni(c2, true), _helperCH.mono(c2)];
      },
      mode3: function(c2) {
        return [_helperCH.omni(c2, false), _helperCH.poly(c2)];
      },
      mode4: function(c2) {
        return [_helperCH.omni(c2, false), _helperCH.mono(c2)];
      }
    };
    _helperGCH.rpnTranspose = _helperGCH.rpnCoarseTuningF;
    var _helperSXX = {
      // compound messages no channel
      sxMasterTuning: function(n2, m3, l2) {
        return [_helperSX.sxMasterCoarseTuning.call(this, n2), _helperSX.sxMasterFineTuning.call(this, m3, l2)];
      },
      sxMasterTuningF: function(x3) {
        return [_helperSX.sxMasterCoarseTuningF.call(this, x3), _helperSX.sxMasterFineTuningF.call(this, x3)];
      },
      gsMasterTuningF: function(x3) {
        return [_helperSX.gsMasterCoarseTuningF.call(this, x3), _helperSX.gsMasterFineTuningF.call(this, x3)];
      },
      xgMasterTuningF: function(x3) {
        return [_helperSX.xgMasterCoarseTuningF.call(this, x3), _helperSX.xgMasterFineTuningF.call(this, x3)];
      },
      sxMasterTuningA: function(a2) {
        return _helperSXX.sxMasterTuningF.call(this, MIDI.shift(a2));
      },
      gsMasterTuningA: function(a2) {
        return _helperSXX.gsMasterTuningF.call(this, MIDI.shift(a2));
      },
      xgMasterTuningA: function(a2) {
        return _helperSXX.xgMasterTuningF.call(this, MIDI.shift(a2));
      },
      gsScaleTuning: function(c2, a2) {
        var out = [];
        if (a2.length != 12) throw RangeError("Wrong input size: " + a2.length);
        for (var i3 = 0; i3 < 12; i3++) out.push(_helperSX.gsOctaveTuning.call(this, c2, i3, a2[i3]));
        return out;
      },
      gsScaleTuningF: function(c2, a2) {
        var out = [];
        if (a2.length != 12) throw RangeError("Wrong input size: " + a2.length);
        for (var i3 = 0; i3 < 12; i3++) out.push(_helperSX.gsOctaveTuningF.call(this, c2, i3, a2[i3]));
        return out;
      },
      xgScaleTuning: function(c2, a2) {
        var out = [];
        if (a2.length != 12) throw RangeError("Wrong input size: " + a2.length);
        for (var i3 = 0; i3 < 12; i3++) out.push(_helperSX.xgOctaveTuning.call(this, c2, i3, a2[i3]));
        return out;
      },
      xgScaleTuningF: function(c2, a2) {
        var out = [];
        if (a2.length != 12) throw RangeError("Wrong input size: " + a2.length);
        for (var i3 = 0; i3 < 12; i3++) out.push(_helperSX.xgOctaveTuningF.call(this, c2, i3, a2[i3]));
        return out;
      }
    };
    function _smf(ff, dd) {
      var midi = new MIDI();
      midi.ff = _8b(ff);
      midi.dd = typeof dd == "undefined" ? "" : _8bs(dd);
      return midi;
    }
    var _helperSMF = {
      // Standard MIDI File events
      smf: function(arg) {
        if (arg instanceof MIDI) return new MIDI(arg);
        var arr = arg instanceof Array ? arg : arguments;
        var ff = _8b(arr[0]);
        var dd = "";
        if (arr.length == 2) dd = _2s(arr[1]);
        else if (arr.length > 2) dd = _2s(Array.prototype.slice.call(arr, 1));
        return _smf(ff, dd);
      },
      smfSeqNumber: function(dd) {
        if (dd == parseInt(dd)) {
          if (dd < 0 || dd > 65535) throw RangeError("Sequence number out of range: " + dd);
          dd = String.fromCharCode(dd >> 8) + String.fromCharCode(dd & 255);
        } else {
          dd = "" + dd;
          if (dd.length == 0) dd = "\0\0";
          else if (dd.length == 1) dd = "\0" + dd;
          else if (dd.length > 2) throw RangeError("Sequence number out of range" + _smftxt(dd));
        }
        return _smf(0, dd);
      },
      smfText: function(dd) {
        return _smf(1, JZZ2.lib.toUTF8(dd));
      },
      smfCopyright: function(dd) {
        return _smf(2, JZZ2.lib.toUTF8(dd));
      },
      smfSeqName: function(dd) {
        return _smf(3, JZZ2.lib.toUTF8(dd));
      },
      smfInstrName: function(dd) {
        return _smf(4, JZZ2.lib.toUTF8(dd));
      },
      smfLyric: function(dd) {
        return _smf(5, JZZ2.lib.toUTF8(dd));
      },
      smfMarker: function(dd) {
        return _smf(6, JZZ2.lib.toUTF8(dd));
      },
      smfCuePoint: function(dd) {
        return _smf(7, JZZ2.lib.toUTF8(dd));
      },
      smfProgName: function(dd) {
        return _smf(8, JZZ2.lib.toUTF8(dd));
      },
      smfDevName: function(dd) {
        return _smf(9, JZZ2.lib.toUTF8(dd));
      },
      smfChannelPrefix: function(dd) {
        if (dd == parseInt(dd)) {
          _validateChannel(dd);
          dd = String.fromCharCode(dd);
        } else {
          dd = "" + dd;
          if (dd.length == 0) dd = "\0";
          else if (dd.length > 1 || dd.charCodeAt(0) > 15) throw RangeError("Channel number out of range" + _smftxt(dd));
        }
        return _smf(32, dd);
      },
      smfMidiPort: function(dd) {
        if (dd == parseInt(dd)) {
          if (dd < 0 || dd > 127) throw RangeError("Port number out of range: " + dd);
          dd = String.fromCharCode(dd);
        } else {
          dd = "" + dd;
          if (dd.length == 0) dd = "\0";
          else if (dd.length > 1 || dd.charCodeAt(0) > 127) throw RangeError("Port number out of range" + _smftxt(dd));
        }
        return _smf(33, dd);
      },
      smfEndOfTrack: function(dd) {
        if (_2s(dd) != "") throw RangeError("Unexpected data" + _smftxt(_2s(dd)));
        return _smf(47);
      },
      smfTempo: function(dd) {
        if (("" + dd).length == 3) return _smf(81, dd);
        if (dd == parseInt(dd) && dd > 0 && dd <= 16777215) {
          return _smf(81, String.fromCharCode(dd >> 16) + String.fromCharCode(dd >> 8 & 255) + String.fromCharCode(dd & 255));
        }
        throw RangeError("Out of range" + _smftxt(_2s(dd)));
      },
      smfBPM: function(bpm) {
        return _helperSMF.smfTempo(Math.round(6e7 / bpm));
      },
      smfSMPTE: function(dd) {
        if (dd instanceof SMPTE) return _smf(84, String.fromCharCode(dd.hour) + String.fromCharCode(dd.minute) + String.fromCharCode(dd.second) + String.fromCharCode(dd.frame) + String.fromCharCode(dd.quarter % 4 * 25));
        var s2 = "" + dd;
        if (s2.length == 5) {
          return _smf(84, dd);
        }
        var arr = dd instanceof Array ? dd : Array.prototype.slice.call(arguments);
        arr.splice(0, 0, 30);
        return _helperSMF.smfSMPTE(new SMPTE(arr));
      },
      smfTimeSignature: function(a2, b2, c2, d2) {
        var nn, dd, cc, bb;
        var m3 = ("" + a2).match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
        if (m3) {
          nn = parseInt(m3[1]);
          dd = parseInt(m3[2]);
          if (nn > 0 && nn < 256 && dd > 0 && !(dd & dd - 1)) {
            cc = dd;
            dd = 0;
            for (cc >>= 1; cc; cc >>= 1) dd++;
            cc = b2 == parseInt(b2) ? b2 : 24;
            bb = c2 == parseInt(c2) ? c2 : 8;
            return _smf(88, String.fromCharCode(nn) + String.fromCharCode(dd) + String.fromCharCode(cc) + String.fromCharCode(bb));
          } else if (("" + a2).length == 4) return _smf(88, a2);
        } else if (a2 == parseInt(a2) && b2 == parseInt(b2)) {
          if (a2 > 0 && a2 < 256 && b2 > 0 && !(b2 & b2 - 1)) {
            nn = a2;
            dd = 0;
            cc = b2;
            for (cc >>= 1; cc; cc >>= 1) dd++;
            cc = c2 == parseInt(c2) ? c2 : 24;
            bb = d2 == parseInt(d2) ? d2 : 8;
            return _smf(88, String.fromCharCode(nn) + String.fromCharCode(dd) + String.fromCharCode(cc) + String.fromCharCode(bb));
          } else if (("" + a2).length == 4) return _smf(88, a2);
          a2 = a2 + "/" + b2;
        } else if (("" + a2).length == 4) return _smf(88, a2);
        throw RangeError("Wrong time signature" + _smftxt(_2s("" + a2)));
      },
      smfKeySignature: function(dd) {
        dd = "" + dd;
        var m3 = dd.match(/^\s*([A-H][b#]?)\s*(|maj|major|dur|m|min|minor|moll)\s*$/i);
        if (m3) {
          var sf = {
            CB: 0,
            GB: 1,
            DB: 2,
            AB: 3,
            EB: 4,
            BB: 5,
            F: 6,
            C: 7,
            G: 8,
            D: 9,
            A: 10,
            E: 11,
            B: 12,
            H: 12,
            "F#": 13,
            "C#": 14,
            "G#": 15,
            "D#": 16,
            "A#": 17
          }[m3[1].toUpperCase()];
          var mi = { "": 0, MAJ: 0, MAJOR: 0, DUR: 0, M: 1, MIN: 1, MINOR: 1, MOLL: 1 }[m3[2].toUpperCase()];
          if (typeof sf != "undefined" && typeof mi != "undefined") {
            if (mi) sf -= 3;
            sf -= 7;
            if (sf >= -7 && sf < 0) dd = String.fromCharCode(256 + sf) + String.fromCharCode(mi);
            else if (sf >= 0 && sf <= 7) dd = String.fromCharCode(sf) + String.fromCharCode(mi);
          }
        }
        if (dd.length == 2 && dd.charCodeAt(1) <= 1 && (dd.charCodeAt(0) <= 7 || dd.charCodeAt(0) <= 255 && dd.charCodeAt(0) >= 249)) return _smf(89, dd);
        throw RangeError("Incorrect key signature" + _smftxt(dd));
      },
      smfSequencer: function(dd) {
        return _smf(127, _2s(dd));
      }
    };
    var _helpers = {};
    function _copyHelperNC(name, func) {
      MIDI[name] = function() {
        return new MIDI(func.apply(this, arguments));
      };
      _helpers[name] = function() {
        return this.send(func.apply(this, arguments));
      };
    }
    function _copyHelperSMF(name, func) {
      MIDI[name] = function() {
        return func.apply(this, arguments);
      };
      _helpers[name] = function() {
        return this.send(func.apply(this, arguments));
      };
    }
    function _copyHelperGNC(name, func) {
      MIDI[name] = function() {
        var i3;
        var g2 = [];
        var a2 = func.apply(this, arguments);
        for (i3 = 0; i3 < a2.length; i3++) g2.push(new MIDI(a2[i3]));
        return g2;
      };
      _helpers[name] = function() {
        var a2 = func.apply(this, arguments);
        var g2 = this;
        for (var i3 = 0; i3 < a2.length; i3++) g2 = g2.send(a2[i3]);
        return g2;
      };
    }
    function _copyHelperMPE(name, func) {
      MIDI[name] = function() {
        return new MIDI(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
      };
      _helpers[name] = function() {
        if (typeof this._master != "undefined") {
          var msg = new MIDI(func.apply(this, [this._master].concat(Array.prototype.slice.call(arguments))));
          msg._mpe = msg[1];
          return this.send(msg);
        }
        return this.send(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
      };
    }
    function _copyHelperCH(name, func) {
      MIDI[name] = function() {
        return new MIDI(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
      };
      _helpers[name] = function() {
        if (typeof this._master != "undefined") {
          var chan;
          var args = Array.prototype.slice.call(arguments);
          if (args.length < func.length) args = [this._master].concat(args);
          else {
            chan = _7bn(args[0]);
            args[0] = this._master;
          }
          var msg = new MIDI(func.apply(this, args));
          msg._mpe = chan;
          return this.send(msg);
        }
        return this.send(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
      };
    }
    function _copyHelperGCH(name, func) {
      MIDI[name] = function() {
        var i3;
        var g2 = [];
        var a2 = func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments)));
        for (i3 = 0; i3 < a2.length; i3++) g2.push(new MIDI(a2[i3]));
        return g2;
      };
      _helpers[name] = function() {
        var i3;
        var a2;
        var g2;
        if (typeof this._master != "undefined") {
          var chan;
          var args = Array.prototype.slice.call(arguments);
          if (args.length < func.length) args = [this._master].concat(args);
          else {
            chan = _7bn(args[0]);
            args[0] = this._master;
          }
          a2 = func.apply(this, args);
          g2 = this;
          for (i3 = 0; i3 < a2.length; i3++) {
            var msg = MIDI(a2[i3]);
            msg._mpe = chan;
            g2 = g2.send(msg);
          }
          return g2;
        }
        a2 = func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments)));
        g2 = this;
        for (i3 = 0; i3 < a2.length; i3++) g2 = g2.send(a2[i3]);
        return g2;
      };
    }
    _for(_helperNC, function(n2) {
      _copyHelperNC(n2, _helperNC[n2]);
    });
    _for(_helperSX, function(n2) {
      _copyHelperNC(n2, _helperSX[n2]);
    });
    _for(_helperSMF, function(n2) {
      _copyHelperSMF(n2, _helperSMF[n2]);
    });
    _for(_helperSXX, function(n2) {
      _copyHelperGNC(n2, _helperSXX[n2]);
    });
    _for(_helperMPE, function(n2) {
      _copyHelperMPE(n2, _helperMPE[n2]);
    });
    _for(_helperCH, function(n2) {
      _copyHelperCH(n2, _helperCH[n2]);
    });
    _for(_helperGCH, function(n2) {
      _copyHelperGCH(n2, _helperGCH[n2]);
    });
    function _copyMidiHelpers(M2) {
      _for(_helpers, function(n2) {
        M2.prototype[n2] = _helpers[n2];
      });
    }
    _copyMidiHelpers(_M);
    var _channelMap = { a: 10, b: 11, c: 12, d: 13, e: 14, f: 15, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };
    for (k2 = 0; k2 < 16; k2++) _channelMap[k2] = k2;
    MIDI.prototype.getChannel = function() {
      if (this.ff == 32 && this.dd.length == 1 && this.dd.charCodeAt(0) < 16) return this.dd.charCodeAt(0);
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 128 || c2 > 239) return;
      return c2 & 15;
    };
    MIDI.prototype.setChannel = function(x3) {
      x3 = _channelMap[x3];
      if (typeof x3 == "undefined") return this;
      if (this.ff == 32) this.dd = String.fromCharCode(x3);
      else {
        var c2 = this[0];
        if (typeof c2 != "undefined" && c2 >= 128 && c2 <= 239) this[0] = c2 & 240 | x3;
      }
      return this;
    };
    MIDI.prototype.getNote = function() {
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 128 || c2 > 175) return;
      return this[1];
    };
    MIDI.prototype.setNote = function(x3) {
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 128 || c2 > 175) return this;
      x3 = MIDI.noteValue(x3);
      if (typeof x3 != "undefined") this[1] = x3;
      return this;
    };
    MIDI.prototype.getVelocity = function() {
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 128 || c2 > 159) return;
      return this[2];
    };
    MIDI.prototype.setVelocity = function(x3) {
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 128 || c2 > 159) return this;
      x3 = parseInt(x3);
      if (x3 >= 0 && x3 < 128) this[2] = x3;
      return this;
    };
    MIDI.prototype.getSysExId = function() {
      if (this[0] == 240) return this[2];
    };
    MIDI.prototype.setSysExId = function(x3) {
      if (this[0] == 240 && this.length > 2) {
        x3 = parseInt(x3);
        if (x3 >= 0 && x3 < 128) this[2] = x3;
      }
      return this;
    };
    MIDI.prototype.getData = function() {
      if (typeof this.dd != "undefined") return this.dd.toString();
    };
    MIDI.prototype.setData = function(dd) {
      this.dd = _2s(dd);
      return this;
    };
    function _is_yamaha_smf(ff, dd) {
      return ff == 127 && typeof dd != "undefined" && dd.charCodeAt(0) == 67 && dd.charCodeAt(1) == 123;
    }
    function _is_yamaha_chord(ff, dd) {
      return _is_yamaha_smf(ff, dd) && dd.charCodeAt(2) == 1;
    }
    function _yamaha_chord(a2, b2) {
      if (a2 >= 0 && a2 <= 127 && b2 >= 0 && b2 <= 127) {
        var c2 = a2 & 15;
        var d2 = a2 >> 4;
        if (c2 > 0 && c2 < 8 && d2 < 7) c2 = ["C", "D", "E", "F", "G", "A", "B"][c2 - 1] + ["bbb", "bb", "b", "", "#", "##", "###"][d2];
        else return "-";
        if (b2 > 34) return c2 + "?";
        else return c2 + [
          "",
          "6",
          "Maj7",
          "Maj7(#11)",
          "(9)",
          "Maj7(9)",
          "6(9)",
          "aug",
          "m",
          "m6",
          "m7",
          "m7b5",
          "m(9)",
          "m7(9)",
          "m7(11)",
          "m+7",
          "m+7(9)",
          "dim",
          "dim7",
          "7",
          "7sus4",
          "7b5",
          "7(9)",
          "7(#11)",
          "7(13)",
          "7(b9)",
          "7(b13)",
          "7(#9)",
          "Maj7aug",
          "7aug",
          "1+8",
          "1+5",
          "sus4",
          "1+2+5",
          "cc"
        ][b2];
      }
      return "-";
    }
    MIDI.prototype.getText = function() {
      if (typeof this.dd != "undefined") {
        if (_is_yamaha_chord(this.ff, this.dd)) return _yamaha_chord(this.dd.charCodeAt(3), this.dd.charCodeAt(4));
        else return JZZ2.lib.fromUTF8(this.dd);
      }
      if (this.isMidiSoft()) {
        var s2 = [];
        for (var i3 = 6; i3 < this.length - 1; i3++) s2.push(String.fromCharCode(this[i3]));
        return s2.join("");
      }
    };
    MIDI.prototype.setText = function(dd) {
      this.dd = JZZ2.lib.toUTF8(dd);
      return this;
    };
    MIDI.prototype.getTempo = function() {
      if (this.ff == 81 && typeof this.dd != "undefined") {
        return this.dd.charCodeAt(0) * 65536 + this.dd.charCodeAt(1) * 256 + this.dd.charCodeAt(2);
      }
    };
    MIDI.prototype.getBPM = function() {
      var ms = this.getTempo();
      if (ms) return 6e7 / ms;
    };
    MIDI.prototype.getTimeSignature = function() {
      if (this.ff == 88 && typeof this.dd != "undefined") {
        return [this.dd.charCodeAt(0), 1 << this.dd.charCodeAt(1)];
      }
    };
    MIDI.prototype.getTimeSignature4 = function() {
      if (this.ff == 88 && typeof this.dd != "undefined") {
        var a2 = [this.dd.charCodeAt(0), 1 << this.dd.charCodeAt(1)];
        if (this.dd.length == 4) a2.push(this.dd.charCodeAt(2), this.dd.charCodeAt(3));
        return a2;
      }
    };
    MIDI.prototype.getKeySignature = function() {
      if (this.ff == 89 && typeof this.dd != "undefined") {
        var sf = this.dd.charCodeAt(0);
        var mi = this.dd.charCodeAt(1);
        if (sf & 128) sf = sf - 256;
        if (sf >= -7 && sf <= 7 && mi >= 0 && mi <= 1) {
          return [
            sf,
            ["Cb", "Gb", "Db", "Ab", "Eb", "Bb", "F", "C", "G", "D", "A", "E", "B", "F#", "C#", "G#", "D#", "A#"][mi ? sf + 10 : sf + 7],
            !!mi
          ];
        }
      }
    };
    MIDI.prototype.isNoteOn = function() {
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 144 || c2 > 159) return false;
      return this[2] > 0 ? true : false;
    };
    MIDI.prototype.isNoteOff = function() {
      var c2 = this[0];
      if (typeof c2 == "undefined" || c2 < 128 || c2 > 159) return false;
      if (c2 < 144) return true;
      return this[2] == 0 ? true : false;
    };
    MIDI.prototype.isSysEx = function() {
      return this[0] == 240;
    };
    MIDI.prototype.isFullSysEx = function() {
      return this[0] == 240 && this[this.length - 1] == 247;
    };
    MIDI.prototype.isMidiSoft = function() {
      return this.isFullSysEx() && this[1] == 0 && this[2] == 32 && this[3] == 36 && this[4] == 0;
    };
    MIDI.prototype.isSMF = function() {
      return this.ff >= 0 && this.ff <= 127;
    };
    MIDI.prototype.isEOT = function() {
      return this.ff == 47;
    };
    MIDI.prototype.isText = function() {
      return this.ff == 1;
    };
    MIDI.prototype.isCopyright = function() {
      return this.ff == 2;
    };
    MIDI.prototype.isSeqName = function() {
      return this.ff == 3;
    };
    MIDI.prototype.isInstrName = function() {
      return this.ff == 4;
    };
    MIDI.prototype.isLyric = function() {
      return this.ff == 5;
    };
    MIDI.prototype.isMarker = function() {
      return this.ff == 6;
    };
    MIDI.prototype.isCuePoint = function() {
      return this.ff == 7;
    };
    MIDI.prototype.isProgName = function() {
      return this.ff == 8;
    };
    MIDI.prototype.isDevName = function() {
      return this.ff == 9;
    };
    MIDI.prototype.isTempo = function() {
      return this.ff == 81;
    };
    MIDI.prototype.isTimeSignature = function() {
      return this.ff == 88;
    };
    MIDI.prototype.isKeySignature = function() {
      return this.ff == 89;
    };
    MIDI.prototype.isGmReset = function() {
      return this.match([240, 126, [0, 0], 9, [0, 0], 247]);
    };
    MIDI.prototype.isGsReset = function() {
      return this.match([240, 65, [0, 0], 66, 18, 64, 0, 127, 0, 65, 247]);
    };
    MIDI.prototype.isXgReset = function() {
      return this.match([240, 67, [16, 240], 76, 0, 0, 126, 0, 247]);
    };
    MIDI.prototype.match = function(a2) {
      var i3, m3;
      for (i3 = 0; i3 < a2.length; i3++) {
        m3 = a2[i3][1];
        if (typeof m3 == "undefined") {
          if (this[i3] != a2[i3]) return false;
        } else {
          if ((this[i3] & m3) != (a2[i3][0] & m3)) return false;
        }
      }
      return true;
    };
    function _s2a(x3) {
      var a2 = [];
      for (var i3 = 0; i3 < x3.length; i3++) {
        a2[i3] = x3.charCodeAt(i3);
      }
      return a2;
    }
    function _a2s(x3) {
      var a2 = "";
      for (var i3 = 0; i3 < x3.length; i3++) {
        a2 += String.fromCharCode(x3[i3]);
      }
      return a2;
    }
    function _2s(x3) {
      return x3 instanceof Array ? _a2s(x3) : typeof x3 == "undefined" ? "" : "" + x3;
    }
    function _s2n(x3) {
      var n2 = 0;
      for (var i3 = 0; i3 < x3.length; i3++) n2 = (n2 << 8) + x3.charCodeAt(i3);
      return n2;
    }
    function __hex(x3) {
      return (x3 < 16 ? "0" : "") + x3.toString(16);
    }
    function _hex(x3) {
      var a2 = [];
      for (var i3 = 0; i3 < x3.length; i3++) a2.push(__hex(x3[i3]));
      return a2.join(" ");
    }
    function _hexx(x3) {
      var a2 = [];
      for (var i3 = 0; i3 < x3.length; i3++) {
        if (i3 && i3 % 4 == 0) a2.push(" ");
        a2.push(__hex(x3[i3]));
      }
      return a2.join("");
    }
    function _toLine(s2) {
      var out = "";
      for (var i3 = 0; i3 < s2.length; i3++) {
        if (s2[i3] == "\n") out += "\\n";
        else if (s2[i3] == "\r") out += "\\r";
        else if (s2[i3] == "	") out += "\\t";
        else if (s2.charCodeAt(i3) < 32) out += "\\x" + __hex(s2.charCodeAt(i3));
        else out += s2[i3];
      }
      return out;
    }
    function _smfhex(dd) {
      return dd.length ? ": " + _hex(_s2a(dd)) : "";
    }
    function _smftxt(dd) {
      return dd.length ? ": " + _toLine(JZZ2.lib.fromUTF8(dd)) : "";
    }
    MIDI.prototype.label = function(s2) {
      this.lbl = this.lbl ? this.lbl + ", " + s2 : s2;
      return this;
    };
    MIDI.prototype.toString = function() {
      return this.lbl ? this._str() + " (" + this.lbl + ")" : this._str();
    };
    MIDI.prototype._str = function() {
      var s2, t2;
      if (!this.length) {
        if (typeof this.ff == "undefined") return "empty";
        s2 = "ff" + __hex(this.ff);
      } else s2 = _hex(this);
      t2 = this._string();
      return t2 ? s2 + " -- " + t2 : s2;
    };
    MIDI.prototype._string = function() {
      var s2 = "";
      var ss;
      if (!this.length) {
        if (this.ff == 0) s2 += "Sequence Number: " + _s2n(this.dd);
        else if (this.ff > 0 && this.ff < 10) s2 += ["", "Text", "Copyright", "Sequence Name", "Instrument Name", "Lyric", "Marker", "Cue Point", "Program Name", "Device Name"][this.ff] + _smftxt(this.dd);
        else if (this.ff == 32) s2 += "Channel Prefix" + _smfhex(this.dd);
        else if (this.ff == 33) s2 += "MIDI Port" + _smfhex(this.dd);
        else if (this.ff == 47) s2 += "End of Track" + _smfhex(this.dd);
        else if (this.ff == 81) {
          var bpm = Math.round(this.getBPM() * 100) / 100;
          s2 += "Tempo: " + bpm + " bpm";
        } else if (this.ff == 84) s2 += "SMPTE Offset: " + _smptetxt(_s2a(this.dd));
        else if (this.ff == 88) {
          var d2 = 1 << this.dd.charCodeAt(1);
          s2 += "Time Signature: " + this.dd.charCodeAt(0) + "/" + d2;
          s2 += " " + this.dd.charCodeAt(2) + " " + this.dd.charCodeAt(3);
        } else if (this.ff == 89) {
          s2 += "Key Signature: ";
          var ks = this.getKeySignature();
          if (ks) {
            s2 += ks[1];
            if (ks[2]) s2 += " min";
          } else s2 += "invalid";
        } else if (this.ff == 127) {
          if (this.dd.charCodeAt(0) == 67) {
            if (this.dd.charCodeAt(1) == 123) {
              s2 += "[XF:" + __hex(this.dd.charCodeAt(2)) + "]";
              ss = {
                0: "Version",
                1: "Chord",
                2: "Rehearsal Mark",
                3: "Phrase Mark",
                4: "Max Phrase Mark",
                5: "Fingering Number",
                12: "Guide Track Flag",
                16: "Guitar Info",
                18: "Chord Voicing",
                127: "XG Song Data Number"
              }[this.dd.charCodeAt(2)];
              s2 += ss ? " " + ss : "";
              s2 += ": ";
              if (this.dd.charCodeAt(2) == 0) {
                return s2 + this.dd.substring(3, 7) + " " + _hex(_s2a(this.dd.substring(7)));
              }
              if (this.dd.charCodeAt(2) == 1) {
                return s2 + this.getText();
              }
              return s2 + _hex(_s2a(this.dd.substring(3)));
            }
          }
          s2 += "Sequencer Specific" + _smfhex(this.dd);
        } else s2 += "SMF" + _smfhex(this.dd);
        return s2;
      }
      ss = {
        241: "MIDI Time Code",
        242: "Song Position",
        243: "Song Select",
        244: "Undefined",
        245: "Undefined",
        246: "Tune request",
        248: "Timing clock",
        249: "Undefined",
        250: "Start",
        251: "Continue",
        252: "Stop",
        253: "Undefined",
        254: "Active Sensing",
        255: "Reset"
      }[this[0]];
      if (ss) return ss;
      if (this.isMidiSoft()) {
        ss = _toLine(this.getText());
        if (ss) ss = " " + ss;
        return "[K:" + __hex(this[5]) + "]" + ss;
      }
      var c2 = this[0] >> 4;
      ss = { 8: "Note Off", 10: "Aftertouch", 12: "Program Change", 13: "Channel Aftertouch", 14: "Pitch Wheel" }[c2];
      if (ss) return ss;
      if (c2 == 9) return this[2] ? "Note On" : "Note Off";
      if (c2 != 11) return s2;
      ss = {
        0: "Bank Select MSB",
        1: "Modulation Wheel MSB",
        2: "Breath Controller MSB",
        4: "Foot Controller MSB",
        5: "Portamento Time MSB",
        6: "Data Entry MSB",
        7: "Channel Volume MSB",
        8: "Balance MSB",
        10: "Pan MSB",
        11: "Expression Controller MSB",
        12: "Effect Control 1 MSB",
        13: "Effect Control 2 MSB",
        16: "General Purpose Controller 1 MSB",
        17: "General Purpose Controller 2 MSB",
        18: "General Purpose Controller 3 MSB",
        19: "General Purpose Controller 4 MSB",
        31: "Karaoke",
        32: "Bank Select LSB",
        33: "Modulation Wheel LSB",
        34: "Breath Controller LSB",
        36: "Foot Controller LSB",
        37: "Portamento Time LSB",
        38: "Data Entry LSB",
        39: "Channel Volume LSB",
        40: "Balance LSB",
        42: "Pan LSB",
        43: "Expression Controller LSB",
        44: "Effect control 1 LSB",
        45: "Effect control 2 LSB",
        48: "General Purpose Controller 1 LSB",
        49: "General Purpose Controller 2 LSB",
        50: "General Purpose Controller 3 LSB",
        51: "General Purpose Controller 4 LSB",
        64: "Damper Pedal",
        65: "Portamento",
        66: "Sostenuto",
        67: "Soft Pedal",
        68: "Legato",
        69: "Hold 2",
        70: "Sound Variation",
        71: "Filter Resonance",
        72: "Release Time",
        73: "Attack Time",
        74: "Brightness",
        75: "Decay Time",
        76: "Vibrato Rate",
        77: "Vibrato Depth",
        78: "Vibrato Delay",
        79: "Sound Controller 10",
        80: "General Purpose Controller 5",
        81: "General Purpose Controller 6",
        82: "General Purpose Controller 7",
        83: "General Purpose Controller 8",
        84: "Portamento Control",
        88: "High Resolution Velocity Prefix",
        91: "Effects 1 Depth",
        92: "Effects 2 Depth",
        93: "Effects 3 Depth",
        94: "Effects 4 Depth",
        95: "Effects 5 Depth",
        96: "Data Increment",
        97: "Data Decrement",
        98: "Non-Registered Parameter Number LSB",
        99: "Non-Registered Parameter Number MSB",
        100: "Registered Parameter Number LSB",
        101: "Registered Parameter Number MSB",
        120: "All Sound Off",
        121: "Reset All Controllers",
        122: "Local Control On/Off",
        123: "All Notes Off",
        124: "Omni Mode Off",
        125: "Omni Mode On",
        126: "Mono Mode On",
        127: "Poly Mode On"
      }[this[1]];
      if (this[1] >= 64 && this[1] <= 69) ss += this[2] < 64 ? " Off" : " On";
      if (!ss) ss = "Undefined";
      return ss;
    };
    MIDI.prototype._stamp = function(obj) {
      this._from.push(obj._orig ? obj._orig : obj);
      return this;
    };
    MIDI.prototype._unstamp = function(obj) {
      if (typeof obj == "undefined") this._from = [];
      else {
        if (obj._orig) obj = obj._orig;
        var i3 = this._from.indexOf(obj);
        if (i3 > -1) this._from.splice(i3, 1);
      }
      return this;
    };
    MIDI.prototype._stamped = function(obj) {
      if (obj._orig) obj = obj._orig;
      for (var i3 = 0; i3 < this._from.length; i3++) if (this._from[i3] == obj) return true;
      return false;
    };
    JZZ2.MIDI = MIDI;
    _J.prototype.MIDI = MIDI;
    function _clear_ctxt(gr) {
      if (typeof gr == "undefined") this._cc = {};
      else this._cc[gr] = {};
    }
    function _rpn_txt(msb, lsb) {
      var a2 = typeof msb == "undefined" ? "??" : __hex(msb);
      var b2 = typeof lsb == "undefined" ? "??" : __hex(lsb);
      var c2 = {
        "0000": "Pitch Bend Sensitivity",
        "0001": "Channel Fine Tuning",
        "0002": "Channel Coarse Tuning",
        "0003": "Select Tuning Program",
        "0004": "Select Tuning Bank",
        "0005": "Vibrato Depth Range",
        "7f7f": "NONE"
      }[a2 + "" + b2];
      return "RPN " + a2 + " " + b2 + (c2 ? ": " + c2 : "");
    }
    function _nrpn_txt(msb, lsb) {
      var a2 = typeof msb == "undefined" ? "??" : __hex(msb);
      var b2 = typeof lsb == "undefined" ? "??" : __hex(lsb);
      return "NRPN " + a2 + " " + b2;
    }
    function _m2_str(a2) {
      var i3;
      var s2 = "";
      for (i3 = 0; i3 < a2.length; i3++) {
        if (!a2[i3]) break;
        s2 += String.fromCharCode(a2[i3]);
      }
      return JZZ2.lib.fromUTF8(s2);
    }
    function _read_ctxt(msg) {
      var mmm, kk, tt2, st2, n2, a2, s2;
      var gr = "x";
      var ch = "x";
      if (msg.isMidi2) {
        tt2 = msg[0] >> 4;
        gr = (msg[0] & 15).toString(16);
        kk = gr;
        if (!this._cc[kk]) this._cc[kk] = {};
        if (tt2 == 2) {
          mmm = new MIDI(msg.slice(1));
        } else if (tt2 == 3) {
          st2 = msg[1] >> 4;
          n2 = msg[1] & 15;
          a2 = msg.slice(2, 2 + n2);
          if (st2 == 0) {
            mmm = new MIDI([240].concat(a2, [247]));
            this._cc[kk].sx = void 0;
          }
          if (st2 == 1) {
            this._cc[kk].sx = a2;
          }
          if (st2 == 2) {
            if (this._cc[kk].sx) this._cc[kk].sx = this._cc[kk].sx.concat(a2);
          }
          if (st2 == 3) {
            if (this._cc[kk].sx) {
              a2 = this._cc[kk].sx.concat(a2);
              mmm = new MIDI([240].concat(a2, [247]));
              this._cc[kk].sx = void 0;
            }
          }
        } else if (tt2 == 4) {
          st2 = msg[1] >> 4;
          ch = (msg[1] & 15).toString(16);
          kk = gr + ch;
          if (!this._cc[kk]) this._cc[kk] = {};
          if (st2 == 12) {
            if (msg[3] & 1) {
              this._cc[kk].bm = msg[6];
              this._cc[kk].bl = msg[7];
            }
            msg._bm = this._cc[kk].bm;
            msg._bl = this._cc[kk].bl;
            if (JZZ2.MIDI.programName) msg.label(JZZ2.MIDI.programName(msg[4], msg._bm, msg._bl));
          }
        } else if (tt2 == 13) {
          st2 = msg[1] >> 6;
          if (!(msg[1] & 48)) ch = (msg[1] & 15).toString(16);
          kk = gr + ch;
          if (!this._cc[kk]) this._cc[kk] = {};
          a2 = msg.slice(4);
          if (st2 == 0) {
            msg.label(_m2_str(a2));
            this._cc[kk].tx = void 0;
          }
          if (st2 == 1) {
            this._cc[kk].tx = a2;
          }
          if (st2 == 2) {
            if (this._cc[kk].tx) this._cc[kk].tx = this._cc[kk].tx.concat(a2);
          }
          if (st2 == 3) {
            if (this._cc[kk].tx) {
              a2 = this._cc[kk].tx.concat(a2);
              msg.label(_m2_str(a2));
              this._cc[kk].tx = void 0;
            }
          }
        }
      } else mmm = msg;
      if (!mmm || !mmm.length || mmm[0] < 128) return msg;
      if (mmm[0] == 255) {
        this._clear();
        return msg;
      }
      st2 = mmm[0] >> 4;
      ch = (mmm[0] & 15).toString(16);
      kk = st2 == 15 ? gr : gr + ch;
      if (!this._cc[kk]) this._cc[kk] = {};
      if (st2 == 12) {
        mmm._bm = this._cc[kk].bm;
        mmm._bl = this._cc[kk].bl;
        if (JZZ2.MIDI.programName) msg.label(JZZ2.MIDI.programName(mmm[1], mmm._bm, mmm._bl));
      } else if (st2 == 11) {
        switch (mmm[1]) {
          case 0:
            this._cc[kk].bm = mmm[2];
            break;
          case 32:
            this._cc[kk].bl = mmm[2];
            break;
          case 98:
            this._cc[kk].nl = mmm[2];
            this._cc[kk].rn = "n";
            break;
          case 99:
            this._cc[kk].nm = mmm[2];
            this._cc[kk].rn = "n";
            break;
          case 100:
            this._cc[kk].rl = mmm[2];
            this._cc[kk].rn = "r";
            break;
          case 101:
            this._cc[kk].rm = mmm[2];
            this._cc[kk].rn = "r";
            break;
          case 6:
          case 38:
          case 96:
          case 97:
            if (this._cc[kk].rn == "r") {
              mmm._rm = this._cc[kk].rm;
              mmm._rl = this._cc[kk].rl;
              msg.label(_rpn_txt(this._cc[kk].rm, this._cc[kk].rl));
            }
            if (this._cc[kk].rn == "n") {
              mmm._nm = this._cc[kk].rm;
              mmm._nl = this._cc[kk].nl;
              msg.label(_nrpn_txt(this._cc[kk].nm, this._cc[kk].nl));
            }
            break;
        }
      } else if (mmm.isFullSysEx()) {
        if (mmm[1] == 127) {
          if (mmm[3] == 4) {
            s2 = { 1: "Master Volume", 2: "Master Balance", 3: "Master Fine Tuning", 4: "Master Coarse Tuning" }[mmm[4]];
            if (s2) msg.label(s2);
          } else if (mmm[3] == 8) {
            s2 = { 2: "Note Tuning", 7: "Note Tuning, Bank", 8: "Scale Tuning, 1 byte format", 9: "Scale Tuning, 2 byte format" }[mmm[4]];
            if (s2) msg.label(s2);
          }
        } else if (mmm[1] == 126) {
          if (mmm[3] == 6) {
            if (mmm[4] == 1) msg.label("Device ID Request");
            else if (mmm[4] == 2) {
              msg.label("Device ID Response");
            }
          } else if (mmm[3] == 8) {
            s2 = {
              0: "Bulk Tuning Dump Request",
              1: "Bulk Tuning Dump",
              3: "Bulk Tuning Dump Request, Bank",
              4: "Bulk Tuning Dump, Bank",
              5: "Scale Tuning Dump, 1 byte format",
              6: "Scale Tuning Dump, 2 byte format",
              7: "Note Tuning, Bank",
              8: "Scale Tuning, 1 byte format",
              9: "Scale Tuning, 2 byte format"
            }[mmm[4]];
            if (s2) msg.label(s2);
          } else if (mmm[3] == 9) {
            if (mmm[4] == 1) {
              msg.label("GM1 System On");
              this._clear(gr);
              this._cc[gr].gm = "1";
            } else if (mmm[4] == 2) {
              msg.label("GM System Off");
              this._clear(gr);
              this._cc[gr].gm = "0";
            } else if (mmm[4] == 3) {
              msg.label("GM2 System On");
              this._clear(gr);
              this._cc[gr].gm = "2";
            }
          }
        } else if (mmm[1] == 67) {
          if ((mmm[2] & 240) == 16 && mmm[3] == 76) {
            if (mmm[4] == 0 && mmm[5] == 0 && mmm[6] == 126 && mmm[7] == 0) {
              msg.label("XG System On");
              this._clear(gr);
              this._cc[gr].gm = "Y";
            } else if (mmm[4] == 0 && mmm[5] == 0 && mmm[6] == 0) msg.label("XG Master Tuning");
            else if (mmm[4] == 0 && mmm[5] == 0 && mmm[6] == 4) msg.label("XG Master Volume");
            else if (mmm[4] == 0 && mmm[5] == 0 && mmm[6] == 6) msg.label("XG Master Transpose");
            else if (mmm[4] == 8 && mmm[5] < 16 && mmm[6] >= 65 && mmm[6] <= 76) msg.label("XG Scale Tuning");
            else msg.label("XG Parameter");
          }
        } else if (mmm[1] == 65) {
          if (mmm[3] == 66 && mmm[4] == 18) {
            if (mmm[5] == 64) {
              if (mmm[6] == 0) {
                if (mmm[7] == 127 && mmm[8] == 0 && mmm[9] == 65) {
                  msg.label("GS Reset");
                  this._clear(gr);
                  this._cc[gr].gm = "R";
                } else if (mmm[7] == 0) msg.label("GS Master Tuning");
                else if (mmm[7] == 4) msg.label("GS Master Volume");
                else if (mmm[7] == 5) msg.label("GS Master Transpose");
                else msg.label("GS Parameter");
              } else if ((mmm[6] & 240) == 16 && mmm[7] == 21) msg.label("GS Drum Part Change");
              else if ((mmm[6] & 240) == 16 && mmm[7] >= 64 && mmm[7] <= 75) msg.label("GS Scale Tuning");
              else msg.label("GS Parameter");
            }
            if (mmm[5] == 65) msg.label("GS Parameter");
          }
        }
      }
      return msg;
    }
    function Context() {
      var self2 = new _M();
      self2._clear = _clear_ctxt;
      self2._read = _read_ctxt;
      self2._receive = function(msg) {
        this._emit(this._read(msg));
      };
      self2.gm = function(g2) {
        if (typeof g2 == "undefined") g2 = "x";
        if (this._cc[g2]) return this._cc[g2].gm || 0;
        return 0;
      };
      self2._clear();
      self2._resume();
      return self2;
    }
    JZZ2.Context = Context;
    _J.prototype.Context = Context;
    function MPE() {
      var self2 = this instanceof MPE ? this : self2 = new MPE();
      self2.reset();
      if (arguments.length) MPE.prototype.setup.apply(self2, arguments);
      return self2;
    }
    MPE.validate = function(arg) {
      var a2 = arg instanceof Array ? arg : arguments;
      if (a2[0] != parseInt(a2[0]) || a2[0] < 0 || a2[0] > 14) throw RangeError("Bad master channel value: " + a2[0]);
      if (a2[1] != parseInt(a2[1]) || a2[1] < 0 || a2[0] + a2[1] > 15) throw RangeError("Bad zone size value: " + a2[1]);
    };
    MPE.prototype.reset = function() {
      for (var n2 = 0; n2 < 16; n2++) this[n2] = { band: 0, master: n2 };
    };
    MPE.prototype.setup = function(m3, n2) {
      MPE.validate(m3, n2);
      var k3;
      var last = m3 + n2;
      if (this[m3].master == m3 && this[m3].band == n2) return;
      if (!n2 && !this[m3].band) return;
      if (this[m3].band) {
        k3 = m3 + this[m3].band;
        if (last < k3) last = k3;
      } else if (this[m3].master == m3 - 1) {
        k3 = m3 - 1;
        k3 = k3 + this[k3].band;
        if (last < k3) last = k3;
        this[m3 - 1] = { band: 0, master: m3 - 1 };
      } else if (this[m3].master != m3) {
        k3 = this[m3].master;
        k3 = k3 + this[k3].band;
        if (last < k3) last = k3;
        this[this[m3].master].band = m3 - this[m3].master - 1;
      }
      this[m3].master = m3;
      this[m3].band = n2;
      for (k3 = m3 + 1; k3 <= m3 + n2; k3++) {
        if (this[k3].band && last < k3 + this[k3].band) last = k3 + this[k3].band;
        this[k3] = { band: 0, master: m3 };
      }
      for (; k3 <= last; k3++) this[k3] = { band: 0, master: k3 };
    };
    MPE.prototype.filter = function(msg) {
      var c2 = msg.getChannel();
      if (!this[c2] || !this[this[c2].master].band) return msg;
      var m3 = this[c2].master;
      var n2 = this[m3].band;
      var i3, j3, k3;
      if (typeof msg._mpe != "undefined") {
        k3 = 256;
        for (i3 = m3 + 1; i3 <= m3 + n2; i3++) {
          if (!this[i3].notes) {
            if (k3 > 0) {
              c2 = i3;
              k3 = 0;
            }
          } else {
            if (k3 > this[i3].notes.length) {
              c2 = i3;
              k3 = this[i3].notes.length;
            }
            for (j3 = 0; j3 < this[i3].notes.length; j3++) {
              if (this[i3].notes[j3] == msg._mpe) {
                c2 = i3;
                k3 = -1;
                break;
              }
            }
          }
        }
        msg.setChannel(c2);
        msg._mpe = void 0;
      }
      if (c2 == m3) return msg;
      if (msg.isNoteOn()) {
        if (!this[c2].notes) this[c2].notes = [];
        _push(this[c2].notes, msg.getNote());
      } else if (msg.isNoteOff()) {
        if (this[c2].notes) _pop(this[c2].notes, msg.getNote());
      }
      return msg;
    };
    JZZ2.MPE = MPE;
    function UMP(arg) {
      var self2 = this instanceof UMP ? this : self2 = new UMP();
      var i3;
      if (arg instanceof UMP) {
        self2._from = arg._from.slice();
        _for(arg, function(i4) {
          if (i4 != "_from") self2[i4] = arg[i4];
        });
        return self2;
      } else self2._from = [];
      if (typeof arg == "undefined") arg = [0, 0, 0, 0];
      var arr = arg instanceof Array ? arg : arguments;
      self2.length = 0;
      for (i3 = 0; i3 < arr.length; i3++) {
        n = arr[i3];
        if (n != parseInt(n) || n < 0 || n > 255) _throw(arr[i3]);
        self2.push(n);
      }
      if (self2.length != [4, 4, 4, 8, 8, 16, 4, 4, 8, 8, 8, 12, 12, 16, 16, 16][self2[0] >> 4]) throw RangeError("Wrong UMP size");
      return self2;
    }
    UMP.prototype = [];
    UMP.prototype.constructor = UMP;
    UMP.prototype.isMidi = function() {
      return 2;
    };
    UMP.prototype.isMidi2 = true;
    UMP.prototype.dump = function() {
      var i3;
      var s2 = "";
      for (i3 = 0; i3 < this.length; i3++) s2 += String.fromCharCode(this[i3]);
      return s2;
    };
    function _UMP() {
    }
    _UMP.prototype = UMP;
    UMP._sxid = 127;
    UMP.sxId = function(id2) {
      if (typeof id2 == "undefined") id2 = UMP._sxid;
      if (id2 == this._sxid) return this;
      id2 = _7b(id2);
      var ret = new _UMP();
      ret._ch = this._ch;
      ret._gr = this._gr;
      ret._sxid = id2;
      return ret;
    };
    UMP.ch = function(c2) {
      if (c2 == this._ch || typeof c2 == "undefined" && typeof this._ch == "undefined") return this;
      var ret = new _UMP();
      if (typeof c2 != "undefined") c2 = _ch(c2);
      ret._ch = c2;
      ret._gr = this._gr;
      ret._sxid = this._sxid;
      return ret;
    };
    UMP.gr = function(g2) {
      if (g2 == this._gr || typeof g2 == "undefined" && typeof this._gr == "undefined") return this;
      var ret = new _UMP();
      if (typeof g2 != "undefined") g2 = _4b(g2);
      ret._ch = this._ch;
      ret._gr = g2;
      ret._sxid = this._sxid;
      return ret;
    };
    UMP.prototype.getGroup = function() {
      if (!this[0]) return;
      var m3 = this[0] >> 4;
      if (m3 == 1 || m3 == 2 || m3 == 3 || m3 == 4 || m3 == 5 || m3 == 13) return this[0] & 15;
    };
    var _zeros = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    function _32a(a2, b2, c2, d2) {
      if (typeof b2 != "undefined") return [_8b(a2), _8b(b2), _8b(c2), _8b(d2)];
      a2 = _32b(a2);
      return [a2 >> 24 & 255, a2 >> 16 & 255, a2 >> 8 & 255, a2 & 255];
    }
    function _f_32(x3) {
      x3 = Math.floor(x3 * 4294967296);
      return x3 > 4294967295 ? 4294967295 : x3 < 0 ? 0 : x3;
    }
    var _helperNN = {
      noop: function() {
        return [0, 0, 0, 0];
      },
      umpClock: function(n2) {
        n2 = _16b(n2);
        return [0, 16, n2 >> 8, n2 & 255];
      },
      umpTimestamp: function(n2) {
        n2 = _16b(n2);
        return [0, 32, n2 >> 8, n2 & 255];
      },
      umpTicksPQN: function(n2) {
        n2 = _16b(n2);
        return [0, 48, n2 >> 8, n2 & 255];
      },
      umpDelta: function(n2) {
        n2 = n2 || 0;
        n2 = _20b(n2);
        return [0, 64 + (n2 >> 16), n2 >> 8 & 255, n2 & 255];
      },
      umpStartClip: function() {
        return [240, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      },
      umpEndClip: function() {
        return [240, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
    };
    var _helperGN = {
      umpTempo: function(g2, n2) {
        return [208 + _4b(g2), 16, 0, 0].concat(_32a(n2), [0, 0, 0, 0, 0, 0, 0, 0]);
      },
      umpBPM: function(g2, n2) {
        return _helperGN.umpTempo(g2, Math.round(6e9 / n2));
      },
      umpTimeSignature: function(g2, a2, b2) {
        var nn, cc, dd;
        var m3 = ("" + a2).match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
        if (m3) {
          nn = parseInt(m3[1]);
          cc = parseInt(m3[2]);
        } else if (a2 == parseInt(a2) && b2 == parseInt(b2)) {
          nn = parseInt(a2);
          cc = parseInt(b2);
        }
        if (nn > 0 && nn < 256 && cc > 0 && !(cc & cc - 1)) {
          dd = 0;
          for (cc >>= 1; cc; cc >>= 1) dd++;
          cc = Math.round(nn * 32 / (1 << dd));
          if (cc < 256) return [208 + _4b(g2), 16, 0, 1, nn, dd, cc, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        throw RangeError("Wrong time signature " + a2 + (typeof b2 == "undefined" ? "" : "/" + b2));
      }
    };
    var _helperGNX = {
      umpMetadata: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 0, t2);
      },
      umpProjectName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 1, t2);
      },
      umpCompositionName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 2, t2);
      },
      umpClipName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 3, t2);
      },
      umpCopyright: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 4, t2);
      },
      umpComposerName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 5, t2);
      },
      umpLyricistName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 6, t2);
      },
      umpArrangerName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 7, t2);
      },
      umpPublisherName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 8, t2);
      },
      umpPerformerName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 9, t2);
      },
      umpAccPerformerName: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 10, t2);
      },
      umpRecordingDate: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 11, t2);
      },
      umpRecordingLocation: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 1, 12, t2);
      },
      umpText: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 2, 0, t2);
      },
      umpLyrics: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 2, 1, t2);
      },
      umpLyricsLanguage: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 2, 2, t2);
      },
      umpRuby: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 2, 3, t2);
      },
      umpRubyLanguage: function(g2, t2) {
        return _helperGCX.umpCustomText(g2, 0, 1, 2, 4, t2);
      },
      umpData: function(g2, x3, y2) {
        if (typeof y2 == "undefined") {
          y2 = x3;
          x3 = 0;
        }
        var i3;
        var a2 = _slice(_bytes(y2), 13);
        for (i3 = 0; i3 < a2.length; i3++) a2[i3] = [80 + _4b(g2), _umpseqstat(a2.length, i3) * 16 + a2[i3].length, _8b(x3)].concat(a2[i3], _zeros).slice(0, 16);
        return a2;
      }
    };
    var _noctrl = [0, 6, 32, 38, 98, 99, 100, 101];
    var _helperGC = {
      umpNoteOn: function(g2, c2, n2, v2, t2, a2) {
        if (typeof v2 == "undefined") v2 = 65535;
        t2 = t2 || 0;
        a2 = a2 || 0;
        v2 = _16b(v2);
        a2 = _16b(a2);
        return [64 + _4b(g2), 144 + _ch(c2), _7bn(n2), _8b(t2), v2 >> 8, v2 & 255, a2 >> 8, a2 & 255];
      },
      umpNoteOff: function(g2, c2, n2, v2, t2, a2) {
        v2 = v2 || 0;
        t2 = t2 || 0;
        a2 = a2 || 0;
        v2 = _16b(v2);
        a2 = _16b(a2);
        return [64 + _4b(g2), 128 + _ch(c2), _7bn(n2), _8b(t2), v2 >> 8, v2 & 255, a2 >> 8, a2 & 255];
      },
      umpAftertouch: function(g2, c2, n2, x3, y2, z2, w2) {
        return [64 + _4b(g2), 160 + _ch(c2), _7bn(n2), 0].concat(_32a(x3, y2, z2, w2));
      },
      umpAftertouchF: function(g2, c2, n2, x3) {
        return _helperGC.umpAftertouch(g2, c2, n2, _f_32(x3));
      },
      umpControl: function(g2, c2, n2, x3, y2, z2, w2) {
        if (_noctrl.includes(n2)) _throw(n2);
        return [64 + _4b(g2), 176 + _ch(c2), _7b(n2), 0].concat(_32a(x3, y2, z2, w2));
      },
      umpPortamento: function(g2, c2, n2) {
        return [64 + _4b(g2), 176 + _ch(c2), 84, 0, _7bn(n2), 0, 0, 0];
      },
      umpPressure: function(g2, c2, x3, y2, z2, w2) {
        return [64 + _4b(g2), 208 + _ch(c2), 0, 0].concat(_32a(x3, y2, z2, w2));
      },
      umpPressureF: function(g2, c2, x3) {
        return _helperGC.umpPressure(g2, c2, _f_32(x3));
      },
      umpProgram: function(g2, c2, n2, msb, lsb) {
        return typeof msb == "undefined" && typeof lsb == "undefined" ? [64 + _4b(g2), 192 + _ch(c2), 0, 0, _7bn(n2), 0, 0, 0] : typeof lsb == "undefined" ? [64 + _4b(g2), 192 + _ch(c2), 0, 1, _7bn(n2), 0, _msb(msb), _lsb(msb)] : [64 + _4b(g2), 192 + _ch(c2), 0, 1, _7bn(n2), 0, _7b(msb), _7b(lsb)];
      },
      umpPitchBend: function(g2, c2, x3, y2, z2, w2) {
        return [64 + _4b(g2), 224 + _ch(c2), 0, 0].concat(_32a(x3, y2, z2, w2));
      },
      umpPitchBendF: function(g2, c2, x3) {
        return _helperGC.umpPitchBend(g2, c2, _f_32((x3 + 1) / 2));
      },
      umpPnPitchBend: function(g2, c2, n2, x3, y2, z2, w2) {
        return [64 + _4b(g2), 96 + _ch(c2), _7bn(n2), 0].concat(_32a(x3, y2, z2, w2));
      },
      umpPnPitchBendF: function(g2, c2, n2, x3) {
        return _helperGC.umpPnPitchBend(g2, c2, n2, _f_32((x3 + 1) / 2));
      },
      umpRPN: function(g2, c2, b2, n2, x3, y2, z2, w2) {
        return [64 + _4b(g2), 32 + _ch(c2), _7b(b2), _7b(n2)].concat(_32a(x3, y2, z2, w2));
      },
      umpNRPN: function(g2, c2, b2, n2, x3, y2, z2, w2) {
        return [64 + _4b(g2), 48 + _ch(c2), _7b(b2), _7b(n2)].concat(_32a(x3, y2, z2, w2));
      },
      umpPnRPN: function(g2, c2, n2, i3, x3, y2, z2, w2) {
        return [64 + _4b(g2), 0 + _ch(c2), _7bn(n2), _8b(i3)].concat(_32a(x3, y2, z2, w2));
      },
      umpPnNRPN: function(g2, c2, n2, i3, x3, y2, z2, w2) {
        return [64 + _4b(g2), 16 + _ch(c2), _7bn(n2), _8b(i3)].concat(_32a(x3, y2, z2, w2));
      },
      umpFineTuning: function(g2, c2, x3, y2, z2, w2) {
        return _helperGC.umpRPN(g2, c2, 0, 1, x3, y2, z2, w2);
      },
      umpFineTuningF: function(g2, c2, x3) {
        return _helperGC.umpFineTuning(g2, c2, MIDI.to32b(_01((x3 % 1 + 1) / 2, x3)));
      },
      umpCoarseTuning: function(g2, c2, n2) {
        return [64 + _4b(g2), 32 + _ch(c2), 0, 2, _7b(n2) * 2, 0, 0, 0];
      },
      umpCoarseTuningF: function(g2, c2, x3) {
        return _helperGC.umpCoarseTuning(g2, c2, 64 + (x3 - x3 % 1));
      },
      umpTuningProgram: function(g2, c2, n2) {
        return [64 + _4b(g2), 32 + _ch(c2), 0, 3, _7b(n2) * 2, 0, 0, 0];
      },
      umpTuningBank: function(g2, c2, n2) {
        return [64 + _4b(g2), 32 + _ch(c2), 0, 4, _7b(n2) * 2, 0, 0, 0];
      },
      umpPnManagement: function(g2, c2, n2, m3) {
        var a2 = m3.toString().split("");
        var x3 = 0;
        for (var i3 = 0; i3 < a2.length; i3++) {
          if (a2[i3] == "S" && !(x3 & 1)) x3 |= 1;
          else if (a2[i3] == "D" && !(x3 & 2)) x3 |= 2;
          else {
            x3 = m3;
            break;
          }
        }
        return [64 + _4b(g2), 240 + _ch(c2), _7bn(n2), _8b(x3), 0, 0, 0, 0];
      }
    };
    _helperGC.umpPnPressure = _helperGC.umpAftertouch;
    _helperGC.umpPnPressureF = _helperGC.umpAftertouchF;
    _helperGC.umpTranspose = _helperGC.umpCoarseTuningF;
    var _helperGCX = {
      umpTuningF: function(g2, c2, x3) {
        return [_helperGC.umpCoarseTuningF(g2, c2, x3), _helperGC.umpFineTuningF(g2, c2, x3)];
      },
      umpTuningA: function(g2, c2, a2) {
        return _helperGCX.umpTuningF(g2, c2, MIDI.shift(a2));
      },
      umpCustomText: function(g2, c2, d2, b2, s2, t2) {
        var i3;
        var a2 = [];
        t2 = JZZ2.lib.toUTF8("" + t2);
        for (i3 = 0; i3 < t2.length; i3++) a2.push(t2.charCodeAt(i3));
        a2 = _slice(a2, 12);
        for (i3 = 0; i3 < a2.length; i3++) a2[i3] = [208 + _4b(g2), _umpseqstat(a2.length, i3) * 64 + (d2 ? 16 : 0) + _ch(c2), b2, s2].concat(a2[i3], _zeros).slice(0, 16);
        return a2;
      },
      umpCMetadata: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 0, t2);
      },
      umpCProjectName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 1, t2);
      },
      umpCCompositionName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 2, t2);
      },
      umpCClipName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 3, t2);
      },
      umpCCopyright: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 4, t2);
      },
      umpCComposerName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 5, t2);
      },
      umpCLyricistName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 6, t2);
      },
      umpCArrangerName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 7, t2);
      },
      umpCPublisherName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 8, t2);
      },
      umpCPerformerName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 9, t2);
      },
      umpCAccPerformerName: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 10, t2);
      },
      umpCRecordingDate: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 11, t2);
      },
      umpCRecordingLocation: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 1, 12, t2);
      },
      umpCText: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 2, 0, t2);
      },
      umpCLyrics: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 2, 1, t2);
      },
      umpCLyricsLanguage: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 2, 2, t2);
      },
      umpCRuby: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 2, 3, t2);
      },
      umpCRubyLanguage: function(g2, c2, t2) {
        return _helperGCX.umpCustomText(g2, c2, 0, 2, 4, t2);
      }
    };
    var _helpersUmp = {};
    function _copyHelperNN(name, func) {
      UMP[name] = function() {
        return new UMP(func.apply(this, arguments));
      };
      _helpersUmp[name] = function() {
        return this.send(func.apply(this, arguments));
      };
    }
    function _copyHelperGN(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        return new UMP(func.apply(this, args));
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        return this.send(func.apply(this, args));
      };
    }
    function _copyHelperGNX(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        var a2 = func.apply(this, args);
        for (var i3 = 0; i3 < a2.length; i3++) a2[i3] = new UMP(a2[i3]);
        return a2;
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        var a2 = func.apply(this, args);
        for (var i3 = 0; i3 < a2.length; i3++) this.send(a2[i3]);
        return this;
      };
    }
    function _copyHelperGC(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        return new UMP(func.apply(this, args));
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        return this.send(func.apply(this, args));
      };
    }
    function _copyHelperGCX(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        var a2 = func.apply(this, args);
        for (var i3 = 0; i3 < a2.length; i3++) a2[i3] = new UMP(a2[i3]);
        return a2;
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        var a2 = func.apply(this, args);
        for (var i3 = 0; i3 < a2.length; i3++) this.send(a2[i3]);
        return this;
      };
    }
    function _umpseqstat(n2, i3) {
      return n2 == 1 ? 0 : i3 == 0 ? 1 : i3 == n2 - 1 ? 3 : 2;
    }
    function _slice(m3, n2) {
      var a2 = [];
      for (var x3 = m3; x3.length; x3 = x3.slice(n2)) a2.push(x3.slice(0, n2));
      return a2.length ? a2 : [[]];
    }
    function _sliceSX(gr, m3) {
      var a2 = _slice(m3.slice(1, m3.length - 1), 6);
      for (var i3 = 0; i3 < a2.length; i3++) a2[i3] = new UMP([48 + gr, _umpseqstat(a2.length, i3) * 16 + a2[i3].length].concat(a2[i3], _zeros).slice(0, 8));
      return a2;
    }
    function _bytes(s2) {
      var i3;
      var a2 = [];
      if (typeof s2 == "string") for (i3 = 0; i3 < s2.length; i3++) a2.push(s2.charCodeAt(i3));
      else for (i3 = 0; i3 < s2.length; i3++) a2.push(s2[i3]);
      for (i3 = 0; i3 < a2.length; i3++) if (a2[i3] != parseInt(a2[i3]) || a2[i3] < 0 || a2[i3] > 255) throw RangeError("Bad data");
      return a2;
    }
    function _copyHelperSX(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        return _sliceSX(_4b(args[0]), func.apply(this, args.slice(1)));
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        var a2 = _sliceSX(_4b(args[0]), func.apply(this, args.slice(1)));
        var g2 = this;
        for (var i3 = 0; i3 < a2.length; i3++) g2 = g2.send(a2[i3]);
        return g2;
      };
    }
    function _copyHelperSXX(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        var m3 = func.apply(this, args.slice(1));
        var a2 = [];
        for (var i3 = 0; i3 < m3.length; i3++) a2 = a2.concat(_sliceSX(_4b(args[0]), m3[i3]));
        return a2;
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        var m3 = func.apply(this, args.slice(1));
        var g2 = this;
        for (var i3 = 0; i3 < m3.length; i3++) {
          var a2 = _sliceSX(_4b(args[0]), m3[i3]);
          for (var j3 = 0; j3 < a2.length; j3++) g2 = g2.send(a2[j3]);
        }
        return g2;
      };
    }
    function _copyHelperM1N(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        return new UMP([16 + _4b(args[0])].concat(func.apply(this, args.slice(1)), _zeros).slice(0, 4));
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        return this.send([16 + _4b(args[0])].concat(func.apply(this, args.slice(1)), _zeros).slice(0, 4));
      };
    }
    function _copyHelperM1C(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        return new UMP([32 + _4b(args[0])].concat(func.apply(this, args.slice(1)), _zeros).slice(0, 4));
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        return this.send([32 + _4b(args[0])].concat(func.apply(this, args.slice(1)), _zeros).slice(0, 4));
      };
    }
    function _copyHelperM1CX(name, func) {
      UMP[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        var a2 = func.apply(this, args.slice(1));
        for (var i3 = 0; i3 < a2.length; i3++) a2[i3] = new UMP([32 + _4b(args[0])].concat(a2[i3], _zeros).slice(0, 4));
        return a2;
      };
      _helpersUmp[name] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this._gr != "undefined") args = [this._gr].concat(args);
        if (typeof this._ch != "undefined") args = [args[0]].concat([this._ch]).concat(args.slice(1));
        var a2 = func.apply(this, args.slice(1));
        var g2 = this;
        for (var i3 = 0; i3 < a2.length; i3++) g2 = g2.send([32 + _4b(args[0])].concat(a2[i3], _zeros).slice(0, 4));
        return g2;
      };
    }
    _for(_helperNN, function(n2) {
      _copyHelperNN(n2, _helperNN[n2]);
    });
    _for(_helperGN, function(n2) {
      _copyHelperGN(n2, _helperGN[n2]);
    });
    _for(_helperGNX, function(n2) {
      _copyHelperGNX(n2, _helperGNX[n2]);
    });
    _for(_helperGC, function(n2) {
      _copyHelperGC(n2, _helperGC[n2]);
    });
    _for(_helperGCX, function(n2) {
      _copyHelperGCX(n2, _helperGCX[n2]);
    });
    _for(_helperNC, function(n2) {
      _copyHelperM1N(n2, _helperNC[n2]);
    });
    _for(_helperMPE, function(n2) {
      _copyHelperM1C(n2, _helperMPE[n2]);
    });
    _for(_helperCH, function(n2) {
      _copyHelperM1C(n2, _helperCH[n2]);
    });
    _for(_helperGCH, function(n2) {
      _copyHelperM1CX(n2, _helperGCH[n2]);
    });
    _for(_helperSX, function(n2) {
      _copyHelperSX(n2, _helperSX[n2]);
    });
    _for(_helperSXX, function(n2) {
      _copyHelperSXX(n2, _helperSXX[n2]);
    });
    function _copyUmpHelpers(M2) {
      _for(_helpersUmp, function(n2) {
        M2.prototype[n2] = _helpersUmp[n2];
      });
    }
    _copyUmpHelpers(_M2);
    UMP.prototype.getTempo = function() {
      if (this.isTempo()) return (this[4] << 24) + (this[5] << 16) + (this[6] << 8) + this[7];
    };
    UMP.prototype.getBPM = function() {
      var n2 = this.getTempo();
      if (n2) return Math.round(6e9 / n2);
    };
    UMP.prototype.getTimeSignature = function() {
      if (this.isTimeSignature()) return [this[4], 1 << this[5]];
    };
    UMP.prototype.getTicksPQN = function() {
      if (this.isTicksPQN()) return (this[2] << 8) + this[3];
    };
    UMP.prototype.getDelta = function() {
      if (this.isDelta()) return ((this[1] & 15) << 16) + (this[2] << 8) + this[3];
    };
    UMP.prototype.getStatus = function() {
      if (this.isFlex()) return this[1] >> 6;
      if (this.isData() || this.isSX()) return this[1] >> 4;
    };
    UMP.prototype.isTempo = function() {
      return this[0] >> 4 == 13 && this[1] >> 4 == 1 && this[2] == 0 && this[3] == 0;
    };
    UMP.prototype.isTimeSignature = function() {
      return this[0] >> 4 == 13 && this[1] >> 4 == 1 && this[2] == 0 && this[3] == 1;
    };
    UMP.prototype.isTicksPQN = function() {
      return this[0] == 0 && this[1] >> 4 == 3;
    };
    UMP.prototype.isDelta = function() {
      return this[0] == 0 && this[1] >> 4 == 4;
    };
    UMP.prototype.isStartClip = function() {
      return this.match([240, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    };
    UMP.prototype.isEndClip = function() {
      return this.match([240, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    };
    UMP.prototype.isData = function() {
      return (this[0] & 240) == 80;
    };
    UMP.prototype.isFlex = function() {
      return (this[0] & 240) == 208;
    };
    UMP.prototype.isText = function() {
      return (this[0] & 240) == 208 && (this[2] == 1 || this[2] == 2);
    };
    UMP.prototype.isSX = function() {
      return (this[0] & 240) == 48;
    };
    UMP.prototype.isNoteOn = function() {
      var c2 = (this[0] || 0) >> 4;
      var d2 = (this[1] || 0) >> 4;
      if (c2 == 4) return d2 == 9;
      else if (c2 == 2) return d2 == 9 && !!this[3];
      return false;
    };
    UMP.prototype.isNoteOff = function() {
      var c2 = (this[0] || 0) >> 4;
      var d2 = (this[1] || 0) >> 4;
      if (c2 == 4) return d2 == 8;
      else if (c2 == 2) return d2 == 8 || d2 == 9 && !this[3];
      return false;
    };
    UMP.prototype.label = MIDI.prototype.label;
    UMP.prototype.toString = MIDI.prototype.toString;
    UMP.prototype._str = function() {
      var t2 = this._string();
      return t2 ? _hexx(this) + " -- " + t2 : _hexx(this);
    };
    UMP.prototype._string = function() {
      var n2, s2, ss;
      var t2 = this[0] >> 4;
      if (t2 == 1 || t2 == 2) return new MIDI(this.slice(1))._string();
      else if (t2 == 0) {
        n2 = this[1] >> 4;
        s2 = ["NOOP", "JR Clock", "JR Timestamp", "Ticks Per Quarter Note", "Delta Ticks"][n2];
      } else if (t2 == 3) {
        s2 = "SysEx";
      } else if (t2 == 4) {
        n2 = this[1] >> 4;
        s2 = {
          0: "Registered Per-Note Controller",
          1: "Assignable Per-Note Controller",
          2: "Registered Controller",
          3: "Assignable Controller",
          4: "Relative Registered Controller",
          5: "Relative Assignable Controller",
          6: "Per-Note Pitch Bend",
          8: "Note Off",
          9: "Note On",
          10: "Poly Pressure",
          11: "Control Change",
          12: "Program Change",
          13: "Channel Pressure",
          14: "Pitch Bend",
          15: "Per-Note Management"
        }[n2];
        if (n2 == 11) {
          s2 = {
            84: "Portamento"
          }[this[2]] || s2;
        }
        if (n2 == 2) {
          ss = {
            "0000": "Pitch Bend Sensitivity",
            "0001": "Fine Tuning",
            "0002": "Coarse Tuning",
            "0003": "Select Tuning Program",
            "0004": "Select Tuning Bank",
            "0005": "Vibrato Depth Range",
            "7f7f": "NONE"
          }[__hex(this[2]) + "" + __hex(this[3])];
          if (ss) s2 += ": " + ss;
        }
      } else if (t2 == 5) {
        s2 = "Data";
      } else if (t2 == 13) {
        n2 = this[2];
        if (n2 == 0) {
          n2 = this[3];
          s2 = {
            0: "Tempo ",
            1: "Time Signature ",
            2: "Metronome",
            5: "Key Signature",
            6: "Chord Name"
          }[n2];
          if (n2 == 0) s2 += this.getBPM() + " BPM";
          else if (n2 == 1) s2 += this.getTimeSignature().join("/");
        } else if (n2 == 1) {
          n2 = this[3];
          s2 = {
            0: "Metadata",
            1: "Project Name",
            2: "Composition Name",
            3: "Clip Name",
            4: "Copyright",
            5: "Composer Name",
            6: "Lyricist Name",
            7: "Arranger Name",
            8: "Publisher Name",
            9: "Primary Performer Name",
            10: "Accompanying Performer Name",
            11: "Recording Date",
            12: "Recording Location"
          }[n2] || "Unknown Text";
        } else if (n2 == 2) {
          n2 = this[3];
          s2 = {
            0: "Text",
            1: "Lyrics",
            2: "Lyrics Language",
            3: "Ruby",
            4: "Ruby Language"
          }[n2] || "Unknown Text";
        }
      }
      if (t2 == 15) {
        s2 = { 32: "Start of Clip", 33: "End of Clip" }[this[1]];
      }
      return s2;
    };
    UMP.prototype._stamp = MIDI.prototype._stamp;
    UMP.prototype._unstamp = MIDI.prototype._unstamp;
    UMP.prototype._stamped = MIDI.prototype._stamped;
    UMP.prototype.match = MIDI.prototype.match;
    JZZ2.UMP = UMP;
    _J.prototype.UMP = UMP;
    JZZ2.MIDI2 = UMP;
    _J.prototype.MIDI2 = UMP;
    function _16_7(a2, b2) {
      var n2 = a2 * 256 + b2;
      return n2 ? n2 >> 9 || 1 : 0;
    }
    function _32_7(a2, b2, c2, d2) {
      var n2 = a2 * 16777216 + b2 * 65536 + c2 * 256 + d2;
      return n2 >> 25 & 127;
    }
    function _grp(m3, g2) {
      m3.gr = g2;
      return m3;
    }
    function _m2m1(msg) {
      if (msg.isMidi2) {
        var n2, c2, x3;
        var t2 = msg[0] >> 4;
        var g2 = msg[0] & 15;
        if (t2 == 1 || t2 == 2) {
          this._emit(_grp(new MIDI(msg.slice(1)), g2));
        } else if (t2 == 3) {
          c2 = msg[1] >> 4;
          n2 = msg[1] & 15;
          if (c2 == 0) {
            this._emit(_grp(new MIDI([240].concat(msg.slice(2, 2 + n2), [247])), g2));
            this._sx[g2] = void 0;
          } else if (c2 == 1) {
            this._sx[g2] = msg.slice(2, 2 + n2);
          } else if (c2 == 2) {
            if (this._sx[g2]) this._sx[g2] = this._sx[g2].concat(msg.slice(2, 2 + n2));
          } else if (c2 == 3) {
            if (this._sx[g2]) this._emit(_grp(new MIDI([240].concat(this._sx[g2], msg.slice(2, 2 + n2), [247])), g2));
            this._sx[g2] = void 0;
          }
        } else if (t2 == 4) {
          n2 = msg[1] >> 4;
          c2 = msg[1] & 15;
          if (n2 == 2 || n2 == 3) {
            this._emit(_grp(new MIDI([176 + c2, n2 == 2 ? 101 : 99, msg[2]]), g2));
            this._emit(_grp(new MIDI([176 + c2, n2 == 2 ? 100 : 98, msg[3]]), g2));
            this._emit(_grp(new MIDI([176 + c2, 6, msg[4] >> 1]), g2));
            this._emit(_grp(new MIDI([176 + c2, 38, (msg[4] & 1) * 64 + (msg[4] >> 2)]), g2));
          } else if (n2 == 8 || n2 == 9) {
            this._emit(_grp(new MIDI([msg[1], msg[2], _16_7(msg[4], msg[5])]), g2));
          }
          if (n2 == 10) {
            this._emit(_grp(new MIDI([msg[1], msg[2], _32_7(msg[4], msg[5], msg[6], msg[7])]), g2));
          }
          if (n2 == 11) {
            if (_noctrl.includes(msg[2])) return;
            this._emit(_grp(new MIDI([msg[1], msg[2], _32_7(msg[4], msg[5], msg[6], msg[7])]), g2));
          }
          if (n2 == 13) {
            this._emit(_grp(new MIDI([msg[1], _32_7(msg[4], msg[5], msg[6], msg[7])]), g2));
          }
          if (n2 == 14) {
            x3 = msg[4] * 16777216 + msg[5] * 65536 + msg[6] * 256 + msg[4] >> 18;
            this._emit(_grp(new MIDI([msg[1], x3 & 127, x3 >> 7 & 127]), g2));
          } else if (n2 == 12) {
            if (msg[3]) {
              this._emit(_grp(new MIDI([176 + c2, 0, msg[6]]), g2));
              this._emit(_grp(new MIDI([176 + c2, 32, msg[7]]), g2));
            }
            this._emit(_grp(new MIDI([msg[1], msg[4]]), g2));
          }
        }
      } else this._emit(msg);
    }
    function M2M1() {
      var self2 = new _M();
      self2._sx = [];
      self2._receive = _m2m1;
      self2._resume();
      return self2.MIDI2();
    }
    JZZ2.M2M1 = M2M1;
    _J.prototype.M2M1 = JZZ2.M2M1;
    function _m1m2(msg) {
      if (!msg.isMidi2) {
        var gr = msg.gr >= 0 && msg.gr <= 15 ? msg.gr : 0;
        if (msg[0] >= 128 && msg[0] < 240) {
          this._emit(JZZ2.MIDI2([32 + gr].concat(msg.slice(), _zeros).slice(0, 4)));
        } else if (msg[0] > 240 && msg[0] <= 255 && msg[0] != 247) {
          this._emit(JZZ2.MIDI2([16 + gr].concat(msg.slice(), _zeros).slice(0, 4)));
        } else if (msg.isFullSysEx()) {
          var a2 = _sliceSX(gr, msg.slice());
          for (var i3 = 0; i3 < a2.length; i3++) this._emit(JZZ2.MIDI2(a2[i3]));
        }
      } else this._emit(msg);
    }
    function M1M2() {
      var self2 = new _M();
      self2._receive = _m1m2;
      self2._resume();
      return self2;
    }
    JZZ2.M1M2 = M1M2;
    _J.prototype.M1M2 = JZZ2.M1M2;
    JZZ2.lib = {};
    JZZ2.lib.now = _now;
    JZZ2.lib.schedule = _schedule;
    JZZ2.lib.R = _R;
    var _sch_list = [];
    var _sch_worker;
    var _sch_count = 0;
    try {
      var _blob = URL.createObjectURL(new Blob(["(", function() {
        function tick() {
          postMessage({});
          setTimeout(tick, 0);
        }
        tick();
      }.toString(), ")()"], { type: "application/javascript" }));
      var _sch_tick = function() {
        var n2 = _sch_list.length;
        for (var i3 = 0; i3 < n2; i3++) _sch_list.shift()();
        _sch_count++;
        if (_sch_count > 20 && _sch_worker) {
          _sch_worker.terminate();
          _sch_worker = void 0;
        }
      };
      var _sch = function(x3) {
        _sch_list.push(x3);
        _sch_count = 0;
        if (!_sch_worker) {
          _sch_worker = new Worker(_blob);
          _sch_worker.onmessage = _sch_tick;
        }
      };
      _sch(function() {
        JZZ2.lib.schedule = _sch;
      });
    } catch (e2) {
    }
    JZZ2.lib.openMidiOut = function(name, engine) {
      var port = new _M();
      engine._openOut(port);
      port._info = engine._info(name);
      return port;
    };
    JZZ2.lib.openMidiIn = function(name, engine) {
      var port = new _M();
      engine._openIn(port);
      port._info = engine._info(name);
      return port;
    };
    JZZ2.lib.registerMidiOut = function(name, engine) {
      var x3 = engine._info(name);
      for (var i3 = 0; i3 < _virtual._outs.length; i3++) if (_virtual._outs[i3].name == x3.name) return false;
      x3.engine = engine;
      _virtual._outs.push(x3);
      if (_jzz) {
        _postRefresh();
        if (_jzz._bad) {
          _jzz._repair();
          _jzz._resume();
        }
      }
      return true;
    };
    JZZ2.lib.registerMidiIn = function(name, engine) {
      var x3 = engine._info(name);
      for (var i3 = 0; i3 < _virtual._ins.length; i3++) if (_virtual._ins[i3].name == x3.name) return false;
      x3.engine = engine;
      _virtual._ins.push(x3);
      if (_jzz) {
        _postRefresh();
        if (_jzz._bad) {
          _jzz._repair();
          _jzz._resume();
        }
      }
      return true;
    };
    JZZ2.lib.unregisterMidiOut = function(name) {
      for (var i3 = 0; i3 < _virtual._outs.length; i3++) if (_virtual._outs[i3].name == name) {
        _virtual._outs.splice(i3, i3 + 1);
        if (_jzz) _postRefresh();
        return true;
      }
      return false;
    };
    JZZ2.lib.unregisterMidiIn = function(name) {
      for (var i3 = 0; i3 < _virtual._ins.length; i3++) if (_virtual._ins[i3].name == name) {
        _virtual._ins.splice(i3, i3 + 1);
        if (_jzz) _postRefresh();
        return true;
      }
      return false;
    };
    JZZ2.lib.plug = function(x3) {
      for (var i3 = 0; i3 < _plugged.length; i3++) if (_plugged[i3] == x3) return;
      _plugged.push(x3);
    };
    JZZ2.lib.unplug = function(x3) {
      for (var i3 = 0; i3 < _plugged.length; i3++) if (_plugged[i3] == x3) {
        _plugged.splice(i3, 1);
        return;
      }
    };
    var _ac;
    function _initAudioContext() {
      if (!_ac && typeof window !== "undefined") {
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
          _ac = new AudioContext();
          if (_ac && !_ac.createGain) _ac.createGain = _ac.createGainNode;
          var _activateAudioContext = function() {
            if (_ac.state != "running") {
              _ac.resume();
              var osc = _ac.createOscillator();
              var gain = _ac.createGain();
              try {
                gain.gain.value = 0;
              } catch (err) {
              }
              gain.gain.setTargetAtTime(0, _ac.currentTime, 0.01);
              osc.connect(gain);
              gain.connect(_ac.destination);
              if (!osc.start) osc.start = osc.noteOn;
              if (!osc.stop) osc.stop = osc.noteOff;
              osc.start(0.1);
              osc.stop(0.11);
            } else if (typeof document != "undefined") {
              document.removeEventListener("touchstart", _activateAudioContext);
              document.removeEventListener("touchend", _activateAudioContext);
              document.removeEventListener("mousedown", _activateAudioContext);
              document.removeEventListener("keydown", _activateAudioContext);
            }
          };
          if (typeof document != "undefined") {
            document.addEventListener("touchstart", _activateAudioContext);
            document.addEventListener("touchend", _activateAudioContext);
            document.addEventListener("mousedown", _activateAudioContext);
            document.addEventListener("keydown", _activateAudioContext);
          }
          _activateAudioContext();
        }
      }
    }
    JZZ2.lib.copyMidiHelpers = _copyMidiHelpers;
    JZZ2.lib.copyMidi2Helpers = _copyUmpHelpers;
    JZZ2.lib.copyUmpHelpers = _copyUmpHelpers;
    JZZ2.lib.getAudioContext = function() {
      _initAudioContext();
      return _ac;
    };
    JZZ2.lib.closeAudioContext = function() {
      if (_ac) _ac.close();
      _ac = void 0;
    };
    var _b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    JZZ2.lib.fromBase64 = function(input) {
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i3 = 0;
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      while (i3 < input.length) {
        enc1 = _b64.indexOf(input.charAt(i3++));
        enc2 = _b64.indexOf(input.charAt(i3++));
        enc3 = _b64.indexOf(input.charAt(i3++));
        enc4 = _b64.indexOf(input.charAt(i3++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output = output + String.fromCharCode(chr1);
        if (enc3 != 64) {
          output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
          output = output + String.fromCharCode(chr3);
        }
      }
      return output;
    };
    JZZ2.lib.toBase64 = function(data) {
      var o1, o2, o3, h1, h2, h3, h4, bits, i3 = 0, ac = 0, enc = "", arr = [];
      if (!data) return data;
      do {
        o1 = data.charCodeAt(i3++);
        o2 = data.charCodeAt(i3++);
        o3 = data.charCodeAt(i3++);
        bits = o1 << 16 | o2 << 8 | o3;
        h1 = bits >> 18 & 63;
        h2 = bits >> 12 & 63;
        h3 = bits >> 6 & 63;
        h4 = bits & 63;
        arr[ac++] = _b64.charAt(h1) + _b64.charAt(h2) + _b64.charAt(h3) + _b64.charAt(h4);
      } while (i3 < data.length);
      enc = arr.join("");
      var r3 = data.length % 3;
      return r3 ? enc.slice(0, r3 - 3) + "===".slice(r3) : enc;
    };
    JZZ2.lib.fromUTF8 = function(data) {
      data = typeof data == "undefined" ? "" : "" + data;
      var out = "";
      var i3, n2, m3;
      for (i3 = 0; i3 < data.length; i3++) {
        n2 = data.charCodeAt(i3);
        if (n2 > 255) return data;
        if (n2 < 128) out += data[i3];
        else if ((n2 & 224) == 192) {
          n2 = (n2 & 31) << 6;
          i3++;
          if (i3 >= data.length) return data;
          m3 = data.charCodeAt(i3);
          if ((m3 & 192) != 128) return data;
          n2 += m3 & 63;
          out += String.fromCharCode(n2);
        } else if ((n2 & 240) == 224) {
          n2 = (n2 & 15) << 12;
          i3++;
          if (i3 >= data.length) return data;
          m3 = data.charCodeAt(i3);
          if ((m3 & 192) != 128) return data;
          n2 += (m3 & 63) << 6;
          i3++;
          if (i3 >= data.length) return data;
          m3 = data.charCodeAt(i3);
          if ((m3 & 192) != 128) return data;
          n2 += m3 & 63;
          out += String.fromCharCode(n2);
        } else if ((n2 & 248) == 240) {
          n2 = (n2 & 7) << 18;
          i3++;
          if (i3 >= data.length) return data;
          m3 = data.charCodeAt(i3);
          if ((m3 & 192) != 128) return data;
          n2 += (m3 & 63) << 12;
          i3++;
          if (i3 >= data.length) return data;
          m3 = data.charCodeAt(i3);
          if ((m3 & 192) != 128) return data;
          n2 += (m3 & 63) << 6;
          i3++;
          if (i3 >= data.length) return data;
          m3 = data.charCodeAt(i3);
          if ((m3 & 192) != 128) return data;
          n2 += m3 & 63;
          if (n2 > 1114111) return data;
          n2 -= 65536;
          out += String.fromCharCode(55296 + (n2 >> 10));
          out += String.fromCharCode(56320 + (n2 & 1023));
        }
      }
      return out;
    };
    JZZ2.lib.toUTF8 = function(data) {
      data = typeof data == "undefined" ? "" : "" + data;
      var out = "";
      var i3, n2;
      for (i3 = 0; i3 < data.length; i3++) {
        n2 = data.charCodeAt(i3);
        if (n2 < 128) out += data[i3];
        else if (n2 < 2048) {
          out += String.fromCharCode(192 + (n2 >> 6));
          out += String.fromCharCode(128 + (n2 & 63));
        } else if (n2 < 65536) {
          out += String.fromCharCode(224 + (n2 >> 12));
          out += String.fromCharCode(128 + (n2 >> 6 & 63));
          out += String.fromCharCode(128 + (n2 & 63));
        } else {
          out += String.fromCharCode(240 + (n2 >> 18));
          out += String.fromCharCode(128 + (n2 >> 12 & 63));
          out += String.fromCharCode(128 + (n2 >> 6 & 63));
          out += String.fromCharCode(128 + (n2 & 63));
        }
      }
      return out;
    };
    var _wma = [];
    var _outputMap = {};
    var _inputMap = {};
    var Promise2 = _scope.Promise;
    if (typeof Promise2 !== "function") {
      Promise2 = function(executor) {
        this.executor = executor;
      };
      Promise2.prototype.then = function(resolve2, reject) {
        if (typeof resolve2 !== "function") {
          resolve2 = _nop;
        }
        if (typeof reject !== "function") {
          reject = _nop;
        }
        this.executor(resolve2, reject);
      };
    }
    function DOMException(name, message, code2) {
      this.name = name;
      this.message = message;
      this.code = code2;
    }
    function MIDIConnectionEvent(port, target) {
      this.bubbles = false;
      this.cancelBubble = false;
      this.cancelable = false;
      this.currentTarget = target;
      this.defaultPrevented = false;
      this.eventPhase = 0;
      this.path = [];
      this.port = port;
      this.returnValue = true;
      this.srcElement = target;
      this.target = target;
      this.timeStamp = _now();
      this.type = "statechange";
    }
    function MIDIMessageEvent(port, data) {
      this.bubbles = false;
      this.cancelBubble = false;
      this.cancelable = false;
      this.currentTarget = port;
      this.data = data;
      this.defaultPrevented = false;
      this.eventPhase = 0;
      this.path = [];
      this.receivedTime = _now();
      this.returnValue = true;
      this.srcElement = port;
      this.target = port;
      this.timeStamp = this.receivedTime;
      this.type = "midimessage";
    }
    function _statechange(p2, a2) {
      if (p2) {
        if (p2.onstatechange) p2.onstatechange(new MIDIConnectionEvent(p2, p2));
        if (a2.onstatechange) a2.onstatechange(new MIDIConnectionEvent(p2, a2));
      }
    }
    function MIDIInput(a2, p2) {
      var self2 = this;
      var _open = false;
      var _ochng = null;
      var _onmsg = null;
      this.type = "input";
      this.id = p2.id;
      this.name = p2.name;
      this.manufacturer = p2.man;
      this.version = p2.ver;
      Object.defineProperty(this, "state", { get: function() {
        return p2.connected ? "connected" : "disconnected";
      }, enumerable: true });
      Object.defineProperty(this, "connection", { get: function() {
        return _open ? p2.proxy ? "open" : "pending" : "closed";
      }, enumerable: true });
      Object.defineProperty(this, "onmidimessage", {
        get: function() {
          return _onmsg;
        },
        set: function(value) {
          if (_func(value)) {
            _onmsg = value;
            if (!_open) self2.open().then(_nop, _nop);
          } else _onmsg = null;
        },
        enumerable: true
      });
      Object.defineProperty(this, "onstatechange", {
        get: function() {
          return _ochng;
        },
        set: function(value) {
          if (_func(value)) _ochng = value;
          else _ochng = null;
        },
        enumerable: true
      });
      this.open = function() {
        return new Promise2(function(resolve2, reject) {
          if (_open) resolve2(self2);
          else {
            p2.open().then(function() {
              if (!_open) {
                _open = true;
                _statechange(self2, a2);
              }
              resolve2(self2);
            }, function() {
              reject(new DOMException("InvalidAccessError", "Port is not available", 15));
            });
          }
        });
      };
      this.close = function() {
        return new Promise2(function(resolve2) {
          if (_open) {
            _open = false;
            p2.close();
            _statechange(self2, a2);
          }
          resolve2(self2);
        });
      };
      Object.freeze(this);
    }
    function _split(q2) {
      var i3, k3;
      while (q2.length) {
        for (i3 = 0; i3 < q2.length; i3++) if (q2[i3] == parseInt(q2[i3]) && q2[i3] >= 128 && q2[i3] <= 255 && q2[i3] != 247) break;
        q2.splice(0, i3);
        if (!q2.length) return;
        if (q2[0] == 240) {
          for (i3 = 1; i3 < q2.length; i3++) if (q2[i3] == 247) break;
          if (i3 == q2.length) return;
          return q2.splice(0, i3 + 1);
        } else {
          k3 = _datalen(q2[0]) + 1;
          if (k3 > q2.length) return;
          for (i3 = 1; i3 < k3; i3++) if (q2[i3] != parseInt(q2[i3]) || q2[i3] < 0 || q2[i3] >= 128) break;
          if (i3 == k3) return q2.splice(0, i3);
          else q2.splice(0, i3);
        }
      }
    }
    function _InputProxy(id2, name, man, ver) {
      var self2 = this;
      this.id = id2;
      this.name = name;
      this.man = man;
      this.ver = ver;
      this.connected = true;
      this.ports = [];
      this.pending = [];
      this.proxy = void 0;
      this.queue = [];
      this.onmidi = function(msg) {
        var m3;
        self2.queue = self2.queue.concat(msg.slice());
        for (m3 = _split(self2.queue); m3; m3 = _split(self2.queue)) {
          for (i2 = 0; i2 < self2.ports.length; i2++) {
            if (self2.ports[i2][0].onmidimessage && (m3[0] != 240 || self2.ports[i2][1])) {
              self2.ports[i2][0].onmidimessage(new MIDIMessageEvent(self2, new Uint8Array(m3)));
            }
          }
        }
      };
    }
    _InputProxy.prototype.open = function() {
      var self2 = this;
      return new Promise2(function(resolve2, reject) {
        var i3;
        if (self2.proxy || !self2.connected) resolve2();
        else {
          self2.pending.push([resolve2, reject]);
          if (self2.pending.length == 1) {
            JZZ2().openMidiIn(self2.name).or(function() {
              for (i3 = 0; i3 < self2.pending.length; i3++) self2.pending[i3][1]();
              self2.pending = [];
            }).and(function() {
              self2.proxy = this;
              self2.proxy.connect(self2.onmidi);
              for (i3 = 0; i3 < self2.pending.length; i3++) self2.pending[i3][0]();
              self2.pending = [];
            });
          }
        }
      });
    };
    _InputProxy.prototype.close = function() {
      var i3;
      if (this.proxy) {
        for (i3 = 0; i3 < this.ports.length; i3++) if (this.ports[i3].connection == "open") return;
        this.proxy.close();
        this.proxy = void 0;
      }
    };
    _InputProxy.prototype.disconnect = function() {
      this.connected = false;
      if (this.proxy) {
        this.proxy.close();
        this.proxy = void 0;
      }
    };
    _InputProxy.prototype.reconnect = function() {
      var self2 = this;
      var i3, p2;
      var a2 = [];
      this.connected = true;
      for (i3 = 0; i3 < _wma.length; i3++) {
        p2 = _wma[i3].inputs.get(this.id);
        if (p2.connection == "closed") _statechange(p2, _wma[i3]);
        else a2.push([p2, _wma[i3]]);
      }
      if (a2.length) {
        JZZ2()._openMidiInNR(self2.name).or(function() {
          for (i3 = 0; i3 < a2.length; i3++) a2[i3][0].close();
        }).and(function() {
          self2.proxy = this;
          self2.proxy.connect(self2.onmidi);
          for (i3 = 0; i3 < a2.length; i3++) _statechange(a2[i3][0], a2[i3][1]);
        });
      }
    };
    function _datalen(x3) {
      if (x3 >= 128 && x3 <= 191 || x3 >= 224 && x3 <= 239 || x3 == 242) return 2;
      if (x3 >= 192 && x3 <= 223 || x3 == 241 || x3 == 243) return 1;
      return 0;
    }
    var _epr = "Failed to execute 'send' on 'MIDIOutput': ";
    function _validate(arr, sysex) {
      var i3, k3;
      var msg;
      var data = [];
      for (i3 = 0; i3 < arr.length; i3++) {
        if (arr[i3] != parseInt(arr[i3]) || arr[i3] < 0 || arr[i3] > 255) throw TypeError(_epr + arr[i3] + " is not a UInt8 value.");
      }
      k3 = 0;
      for (i3 = 0; i3 < arr.length; i3++) {
        if (!k3) {
          if (arr[i3] < 128) throw TypeError(_epr + "Running status is not allowed at index " + i3 + " (" + arr[i3] + ").");
          if (arr[i3] == 247) throw TypeError(_epr + "Unexpected end of system exclusive message at index " + i3 + " (" + arr[i3] + ").");
          msg = [arr[i3]];
          data.push(msg);
          if (arr[i3] == 240) {
            if (!sysex) throw new DOMException("InvalidAccessError", _epr + "System exclusive messag is not allowed at index " + i3 + " (" + arr[i3] + ").", 15);
            k3 = -1;
            for (; i3 < arr.length; i3++) {
              msg.push(arr[i3]);
              if (arr[i3] == 247) {
                k3 = 0;
                break;
              }
            }
          } else {
            k3 = _datalen(arr[i3]);
          }
        } else {
          if (arr[i3] > 127) throw TypeError(_epr + "Unexpected status byte at index " + i3 + " (" + arr[i3] + ").");
          msg.push(arr[i3]);
          k3--;
        }
      }
      if (k3) throw TypeError(_epr + "Message is incomplete");
      return [data];
    }
    function MIDIOutput(a2, p2) {
      var self2 = this;
      var _open = false;
      var _ochng = null;
      this.type = "output";
      this.id = p2.id;
      this.name = p2.name;
      this.manufacturer = p2.man;
      this.version = p2.ver;
      Object.defineProperty(this, "state", { get: function() {
        return p2.connected ? "connected" : "disconnected";
      }, enumerable: true });
      Object.defineProperty(this, "connection", { get: function() {
        return _open ? p2.proxy ? "open" : "pending" : "closed";
      }, enumerable: true });
      Object.defineProperty(this, "onstatechange", {
        get: function() {
          return _ochng;
        },
        set: function(value) {
          if (_func(value)) _ochng = value;
          else _ochng = null;
        },
        enumerable: true
      });
      this.open = function() {
        return new Promise2(function(resolve2, reject) {
          if (_open) resolve2(self2);
          else {
            p2.open().then(function() {
              if (!_open) {
                _open = true;
                _statechange(self2, a2);
              }
              resolve2(self2);
            }, function() {
              reject(new DOMException("InvalidAccessError", "Port is not available", 15));
            });
          }
        });
      };
      this.close = function() {
        return new Promise2(function(resolve2) {
          if (_open) {
            _open = false;
            self2.clear();
            p2.close();
            _statechange(self2, a2);
          }
          resolve2(self2);
        });
      };
      this.clear = function() {
      };
      this.send = function(data, timestamp) {
        _validate(data, a2.sysexEnabled);
        if (!p2.connected) throw new DOMException("InvalidStateError", "Port is not connected", 11);
        if (_open) {
          var now = _now();
          if (timestamp > now) setTimeout(function() {
            p2.proxy.send(data);
          }, timestamp - now);
          else p2.proxy.send(data);
        } else this.open().then(function() {
          self2.send(data, timestamp);
        }, _nop);
      };
      Object.freeze(this);
    }
    function _OutputProxy(id2, name, man, ver) {
      this.id = id2;
      this.name = name;
      this.man = man;
      this.ver = ver;
      this.connected = true;
      this.ports = [];
      this.pending = [];
      this.proxy = void 0;
    }
    _OutputProxy.prototype.open = function() {
      var self2 = this;
      return new Promise2(function(resolve2, reject) {
        var i3;
        if (self2.proxy || !self2.connected) resolve2();
        else {
          self2.pending.push([resolve2, reject]);
          if (self2.pending.length == 1) {
            JZZ2().openMidiOut(self2.name).or(function() {
              for (i3 = 0; i3 < self2.pending.length; i3++) self2.pending[i3][1]();
              self2.pending = [];
            }).and(function() {
              self2.proxy = this;
              for (i3 = 0; i3 < self2.pending.length; i3++) self2.pending[i3][0]();
              self2.pending = [];
            });
          }
        }
      });
    };
    _OutputProxy.prototype.close = function() {
      var i3;
      if (this.proxy) {
        for (i3 = 0; i3 < this.ports.length; i3++) if (this.ports[i3].connection == "open") return;
        this.proxy.close();
        this.proxy = void 0;
      }
    };
    _OutputProxy.prototype.disconnect = function() {
      this.connected = false;
      if (this.proxy) {
        this.proxy.close();
        this.proxy = void 0;
      }
    };
    _OutputProxy.prototype.reconnect = function() {
      var self2 = this;
      var i3, p2;
      var a2 = [];
      this.connected = true;
      for (i3 = 0; i3 < _wma.length; i3++) {
        p2 = _wma[i3].outputs.get(this.id);
        if (p2.connection == "closed") _statechange(p2, _wma[i3]);
        else a2.push([p2, _wma[i3]]);
      }
      if (a2.length) {
        JZZ2()._openMidiOutNR(self2.name).or(function() {
          for (i3 = 0; i3 < a2.length; i3++) a2[i3][0].close();
        }).and(function() {
          self2.proxy = this;
          for (i3 = 0; i3 < a2.length; i3++) _statechange(a2[i3][0], a2[i3][1]);
        });
      }
    };
    function _Maplike(data) {
      this.has = function(id2) {
        return data.hasOwnProperty(id2) && data[id2].connected;
      };
      this.keys = function() {
        try {
          var m3 = /* @__PURE__ */ new Map();
          for (var id2 in data) if (this.has(id2)) m3.set(id2, this.get(id2));
          return m3.keys();
        } catch (e2) {
        }
      };
      this.values = function() {
        try {
          var m3 = /* @__PURE__ */ new Map();
          for (var id2 in data) if (this.has(id2)) m3.set(id2, this.get(id2));
          return m3.values();
        } catch (e2) {
        }
      };
      this.entries = function() {
        try {
          var m3 = /* @__PURE__ */ new Map();
          for (var id2 in data) if (this.has(id2)) m3.set(id2, this.get(id2));
          return m3.entries();
        } catch (e2) {
        }
      };
      this.forEach = function(fun, self2) {
        if (typeof self2 == "undefined") self2 = this;
        for (var id2 in data) if (this.has(id2)) fun.call(self2, this.get(id2), id2, this);
      };
      Object.defineProperty(this, "size", {
        get: function() {
          var len = 0;
          for (var id2 in data) if (this.has(id2)) len++;
          return len;
        },
        enumerable: true
      });
    }
    function MIDIInputMap(_access, _inputs) {
      this.get = function(id2) {
        if (_inputMap.hasOwnProperty(id2) && _inputMap[id2].connected) {
          if (!_inputs[id2]) {
            _inputs[id2] = new MIDIInput(_access, _inputMap[id2]);
            _inputMap[id2].ports.push([_inputs[id2], _access.sysexEnabled]);
          }
          return _inputs[id2];
        }
      };
      Object.freeze(this);
    }
    MIDIInputMap.prototype = new _Maplike(_inputMap);
    MIDIInputMap.prototype.constructor = MIDIInputMap;
    function MIDIOutputMap(_access, _outputs) {
      this.get = function(id2) {
        if (_outputMap.hasOwnProperty(id2) && _outputMap[id2].connected) {
          if (!_outputs[id2]) {
            _outputs[id2] = new MIDIOutput(_access, _outputMap[id2]);
            _outputMap[id2].ports.push([_outputs[id2], _access.sysexEnabled]);
          }
          return _outputs[id2];
        }
      };
      Object.freeze(this);
    }
    MIDIOutputMap.prototype = new _Maplike(_outputMap);
    MIDIOutputMap.prototype.constructor = MIDIOutputMap;
    function _wm_watch(x3) {
      var i3, k3, p2, a2;
      for (i3 = 0; i3 < x3.inputs.added.length; i3++) {
        p2 = x3.inputs.added[i3];
        if (!_inputMap.hasOwnProperty(p2.id)) _inputMap[p2.id] = new _InputProxy(p2.id, p2.name, p2.manufacturer, p2.version);
        _inputMap[p2.id].reconnect();
      }
      for (i3 = 0; i3 < x3.outputs.added.length; i3++) {
        p2 = x3.outputs.added[i3];
        if (!_outputMap.hasOwnProperty(p2.id)) _outputMap[p2.id] = new _OutputProxy(p2.id, p2.name, p2.manufacturer, p2.version);
        _outputMap[p2.id].reconnect();
      }
      for (i3 = 0; i3 < x3.inputs.removed.length; i3++) {
        p2 = x3.inputs.removed[i3];
        if (_inputMap.hasOwnProperty(p2.id)) {
          a2 = [];
          for (k3 = 0; k3 < _wma.length; k3++) a2.push([_wma[k3].inputs.get(p2.id), _wma[k3]]);
          _inputMap[p2.id].disconnect();
          for (k3 = 0; k3 < a2.length; k3++) _statechange(a2[k3][0], a2[k3][1]);
        }
      }
      for (i3 = 0; i3 < x3.outputs.removed.length; i3++) {
        p2 = x3.outputs.removed[i3];
        if (_outputMap.hasOwnProperty(p2.id)) {
          a2 = [];
          for (k3 = 0; k3 < _wma.length; k3++) a2.push([_wma[k3].outputs.get(p2.id), _wma[k3]]);
          _outputMap[p2.id].disconnect();
          for (k3 = 0; k3 < a2.length; k3++) _statechange(a2[k3][0], a2[k3][1]);
        }
      }
    }
    function MIDIAccess(sysex) {
      var _inputs = {};
      var _outputs = {};
      var _onstatechange = null;
      var self2 = this;
      this.sysexEnabled = sysex;
      this.inputs = new MIDIInputMap(self2, _inputs);
      this.outputs = new MIDIOutputMap(self2, _outputs);
      Object.defineProperty(this, "onstatechange", {
        get: function() {
          return _onstatechange;
        },
        set: function(f3) {
          _onstatechange = _func(f3) ? f3 : null;
        },
        enumerable: true
      });
      Object.freeze(this);
      var i3;
      var p2;
      var info = _jzz._info;
      for (i3 = 0; i3 < info.inputs.length; i3++) {
        p2 = info.inputs[i3];
        if (!_inputMap.hasOwnProperty(p2.id)) _inputMap[p2.id] = new _InputProxy(p2.id, p2.name, p2.manufacturer, p2.version);
      }
      for (i3 = 0; i3 < info.outputs.length; i3++) {
        p2 = info.outputs[i3];
        if (!_outputMap.hasOwnProperty(p2.id)) _outputMap[p2.id] = new _OutputProxy(p2.id, p2.name, p2.manufacturer, p2.version);
      }
      if (!_wma.length) JZZ2().onChange(_wm_watch);
      _wma.push(this);
    }
    JZZ2.requestMIDIAccess = function(opt) {
      return new Promise2(function(resolve2, reject) {
        JZZ2.JZZ(opt).or(function() {
        }).and(function() {
          var sysex = !!(opt && opt.sysex);
          if (sysex && !this.info().sysex) reject(new DOMException("SecurityError", "Sysex is not allowed", 18));
          else {
            var wma = new MIDIAccess(sysex);
            resolve2(wma);
          }
        });
      });
    };
    if (typeof navigator !== "undefined" && !navigator.requestMIDIAccess) navigator.requestMIDIAccess = JZZ2.requestMIDIAccess;
    JZZ2.close = function() {
      if (_engine._close) _engine._close();
    };
    return JZZ2;
  });
})(JZZ$1);
var JZZExports = JZZ$1.exports;
const JZZ = /* @__PURE__ */ getDefaultExportFromCjs(JZZExports);
var __getOwnPropDesc$e = Object.getOwnPropertyDescriptor;
var __decorateClass$e = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$e(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
let EasyMidiAdapter = class {
  input = null;
  currentDevice = null;
  handlers = /* @__PURE__ */ new Set();
  jzzInitialized = false;
  async getDevices() {
    try {
      await this.ensureInitialized();
      const info = await JZZ().info();
      const devices = info.inputs.map((input, index) => ({
        name: input.name,
        id: index.toString()
      }));
      return success(devices);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to get MIDI devices: ${errorMessage}`));
    }
  }
  async openDevice(deviceName) {
    try {
      if (this.input) {
        this.closeDevice();
      }
      await this.ensureInitialized();
      this.input = await JZZ().openMidiIn(deviceName);
      this.input.connect((msg) => {
        this.handleMidiMessage(msg);
      });
      this.currentDevice = deviceName;
      console.log(`MIDI device opened: ${deviceName}`);
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to open MIDI device: ${errorMessage}`));
    }
  }
  closeDevice() {
    try {
      if (this.input) {
        this.input.close();
        this.input = null;
        this.currentDevice = null;
      }
      console.log("MIDI device closed");
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to close MIDI device: ${errorMessage}`));
    }
  }
  getCurrentDevice() {
    return this.currentDevice;
  }
  isDeviceOpen() {
    return this.input !== null;
  }
  onMessage(handler) {
    this.handlers.add(handler);
  }
  offMessage(handler) {
    this.handlers.delete(handler);
  }
  removeAllHandlers() {
    this.handlers.clear();
  }
  async ensureInitialized() {
    if (!this.jzzInitialized) {
      await JZZ();
      this.jzzInitialized = true;
    }
  }
  handleMidiMessage(msg) {
    const data = msg.slice();
    if (data.length < 2) return;
    const status = data[0];
    const type2 = status & 240;
    const channel = (status & 15) + 1;
    let midiMessage = null;
    switch (type2) {
      case 144:
        if (data[2] > 0) {
          midiMessage = MidiMessage.note(data[1], data[2], channel);
        } else {
          midiMessage = MidiMessage.note(data[1], 0, channel);
        }
        break;
      case 128:
        midiMessage = MidiMessage.note(data[1], 0, channel);
        break;
      case 176:
        midiMessage = MidiMessage.cc(data[1], data[2], channel);
        break;
      case 192:
        midiMessage = MidiMessage.programChange(data[1], channel);
        break;
    }
    if (midiMessage) {
      this.notifyHandlers(midiMessage);
    }
  }
  notifyHandlers(message) {
    this.handlers.forEach((handler) => {
      try {
        handler(message);
      } catch (error2) {
        console.error("Error in MIDI handler:", error2);
      }
    });
  }
};
EasyMidiAdapter = __decorateClass$e([
  Kt()
], EasyMidiAdapter);
const typeTags = {
  s: "string",
  f: "float",
  i: "integer",
  b: "blob"
};
class Argument {
  constructor(type2, value) {
    this.type = type2;
    this.value = value;
  }
}
class Message {
  constructor(address, ...args) {
    this.oscType = "message";
    this.address = address;
    this.args = args;
  }
  append(arg) {
    let argOut;
    switch (typeof arg) {
      case "object":
        if (arg instanceof Array) {
          arg.forEach((a2) => this.append(a2));
        } else if (arg.type) {
          if (typeTags[arg.type]) arg.type = typeTags[arg.type];
          this.args.push(arg);
        } else {
          throw new Error(`don't know how to encode object ${arg}`);
        }
        break;
      case "number":
        if (Math.floor(arg) === arg) {
          argOut = new Argument("integer", arg);
        } else {
          argOut = new Argument("float", arg);
        }
        break;
      case "string":
        argOut = new Argument("string", arg);
        break;
      case "boolean":
        argOut = new Argument("boolean", arg);
        break;
      default:
        throw new Error(`don't know how to encode ${arg}`);
    }
    if (argOut) this.args.push(argOut);
  }
}
var lib = {};
var oscUtilities = {};
var binpack = { exports: {} };
var hasRequiredBinpack;
function requireBinpack() {
  if (hasRequiredBinpack) return binpack.exports;
  hasRequiredBinpack = 1;
  (function(module) {
    var sizeOfType = function(t2) {
      if (t2[0] === "U") {
        t2 = t2.slice(1);
      }
      return {
        "Float32": 4,
        "Float64": 8,
        "Int8": 1,
        "Int16": 2,
        "Int32": 4,
        "Int64": 8
      }[t2];
    };
    var endianConv = function(e2, t2) {
      if (t2[t2.length - 1] === "8")
        return "";
      if (e2 === "big") {
        return "BE";
      }
      return "LE";
    };
    var addBindings = function(binpackTypename, nodeTypename) {
      if (!(typeof nodeTypename !== "undefined" && nodeTypename !== null)) {
        nodeTypename = binpackTypename;
      }
      module.exports["pack" + binpackTypename] = function(num, endian) {
        b = new Buffer(sizeOfType(binpackTypename));
        b["write" + nodeTypename + endianConv(endian, binpackTypename)](num, 0, true);
        return b;
      };
      module.exports["unpack" + binpackTypename] = function(buff, endian) {
        return buff["read" + nodeTypename + endianConv(endian, binpackTypename)](0);
      };
    };
    var addIntBindings = function(n) {
      addBindings("Int" + n);
      addBindings("UInt" + n);
    };
    addIntBindings(8);
    addIntBindings(16);
    addIntBindings(32);
    twoToThe32 = Math.pow(2, 32);
    var read64 = function(unsigned) {
      return function(buff, endian) {
        var e2 = endianConv(endian, "");
        var u2 = unsigned ? "U" : "";
        var low, high;
        if (e2 === "LE") {
          low = buff.readUInt32LE(0);
          high = buff["read" + u2 + "Int32LE"](4);
        } else {
          low = buff.readUInt32BE(4);
          high = buff["read" + u2 + "Int32BE"](0);
        }
        return high * twoToThe32 + low;
      };
    };
    var write64 = function(unsigned) {
      return function(num, endian) {
        var e2 = endianConv(endian, "");
        var u2 = unsigned ? "U" : "";
        var b2 = new Buffer(8);
        var high = Math.floor(num / twoToThe32);
        var low = Math.floor(num - high * twoToThe32);
        if (e2 == "LE") {
          b2.writeUInt32LE(low, 0, true);
          b2["write" + u2 + "Int32LE"](high, 4, true);
        } else {
          b2.writeUInt32BE(low, 4, true);
          b2["write" + u2 + "Int32BE"](high, 0, true);
        }
        return b2;
      };
    };
    module.exports.unpackInt64 = read64(false);
    module.exports.unpackUInt64 = read64(true);
    module.exports.packInt64 = write64(false);
    module.exports.packUInt64 = write64(true);
    addBindings("Float32", "Float");
    addBindings("Float64", "Double");
  })(binpack);
  return binpack.exports;
}
var hasRequiredOscUtilities;
function requireOscUtilities() {
  if (hasRequiredOscUtilities) return oscUtilities;
  hasRequiredOscUtilities = 1;
  (function(exports$1) {
    (function() {
      var IsArray, StrictError, TWO_POW_32, UNIX_EPOCH, binpack2, getArrayArg, isOscBundleBuffer, makeTimetag, mapBundleList, oscTypeCodes, padding, toOscTypeAndArgs, hasProp = {}.hasOwnProperty;
      binpack2 = requireBinpack();
      exports$1.concat = function(buffers) {
        var buffer, copyTo, destBuffer, j2, k2, l2, len, len1, len2, sumLength;
        if (!IsArray(buffers)) {
          throw new Error("concat must take an array of buffers");
        }
        for (j2 = 0, len = buffers.length; j2 < len; j2++) {
          buffer = buffers[j2];
          if (!Buffer.isBuffer(buffer)) {
            throw new Error("concat must take an array of buffers");
          }
        }
        sumLength = 0;
        for (k2 = 0, len1 = buffers.length; k2 < len1; k2++) {
          buffer = buffers[k2];
          sumLength += buffer.length;
        }
        destBuffer = new Buffer(sumLength);
        copyTo = 0;
        for (l2 = 0, len2 = buffers.length; l2 < len2; l2++) {
          buffer = buffers[l2];
          buffer.copy(destBuffer, copyTo);
          copyTo += buffer.length;
        }
        return destBuffer;
      };
      exports$1.toOscString = function(str, strict) {
        var j2, nullIndex, ref2;
        if (!(typeof str === "string")) {
          throw new Error("can't pack a non-string into an osc-string");
        }
        nullIndex = str.indexOf("\0");
        if (nullIndex !== -1 && strict) {
          throw StrictError("Can't pack an osc-string that contains NULL characters");
        }
        if (nullIndex !== -1) {
          str = str.slice(0, nullIndex);
        }
        for (j2 = 0, ref2 = padding(str); 0 <= ref2 ? j2 < ref2 : j2 > ref2; 0 <= ref2 ? ++j2 : --j2) {
          str += "\0";
        }
        return new Buffer(str);
      };
      exports$1.splitOscString = function(buffer, strict) {
        var i2, j2, nullIndex, rawStr, ref2, ref1, rest, splitPoint, str;
        if (!Buffer.isBuffer(buffer)) {
          throw StrictError("Can't split something that isn't a buffer");
        }
        rawStr = buffer.toString("utf8");
        nullIndex = rawStr.indexOf("\0");
        if (nullIndex === -1) {
          if (strict) {
            throw new Error("All osc-strings must contain a null character");
          }
          return {
            string: rawStr,
            rest: new Buffer(0)
          };
        }
        str = rawStr.slice(0, nullIndex);
        splitPoint = Buffer.byteLength(str) + padding(str);
        if (strict && splitPoint > buffer.length) {
          throw StrictError("Not enough padding for osc-string");
        }
        if (strict) {
          for (i2 = j2 = ref2 = Buffer.byteLength(str), ref1 = splitPoint; ref2 <= ref1 ? j2 < ref1 : j2 > ref1; i2 = ref2 <= ref1 ? ++j2 : --j2) {
            if (buffer[i2] !== 0) {
              throw StrictError("Not enough or incorrect padding for osc-string");
            }
          }
        }
        rest = buffer.slice(splitPoint, buffer.length);
        return {
          string: str,
          rest
        };
      };
      exports$1.splitInteger = function(buffer, type2) {
        var bytes, rest, value;
        if (type2 == null) {
          type2 = "Int32";
        }
        bytes = binpack2["pack" + type2](0).length;
        if (buffer.length < bytes) {
          throw new Error("buffer is not big enough for integer type");
        }
        value = binpack2["unpack" + type2](buffer.slice(0, bytes), "big");
        rest = buffer.slice(bytes, buffer.length);
        return {
          integer: value,
          rest
        };
      };
      exports$1.splitTimetag = function(buffer) {
        var a2, b2, bytes, c2, d2, fractional, rest, seconds, type2;
        type2 = "UInt32";
        bytes = binpack2["pack" + type2](0).length;
        if (buffer.length < bytes * 2) {
          throw new Error("buffer is not big enough to contain a timetag");
        }
        a2 = 0;
        b2 = bytes;
        seconds = binpack2["unpack" + type2](buffer.slice(a2, b2), "big");
        c2 = bytes;
        d2 = bytes + bytes;
        fractional = binpack2["unpack" + type2](buffer.slice(c2, d2), "big");
        rest = buffer.slice(d2, buffer.length);
        return {
          timetag: [seconds, fractional],
          rest
        };
      };
      UNIX_EPOCH = 2208988800;
      TWO_POW_32 = 4294967296;
      exports$1.dateToTimetag = function(date) {
        return exports$1.timestampToTimetag(date.getTime() / 1e3);
      };
      exports$1.timestampToTimetag = function(secs) {
        var fracSeconds, wholeSecs;
        wholeSecs = Math.floor(secs);
        fracSeconds = secs - wholeSecs;
        return makeTimetag(wholeSecs, fracSeconds);
      };
      exports$1.timetagToTimestamp = function(timetag) {
        var seconds;
        seconds = timetag[0] + exports$1.ntpToFractionalSeconds(timetag[1]);
        return seconds - UNIX_EPOCH;
      };
      makeTimetag = function(unixseconds, fracSeconds) {
        var ntpFracs, ntpSecs;
        ntpSecs = unixseconds + UNIX_EPOCH;
        ntpFracs = Math.round(TWO_POW_32 * fracSeconds);
        return [ntpSecs, ntpFracs];
      };
      exports$1.timetagToDate = function(timetag) {
        var date, dd, fracs, fractional, seconds;
        seconds = timetag[0], fractional = timetag[1];
        seconds = seconds - UNIX_EPOCH;
        fracs = exports$1.ntpToFractionalSeconds(fractional);
        date = /* @__PURE__ */ new Date();
        date.setTime(seconds * 1e3 + fracs * 1e3);
        dd = /* @__PURE__ */ new Date();
        dd.setUTCFullYear(date.getUTCFullYear());
        dd.setUTCMonth(date.getUTCMonth());
        dd.setUTCDate(date.getUTCDate());
        dd.setUTCHours(date.getUTCHours());
        dd.setUTCMinutes(date.getUTCMinutes());
        dd.setUTCSeconds(date.getUTCSeconds());
        dd.setUTCMilliseconds(fracs * 1e3);
        return dd;
      };
      exports$1.deltaTimetag = function(seconds, now) {
        var n;
        n = (now != null ? now : /* @__PURE__ */ new Date()) / 1e3;
        return exports$1.timestampToTimetag(n + seconds);
      };
      exports$1.ntpToFractionalSeconds = function(fracSeconds) {
        return parseFloat(fracSeconds) / TWO_POW_32;
      };
      exports$1.toTimetagBuffer = function(timetag) {
        var high, low, type2;
        if (typeof timetag === "number") {
          timetag = exports$1.timestampToTimetag(timetag);
        } else if (typeof timetag === "object" && "getTime" in timetag) {
          timetag = exports$1.dateToTimetag(timetag);
        } else if (timetag.length !== 2) {
          throw new Error("Invalid timetag" + timetag);
        }
        type2 = "UInt32";
        high = binpack2["pack" + type2](timetag[0], "big");
        low = binpack2["pack" + type2](timetag[1], "big");
        return exports$1.concat([high, low]);
      };
      exports$1.toIntegerBuffer = function(number, type2) {
        if (type2 == null) {
          type2 = "Int32";
        }
        if (typeof number !== "number") {
          throw new Error("cannot pack a non-number into an integer buffer");
        }
        return binpack2["pack" + type2](number, "big");
      };
      oscTypeCodes = {
        s: {
          representation: "string",
          split: function(buffer, strict) {
            var split;
            split = exports$1.splitOscString(buffer, strict);
            return {
              value: split.string,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "string") {
              throw new Error("expected string");
            }
            return exports$1.toOscString(value, strict);
          }
        },
        i: {
          representation: "integer",
          split: function(buffer, strict) {
            var split;
            split = exports$1.splitInteger(buffer);
            return {
              value: split.integer,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return exports$1.toIntegerBuffer(value);
          }
        },
        t: {
          representation: "timetag",
          split: function(buffer, strict) {
            var split;
            split = exports$1.splitTimetag(buffer);
            return {
              value: split.timetag,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            return exports$1.toTimetagBuffer(value);
          }
        },
        f: {
          representation: "float",
          split: function(buffer, strict) {
            return {
              value: binpack2.unpackFloat32(buffer.slice(0, 4), "big"),
              rest: buffer.slice(4, buffer.length)
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return binpack2.packFloat32(value, "big");
          }
        },
        d: {
          representation: "double",
          split: function(buffer, strict) {
            return {
              value: binpack2.unpackFloat64(buffer.slice(0, 8), "big"),
              rest: buffer.slice(8, buffer.length)
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return binpack2.packFloat64(value, "big");
          }
        },
        b: {
          representation: "blob",
          split: function(buffer, strict) {
            var length, ref2;
            ref2 = exports$1.splitInteger(buffer), length = ref2.integer, buffer = ref2.rest;
            return {
              value: buffer.slice(0, length),
              rest: buffer.slice(length, buffer.length)
            };
          },
          toArg: function(value, strict) {
            var size;
            if (!Buffer.isBuffer(value)) {
              throw new Error("expected node.js Buffer");
            }
            size = exports$1.toIntegerBuffer(value.length);
            return exports$1.concat([size, value]);
          }
        },
        T: {
          representation: "true",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: true
            };
          },
          toArg: function(value, strict) {
            if (!value && strict) {
              throw new Error("true must be true");
            }
            return new Buffer(0);
          }
        },
        F: {
          representation: "false",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: false
            };
          },
          toArg: function(value, strict) {
            if (value && strict) {
              throw new Error("false must be false");
            }
            return new Buffer(0);
          }
        },
        N: {
          representation: "null",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: null
            };
          },
          toArg: function(value, strict) {
            if (value && strict) {
              throw new Error("null must be false");
            }
            return new Buffer(0);
          }
        },
        I: {
          representation: "bang",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: "bang"
            };
          },
          toArg: function(value, strict) {
            return new Buffer(0);
          }
        }
      };
      exports$1.oscTypeCodeToTypeString = function(code2) {
        var ref2;
        return (ref2 = oscTypeCodes[code2]) != null ? ref2.representation : void 0;
      };
      exports$1.typeStringToOscTypeCode = function(rep) {
        var code2, str;
        for (code2 in oscTypeCodes) {
          if (!hasProp.call(oscTypeCodes, code2)) continue;
          str = oscTypeCodes[code2].representation;
          if (str === rep) {
            return code2;
          }
        }
        return null;
      };
      exports$1.argToTypeCode = function(arg, strict) {
        var code2, value;
        if ((arg != null ? arg.type : void 0) != null && typeof arg.type === "string" && (code2 = exports$1.typeStringToOscTypeCode(arg.type)) != null) {
          return code2;
        }
        value = (arg != null ? arg.value : void 0) != null ? arg.value : arg;
        if (strict && value == null) {
          throw new Error("Argument has no value");
        }
        if (typeof value === "string") {
          return "s";
        }
        if (typeof value === "number") {
          return "f";
        }
        if (Buffer.isBuffer(value)) {
          return "b";
        }
        if (typeof value === "boolean") {
          if (value) {
            return "T";
          } else {
            return "F";
          }
        }
        if (value === null) {
          return "N";
        }
        throw new Error("I don't know what type this is supposed to be.");
      };
      exports$1.splitOscArgument = function(buffer, type2, strict) {
        var osctype;
        osctype = exports$1.typeStringToOscTypeCode(type2);
        if (osctype != null) {
          return oscTypeCodes[osctype].split(buffer, strict);
        } else {
          throw new Error("I don't understand how I'm supposed to unpack " + type2);
        }
      };
      exports$1.toOscArgument = function(value, type2, strict) {
        var osctype;
        osctype = exports$1.typeStringToOscTypeCode(type2);
        if (osctype != null) {
          return oscTypeCodes[osctype].toArg(value, strict);
        } else {
          throw new Error("I don't know how to pack " + type2);
        }
      };
      exports$1.fromOscMessage = function(buffer, strict) {
        var address, arg, args, arrayStack, built, j2, len, ref2, ref1, type2, typeString, types2;
        ref2 = exports$1.splitOscString(buffer, strict), address = ref2.string, buffer = ref2.rest;
        if (strict && address[0] !== "/") {
          throw StrictError("addresses must start with /");
        }
        if (!buffer.length) {
          return {
            address,
            args: []
          };
        }
        ref1 = exports$1.splitOscString(buffer, strict), types2 = ref1.string, buffer = ref1.rest;
        if (types2[0] !== ",") {
          if (strict) {
            throw StrictError("Argument lists must begin with ,");
          }
          return {
            address,
            args: []
          };
        }
        types2 = types2.slice(1, +types2.length + 1 || 9e9);
        args = [];
        arrayStack = [args];
        for (j2 = 0, len = types2.length; j2 < len; j2++) {
          type2 = types2[j2];
          if (type2 === "[") {
            arrayStack.push([]);
            continue;
          }
          if (type2 === "]") {
            if (arrayStack.length <= 1) {
              if (strict) {
                throw new StrictError("Mismatched ']' character.");
              }
            } else {
              built = arrayStack.pop();
              arrayStack[arrayStack.length - 1].push({
                type: "array",
                value: built
              });
            }
            continue;
          }
          typeString = exports$1.oscTypeCodeToTypeString(type2);
          if (typeString == null) {
            throw new Error("I don't understand the argument code " + type2);
          }
          arg = exports$1.splitOscArgument(buffer, typeString, strict);
          if (arg != null) {
            buffer = arg.rest;
          }
          arrayStack[arrayStack.length - 1].push({
            type: typeString,
            value: arg != null ? arg.value : void 0
          });
        }
        if (arrayStack.length !== 1 && strict) {
          throw new StrictError("Mismatched '[' character");
        }
        return {
          address,
          args,
          oscType: "message"
        };
      };
      exports$1.fromOscBundle = function(buffer, strict) {
        var bundleTag, convertedElems, ref2, ref1, timetag;
        ref2 = exports$1.splitOscString(buffer, strict), bundleTag = ref2.string, buffer = ref2.rest;
        if (bundleTag !== "#bundle") {
          throw new Error("osc-bundles must begin with #bundle");
        }
        ref1 = exports$1.splitTimetag(buffer), timetag = ref1.timetag, buffer = ref1.rest;
        convertedElems = mapBundleList(buffer, function(buffer2) {
          return exports$1.fromOscPacket(buffer2, strict);
        });
        return {
          timetag,
          elements: convertedElems,
          oscType: "bundle"
        };
      };
      exports$1.fromOscPacket = function(buffer, strict) {
        if (isOscBundleBuffer(buffer, strict)) {
          return exports$1.fromOscBundle(buffer, strict);
        } else {
          return exports$1.fromOscMessage(buffer, strict);
        }
      };
      getArrayArg = function(arg) {
        if (IsArray(arg)) {
          return arg;
        } else if ((arg != null ? arg.type : void 0) === "array" && IsArray(arg != null ? arg.value : void 0)) {
          return arg.value;
        } else if (arg != null && arg.type == null && IsArray(arg.value)) {
          return arg.value;
        } else {
          return null;
        }
      };
      toOscTypeAndArgs = function(argList, strict) {
        var arg, buff, j2, len, oscargs, osctype, ref2, thisArgs, thisType, typeCode, value;
        osctype = "";
        oscargs = [];
        for (j2 = 0, len = argList.length; j2 < len; j2++) {
          arg = argList[j2];
          if (getArrayArg(arg) != null) {
            ref2 = toOscTypeAndArgs(getArrayArg(arg), strict), thisType = ref2[0], thisArgs = ref2[1];
            osctype += "[" + thisType + "]";
            oscargs = oscargs.concat(thisArgs);
            continue;
          }
          typeCode = exports$1.argToTypeCode(arg, strict);
          if (typeCode != null) {
            value = arg != null ? arg.value : void 0;
            if (value === void 0) {
              value = arg;
            }
            buff = exports$1.toOscArgument(value, exports$1.oscTypeCodeToTypeString(typeCode), strict);
            if (buff != null) {
              oscargs.push(buff);
              osctype += typeCode;
            }
          }
        }
        return [osctype, oscargs];
      };
      exports$1.toOscMessage = function(message, strict) {
        var address, allArgs, args, old_arg, oscaddr, oscargs, osctype, ref2;
        address = (message != null ? message.address : void 0) != null ? message.address : message;
        if (typeof address !== "string") {
          throw new Error("message must contain an address");
        }
        args = message != null ? message.args : void 0;
        if (args === void 0) {
          args = [];
        }
        if (!IsArray(args)) {
          old_arg = args;
          args = [];
          args[0] = old_arg;
        }
        oscaddr = exports$1.toOscString(address, strict);
        ref2 = toOscTypeAndArgs(args, strict), osctype = ref2[0], oscargs = ref2[1];
        osctype = "," + osctype;
        allArgs = exports$1.concat(oscargs);
        osctype = exports$1.toOscString(osctype);
        return exports$1.concat([oscaddr, osctype, allArgs]);
      };
      exports$1.toOscBundle = function(bundle, strict) {
        var allElems, buff, elem, elements, elemstr, j2, len, oscBundleTag, oscElems, oscTimeTag, ref2, ref1, size, timetag;
        if (strict && (bundle != null ? bundle.timetag : void 0) == null) {
          throw StrictError("bundles must have timetags.");
        }
        timetag = (ref2 = bundle != null ? bundle.timetag : void 0) != null ? ref2 : /* @__PURE__ */ new Date();
        elements = (ref1 = bundle != null ? bundle.elements : void 0) != null ? ref1 : [];
        if (!IsArray(elements)) {
          elemstr = elements;
          elements = [];
          elements.push(elemstr);
        }
        oscBundleTag = exports$1.toOscString("#bundle");
        oscTimeTag = exports$1.toTimetagBuffer(timetag);
        oscElems = [];
        for (j2 = 0, len = elements.length; j2 < len; j2++) {
          elem = elements[j2];
          try {
            buff = exports$1.toOscPacket(elem, strict);
            size = exports$1.toIntegerBuffer(buff.length);
            oscElems.push(exports$1.concat([size, buff]));
          } catch (error2) {
          }
        }
        allElems = exports$1.concat(oscElems);
        return exports$1.concat([oscBundleTag, oscTimeTag, allElems]);
      };
      exports$1.toOscPacket = function(bundleOrMessage, strict) {
        if ((bundleOrMessage != null ? bundleOrMessage.oscType : void 0) != null) {
          if (bundleOrMessage.oscType === "bundle") {
            return exports$1.toOscBundle(bundleOrMessage, strict);
          }
          return exports$1.toOscMessage(bundleOrMessage, strict);
        }
        if ((bundleOrMessage != null ? bundleOrMessage.timetag : void 0) != null || (bundleOrMessage != null ? bundleOrMessage.elements : void 0) != null) {
          return exports$1.toOscBundle(bundleOrMessage, strict);
        }
        return exports$1.toOscMessage(bundleOrMessage, strict);
      };
      exports$1.applyMessageTranformerToBundle = function(transform) {
        return function(buffer) {
          var bundleTagBuffer, copyIndex, elem, elems, j2, k2, len, len1, lengthBuff, outBuffer, ref2, string, timetagBuffer, totalLength;
          ref2 = exports$1.splitOscString(buffer), string = ref2.string, buffer = ref2.rest;
          if (string !== "#bundle") {
            throw new Error("osc-bundles must begin with #bundle");
          }
          bundleTagBuffer = exports$1.toOscString(string);
          timetagBuffer = buffer.slice(0, 8);
          buffer = buffer.slice(8, buffer.length);
          elems = mapBundleList(buffer, function(buffer2) {
            return exports$1.applyTransform(buffer2, transform, exports$1.applyMessageTranformerToBundle(transform));
          });
          totalLength = bundleTagBuffer.length + timetagBuffer.length;
          for (j2 = 0, len = elems.length; j2 < len; j2++) {
            elem = elems[j2];
            totalLength += 4 + elem.length;
          }
          outBuffer = new Buffer(totalLength);
          bundleTagBuffer.copy(outBuffer, 0);
          timetagBuffer.copy(outBuffer, bundleTagBuffer.length);
          copyIndex = bundleTagBuffer.length + timetagBuffer.length;
          for (k2 = 0, len1 = elems.length; k2 < len1; k2++) {
            elem = elems[k2];
            lengthBuff = exports$1.toIntegerBuffer(elem.length);
            lengthBuff.copy(outBuffer, copyIndex);
            copyIndex += 4;
            elem.copy(outBuffer, copyIndex);
            copyIndex += elem.length;
          }
          return outBuffer;
        };
      };
      exports$1.applyTransform = function(buffer, mTransform, bundleTransform) {
        if (bundleTransform == null) {
          bundleTransform = exports$1.applyMessageTranformerToBundle(mTransform);
        }
        if (isOscBundleBuffer(buffer)) {
          return bundleTransform(buffer);
        } else {
          return mTransform(buffer);
        }
      };
      exports$1.addressTransform = function(transform) {
        return function(buffer) {
          var ref2, rest, string;
          ref2 = exports$1.splitOscString(buffer), string = ref2.string, rest = ref2.rest;
          string = transform(string);
          return exports$1.concat([exports$1.toOscString(string), rest]);
        };
      };
      exports$1.messageTransform = function(transform) {
        return function(buffer) {
          var message;
          message = exports$1.fromOscMessage(buffer);
          return exports$1.toOscMessage(transform(message));
        };
      };
      IsArray = Array.isArray;
      StrictError = function(str) {
        return new Error("Strict Error: " + str);
      };
      padding = function(str) {
        var bufflength;
        bufflength = Buffer.byteLength(str);
        return 4 - bufflength % 4;
      };
      isOscBundleBuffer = function(buffer, strict) {
        var string;
        string = exports$1.splitOscString(buffer, strict).string;
        return string === "#bundle";
      };
      mapBundleList = function(buffer, func) {
        var elem, elems, j2, len, nonNullElems, size, thisElemBuffer;
        elems = function() {
          var ref2, results;
          results = [];
          while (buffer.length) {
            ref2 = exports$1.splitInteger(buffer), size = ref2.integer, buffer = ref2.rest;
            if (size > buffer.length) {
              throw new Error("Invalid bundle list: size of element is bigger than buffer");
            }
            thisElemBuffer = buffer.slice(0, size);
            buffer = buffer.slice(size, buffer.length);
            try {
              results.push(func(thisElemBuffer));
            } catch (error2) {
              results.push(null);
            }
          }
          return results;
        }();
        nonNullElems = [];
        for (j2 = 0, len = elems.length; j2 < len; j2++) {
          elem = elems[j2];
          if (elem != null) {
            nonNullElems.push(elem);
          }
        }
        return nonNullElems;
      };
    }).call(commonjsGlobal);
  })(oscUtilities);
  return oscUtilities;
}
(function() {
  var utils2;
  utils2 = requireOscUtilities();
  lib.fromBuffer = function(buffer, strict) {
    if (buffer instanceof ArrayBuffer) {
      buffer = new Buffer(new Uint8Array(buffer));
    } else if (buffer instanceof Uint8Array) {
      buffer = new Buffer(buffer);
    }
    return utils2.fromOscPacket(buffer, strict);
  };
  lib.toBuffer = function(object, strict, opt) {
    if (typeof object === "string")
      return utils2.toOscPacket({ "address": object, "args": strict }, opt);
    return utils2.toOscPacket(object, strict);
  };
  lib.applyAddressTransform = function(buffer, transform) {
    return utils2.applyTransform(buffer, utils2.addressTransform(transform));
  };
  lib.applyMessageTransform = function(buffer, transform) {
    return utils2.applyTransform(buffer, utils2.messageTransform(transform));
  };
  lib.timetagToDate = utils2.timetagToDate;
  lib.dateToTimetag = utils2.dateToTimetag;
  lib.timetagToTimestamp = utils2.timetagToTimestamp;
  lib.timestampToTimetag = utils2.timestampToTimetag;
}).call(commonjsGlobal);
const { toBuffer } = lib;
class Client {
  constructor(host, port) {
    this.host = host;
    this.port = port;
    this._sock = node_dgram.createSocket({
      type: "udp4",
      reuseAddr: true
    });
  }
  close(cb) {
    this._sock.close(cb);
  }
  send(...args) {
    let message = args[0];
    let callback;
    if (typeof args[args.length - 1] === "function") {
      callback = args.pop();
    } else {
      callback = () => {
      };
    }
    if (message instanceof Array) {
      message = {
        address: message[0],
        args: message.splice(1)
      };
    }
    let mes;
    let buf;
    try {
      switch (typeof message) {
        case "object":
          buf = toBuffer(message);
          this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
          break;
        case "string":
          mes = new Message(args[0]);
          for (let i2 = 1; i2 < args.length; i2++) {
            mes.append(args[i2]);
          }
          buf = toBuffer(mes);
          this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
          break;
        default:
          throw new TypeError("That Message Just Doesn't Seem Right");
      }
    } catch (e2) {
      if (e2.code !== "ERR_SOCKET_DGRAM_NOT_RUNNING") throw e2;
      const error2 = new ReferenceError("Cannot send message on closed socket.");
      error2.code = e2.code;
      callback(error2);
    }
  }
}
var OscConnectionStatus = /* @__PURE__ */ ((OscConnectionStatus2) => {
  OscConnectionStatus2["DISCONNECTED"] = "disconnected";
  OscConnectionStatus2["CONNECTING"] = "connecting";
  OscConnectionStatus2["CONNECTED"] = "connected";
  OscConnectionStatus2["ERROR"] = "error";
  return OscConnectionStatus2;
})(OscConnectionStatus || {});
var __getOwnPropDesc$d = Object.getOwnPropertyDescriptor;
var __decorateClass$d = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$d(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
let NodeOscAdapter = class {
  client = null;
  status = OscConnectionStatus.DISCONNECTED;
  host = "127.0.0.1";
  port = 11e3;
  connect(host, port) {
    try {
      this.host = host;
      this.port = port;
      this.client = new Client(this.host, this.port);
      this.status = OscConnectionStatus.CONNECTED;
      console.log(`OSC connected to ${this.host}:${this.port}`);
      return success(void 0);
    } catch (error2) {
      this.status = OscConnectionStatus.ERROR;
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to connect to OSC: ${errorMessage}`));
    }
  }
  disconnect() {
    try {
      if (this.client) {
        this.client.close();
        this.client = null;
      }
      this.status = OscConnectionStatus.DISCONNECTED;
      console.log("OSC disconnected");
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to disconnect from OSC: ${errorMessage}`));
    }
  }
  send(command) {
    try {
      if (!this.client) {
        return failure(new Error("OSC client not connected"));
      }
      const args = command.parameters.map((param) => {
        if (typeof param === "boolean") {
          return param ? 1 : 0;
        }
        return param;
      });
      this.client.send(command.address.path, ...args, (err) => {
        if (err) {
          console.error(`Error sending OSC message: ${err.message}`);
        }
      });
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to send OSC message: ${errorMessage}`));
    }
  }
  isConnected() {
    return this.status === OscConnectionStatus.CONNECTED && this.client !== null;
  }
  getStatus() {
    return this.status;
  }
  async test() {
    try {
      if (!this.isConnected()) {
        return failure(new Error("Not connected to OSC server"));
      }
      this.client.send("/live/test", (err) => {
        if (err) {
          console.error(`Test message error: ${err.message}`);
        }
      });
      return success(true);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`OSC test failed: ${errorMessage}`));
    }
  }
};
NodeOscAdapter = __decorateClass$d([
  Kt()
], NodeOscAdapter);
var __getOwnPropDesc$c = Object.getOwnPropertyDescriptor;
var __decorateClass$c = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$c(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$c = (index, decorator) => (target, key) => decorator(target, key, index);
let OscTrackNameResolver = class {
  // 5 minutes
  constructor(oscService) {
    this.oscService = oscService;
  }
  tracks = [];
  cacheTimestamp = 0;
  CACHE_TTL_MS = 5 * 60 * 1e3;
  async fetchTracks() {
    try {
      if (!this.oscService.isConnected()) {
        return failure(new Error("OSC service not connected"));
      }
      const getTracksCommand = OscCommand.create("/live/song/get/track_names", []);
      const sendResult = this.oscService.send(getTracksCommand);
      if (sendResult.isFailure()) {
        return failure(sendResult.error);
      }
      return failure(
        new Error(
          "Track name fetching requires two-way OSC communication. Please configure tracks manually."
        )
      );
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(new Error(`Failed to fetch tracks: ${errorMessage}`));
    }
  }
  getTracks() {
    return [...this.tracks];
  }
  resolveTrackName(name) {
    const track = this.tracks.find((t2) => t2.name === name);
    if (!track) {
      return failure(new Error(`Track not found: ${name}`));
    }
    return success(track.index);
  }
  resolveTrackIndex(index) {
    const track = this.tracks.find((t2) => t2.index === index);
    if (!track) {
      return failure(new Error(`Track index not found: ${index}`));
    }
    return success(track.name);
  }
  hasCachedTracks() {
    return this.tracks.length > 0;
  }
  clearCache() {
    this.tracks = [];
    this.cacheTimestamp = 0;
  }
  getCacheAge() {
    if (this.cacheTimestamp === 0) {
      return Number.MAX_SAFE_INTEGER;
    }
    return Date.now() - this.cacheTimestamp;
  }
  isCacheExpired(maxAgeMs = this.CACHE_TTL_MS) {
    return this.getCacheAge() > maxAgeMs;
  }
  /**
   * Manually set tracks (for when track names are provided by the UI or config)
   */
  setTracks(tracks) {
    this.tracks = [...tracks];
    this.cacheTimestamp = Date.now();
  }
};
OscTrackNameResolver = __decorateClass$c([
  Kt(),
  __decorateParam$c(0, Yt(TYPES.OscOutputService))
], OscTrackNameResolver);
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto$1.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const native = {
  randomUUID: crypto$1.randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
var __decorateClass$b = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$b(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$b = (index, decorator) => (target, key) => decorator(target, key, index);
let CreateMapping = class {
  constructor(mappingRepository) {
    this.mappingRepository = mappingRepository;
  }
  async execute(input) {
    try {
      const channel = MidiChannel.fromValue(input.trigger.channel);
      const trigger = this.createTrigger(input, channel);
      const command = OscCommand.create(input.command.address, input.command.parameters);
      const id2 = v4();
      const mapping = Mapping.create(
        id2,
        input.name,
        trigger,
        command,
        input.parameterMappings || [],
        input.enabled ?? true
      );
      const saveResult = await this.mappingRepository.save(mapping);
      if (saveResult.isFailure()) {
        return failure(`Failed to save mapping: ${saveResult.error.message}`);
      }
      return success({ mappingId: id2 });
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to create mapping: ${errorMessage}`);
    }
  }
  createTrigger(input, channel) {
    switch (input.trigger.type) {
      case "note":
        if (input.trigger.note === void 0) {
          throw new Error("Note trigger requires note parameter");
        }
        return {
          type: input.trigger.type,
          note: input.trigger.note,
          channel,
          velocityRange: input.trigger.velocityRange
        };
      case "cc":
        if (input.trigger.controller === void 0) {
          throw new Error("CC trigger requires controller parameter");
        }
        return {
          type: input.trigger.type,
          controller: input.trigger.controller,
          channel,
          valueRange: input.trigger.valueRange
        };
      case "program_change":
        if (input.trigger.program === void 0) {
          throw new Error("Program change trigger requires program parameter");
        }
        return {
          type: input.trigger.type,
          program: input.trigger.program,
          channel
        };
      default:
        throw new Error(`Unknown trigger type: ${input.trigger.type}`);
    }
  }
};
CreateMapping = __decorateClass$b([
  Kt(),
  __decorateParam$b(0, Yt(TYPES.MappingRepository))
], CreateMapping);
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorateClass$a = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$a = (index, decorator) => (target, key) => decorator(target, key, index);
let DeleteMapping = class {
  constructor(mappingRepository) {
    this.mappingRepository = mappingRepository;
  }
  async execute(input) {
    try {
      const existsResult = await this.mappingRepository.exists(input.mappingId);
      if (existsResult.isFailure()) {
        return failure(`Failed to check mapping existence: ${existsResult.error.message}`);
      }
      if (!existsResult.value) {
        return failure(`Mapping with ID ${input.mappingId} not found`);
      }
      const deleteResult = await this.mappingRepository.delete(input.mappingId);
      if (deleteResult.isFailure()) {
        return failure(`Failed to delete mapping: ${deleteResult.error.message}`);
      }
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to delete mapping: ${errorMessage}`);
    }
  }
};
DeleteMapping = __decorateClass$a([
  Kt(),
  __decorateParam$a(0, Yt(TYPES.MappingRepository))
], DeleteMapping);
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$9 = (index, decorator) => (target, key) => decorator(target, key, index);
let GetAllMappings = class {
  constructor(mappingRepository) {
    this.mappingRepository = mappingRepository;
  }
  async execute() {
    try {
      const result = await this.mappingRepository.getAll();
      if (result.isFailure()) {
        return failure(`Failed to get mappings: ${result.error.message}`);
      }
      const mappings = result.value.map((mapping) => this.mapToDTO(mapping));
      return success({ mappings });
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to get mappings: ${errorMessage}`);
    }
  }
  mapToDTO(mapping) {
    return {
      id: mapping.id,
      name: mapping.name,
      trigger: {
        ...mapping.trigger,
        channel: mapping.trigger.channel.toJSON()
      },
      command: mapping.command.toJSON(),
      parameterMappings: [...mapping.parameterMappings],
      enabled: mapping.enabled
    };
  }
};
GetAllMappings = __decorateClass$9([
  Kt(),
  __decorateParam$9(0, Yt(TYPES.MappingRepository))
], GetAllMappings);
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$8 = (index, decorator) => (target, key) => decorator(target, key, index);
let UpdateMapping = class {
  constructor(mappingRepository) {
    this.mappingRepository = mappingRepository;
  }
  async execute(input) {
    try {
      const getResult = await this.mappingRepository.getById(input.mappingId);
      if (getResult.isFailure()) {
        return failure(`Failed to get mapping: ${getResult.error.message}`);
      }
      if (!getResult.value) {
        return failure(`Mapping with ID ${input.mappingId} not found`);
      }
      let mapping = getResult.value;
      if (input.name !== void 0) {
        mapping = mapping.withName(input.name);
      }
      if (input.enabled !== void 0) {
        mapping = mapping.withEnabled(input.enabled);
      }
      const updateResult = await this.mappingRepository.update(mapping);
      if (updateResult.isFailure()) {
        return failure(`Failed to update mapping: ${updateResult.error.message}`);
      }
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to update mapping: ${errorMessage}`);
    }
  }
};
UpdateMapping = __decorateClass$8([
  Kt(),
  __decorateParam$8(0, Yt(TYPES.MappingRepository))
], UpdateMapping);
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$7 = (index, decorator) => (target, key) => decorator(target, key, index);
let ProcessMidiInput = class {
  constructor(mappingRepository, oscService, trackResolver) {
    this.mappingRepository = mappingRepository;
    this.oscService = oscService;
    this.trackResolver = trackResolver;
  }
  async execute(message) {
    try {
      const mappingsResult = await this.mappingRepository.getAll();
      if (mappingsResult.isFailure()) {
        return failure(`Failed to get mappings: ${mappingsResult.error.message}`);
      }
      const matchingMappings = mappingsResult.value.filter((mapping) => mapping.matches(message));
      for (const mapping of matchingMappings) {
        let command = mapping.command;
        for (const paramMapping of mapping.parameterMappings) {
          const value = this.resolveParameterValue(paramMapping, message);
          if (value !== null) {
            command = command.withParameter(paramMapping.parameterIndex, value);
          }
        }
        const sendResult = this.oscService.send(command);
        if (sendResult.isFailure()) {
          console.error(`Failed to send OSC command: ${sendResult.error.message}`);
        }
      }
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to process MIDI input: ${errorMessage}`);
    }
  }
  resolveParameterValue(paramMapping, message) {
    switch (paramMapping.substitution) {
      case ParameterSubstitution.NONE:
        return null;
      case ParameterSubstitution.VELOCITY:
        if (message.type === "note") {
          return message.data.velocity;
        } else if (message.type === "cc") {
          return message.data.value;
        }
        return null;
      case ParameterSubstitution.VELOCITY_NORMALIZED:
        if (message.type === "note") {
          return message.data.velocity / 127;
        } else if (message.type === "cc") {
          return message.data.normalizedValue;
        }
        return null;
      case ParameterSubstitution.TRACK_NAME:
        if (paramMapping.trackName) {
          const result = this.trackResolver.resolveTrackName(paramMapping.trackName);
          return result.isSuccess() ? result.value : null;
        }
        return null;
      case ParameterSubstitution.TRACK_INDEX:
        return paramMapping.trackIndex ?? null;
      default:
        return null;
    }
  }
};
ProcessMidiInput = __decorateClass$7([
  Kt(),
  __decorateParam$7(0, Yt(TYPES.MappingRepository)),
  __decorateParam$7(1, Yt(TYPES.OscOutputService)),
  __decorateParam$7(2, Yt(TYPES.TrackNameResolver))
], ProcessMidiInput);
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$6 = (index, decorator) => (target, key) => decorator(target, key, index);
let StartLearnMode = class {
  constructor(midiService, createMapping) {
    this.midiService = midiService;
    this.createMapping = createMapping;
  }
  isLearning = false;
  learnCallback = null;
  pendingCommand = null;
  async execute(input) {
    if (this.isLearning) {
      return failure("Learn mode is already active");
    }
    this.isLearning = true;
    this.pendingCommand = input;
    this.learnCallback = async (message) => {
      await this.handleLearnedMidiMessage(message);
    };
    this.midiService.onMessage(this.learnCallback);
    return success(void 0);
  }
  async handleLearnedMidiMessage(message) {
    if (!this.isLearning || !this.pendingCommand || !this.learnCallback) {
      return;
    }
    this.stopLearning();
    const mappingName = `MIDI ${MidiMessage.toString(message)}  ${this.pendingCommand.commandAddress}`;
    const trigger = this.createTriggerFromMessage(message);
    const createResult = await this.createMapping.execute({
      name: mappingName,
      trigger,
      command: {
        address: this.pendingCommand.commandAddress,
        parameters: this.pendingCommand.commandParameters
      },
      parameterMappings: this.pendingCommand.parameterMappings,
      enabled: true
    });
    if (createResult.isFailure()) {
      console.error("Failed to create learned mapping:", createResult.error);
    }
  }
  createTriggerFromMessage(message) {
    switch (message.type) {
      case "note":
        return {
          type: message.type,
          note: message.data.note,
          channel: message.data.channel
        };
      case "cc":
        return {
          type: message.type,
          controller: message.data.controller,
          channel: message.data.channel
        };
      case "program_change":
        return {
          type: message.type,
          program: message.data.program,
          channel: message.data.channel
        };
    }
  }
  stopLearning() {
    if (this.learnCallback) {
      this.midiService.offMessage(this.learnCallback);
      this.learnCallback = null;
    }
    this.isLearning = false;
    this.pendingCommand = null;
  }
  isActive() {
    return this.isLearning;
  }
  cancel() {
    this.stopLearning();
  }
};
StartLearnMode = __decorateClass$6([
  Kt(),
  __decorateParam$6(0, Yt(TYPES.MidiInputService)),
  __decorateParam$6(1, Yt(TYPES.CreateMapping))
], StartLearnMode);
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$5 = (index, decorator) => (target, key) => decorator(target, key, index);
let SelectMidiDevice = class {
  constructor(midiService, configRepository) {
    this.midiService = midiService;
    this.configRepository = configRepository;
  }
  async execute(input) {
    try {
      if (this.midiService.isDeviceOpen()) {
        const closeResult = this.midiService.closeDevice();
        if (closeResult.isFailure()) {
          return failure(`Failed to close current device: ${closeResult.error.message}`);
        }
      }
      const openResult = this.midiService.openDevice(input.deviceName);
      if (openResult.isFailure()) {
        return failure(`Failed to open device: ${openResult.error.message}`);
      }
      await this.configRepository.setValue("selectedMidiDevice", input.deviceName);
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to select MIDI device: ${errorMessage}`);
    }
  }
};
SelectMidiDevice = __decorateClass$5([
  Kt(),
  __decorateParam$5(0, Yt(TYPES.MidiInputService)),
  __decorateParam$5(1, Yt(TYPES.ConfigRepository))
], SelectMidiDevice);
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$4 = (index, decorator) => (target, key) => decorator(target, key, index);
let GetMidiDevices = class {
  constructor(midiService) {
    this.midiService = midiService;
  }
  async execute() {
    try {
      const devicesResult = await this.midiService.getDevices();
      if (devicesResult.isFailure()) {
        return failure(`Failed to get MIDI devices: ${devicesResult.error.message}`);
      }
      const currentDevice = this.midiService.getCurrentDevice();
      return success({
        devices: devicesResult.value,
        currentDevice
      });
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to get MIDI devices: ${errorMessage}`);
    }
  }
};
GetMidiDevices = __decorateClass$4([
  Kt(),
  __decorateParam$4(0, Yt(TYPES.MidiInputService))
], GetMidiDevices);
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$3 = (index, decorator) => (target, key) => decorator(target, key, index);
let FetchTrackNames = class {
  constructor(trackResolver) {
    this.trackResolver = trackResolver;
  }
  async execute(forceRefresh = false) {
    try {
      if (!forceRefresh && this.trackResolver.hasCachedTracks() && !this.trackResolver.isCacheExpired()) {
        const tracks2 = this.trackResolver.getTracks();
        const cacheAge = this.trackResolver.getCacheAge();
        return success({
          tracks: tracks2.map((t2) => ({ index: t2.index, name: t2.name })),
          cacheAge
        });
      }
      const fetchResult = await this.trackResolver.fetchTracks();
      if (fetchResult.isFailure()) {
        return failure(`Failed to fetch tracks: ${fetchResult.error.message}`);
      }
      const tracks = fetchResult.value.map((t2) => ({
        index: t2.index,
        name: t2.name
      }));
      return success({
        tracks,
        cacheAge: 0
      });
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to fetch track names: ${errorMessage}`);
    }
  }
};
FetchTrackNames = __decorateClass$3([
  Kt(),
  __decorateParam$3(0, Yt(TYPES.TrackNameResolver))
], FetchTrackNames);
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$2 = (index, decorator) => (target, key) => decorator(target, key, index);
let GetConfig = class {
  constructor(configRepository) {
    this.configRepository = configRepository;
  }
  async execute() {
    try {
      const configResult = await this.configRepository.get();
      if (configResult.isFailure()) {
        return failure(`Failed to get config: ${configResult.error.message}`);
      }
      return success(configResult.value);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to get config: ${errorMessage}`);
    }
  }
};
GetConfig = __decorateClass$2([
  Kt(),
  __decorateParam$2(0, Yt(TYPES.ConfigRepository))
], GetConfig);
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam$1 = (index, decorator) => (target, key) => decorator(target, key, index);
let UpdateConfig = class {
  constructor(configRepository) {
    this.configRepository = configRepository;
  }
  async execute(input) {
    try {
      const updateResult = await this.configRepository.update(input);
      if (updateResult.isFailure()) {
        return failure(`Failed to update config: ${updateResult.error.message}`);
      }
      return success(void 0);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to update config: ${errorMessage}`);
    }
  }
};
UpdateConfig = __decorateClass$1([
  Kt(),
  __decorateParam$1(0, Yt(TYPES.ConfigRepository))
], UpdateConfig);
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = decorator(result) || result;
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);
let TestOscConnection = class {
  constructor(oscService) {
    this.oscService = oscService;
  }
  async execute() {
    try {
      const testResult = await this.oscService.test();
      if (testResult.isFailure()) {
        return failure(`OSC connection test failed: ${testResult.error.message}`);
      }
      return success(testResult.value);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      return failure(`Failed to test OSC connection: ${errorMessage}`);
    }
  }
};
TestOscConnection = __decorateClass([
  Kt(),
  __decorateParam(0, Yt(TYPES.OscOutputService))
], TestOscConnection);
function createContainer() {
  const container = new Pt();
  container.bind(TYPES.MappingRepository).to(InMemoryMappingRepository).inSingletonScope();
  container.bind(TYPES.ConfigRepository).to(ElectronStoreConfigRepository).inSingletonScope();
  container.bind(TYPES.MidiInputService).to(EasyMidiAdapter).inSingletonScope();
  container.bind(TYPES.OscOutputService).to(NodeOscAdapter).inSingletonScope();
  container.bind(TYPES.TrackNameResolver).to(OscTrackNameResolver).inSingletonScope();
  container.bind(TYPES.CreateMapping).to(CreateMapping);
  container.bind(TYPES.DeleteMapping).to(DeleteMapping);
  container.bind(TYPES.GetAllMappings).to(GetAllMappings);
  container.bind(TYPES.UpdateMapping).to(UpdateMapping);
  container.bind(TYPES.ProcessMidiInput).to(ProcessMidiInput);
  container.bind(TYPES.StartLearnMode).to(StartLearnMode).inSingletonScope();
  container.bind(TYPES.SelectMidiDevice).to(SelectMidiDevice);
  container.bind(TYPES.GetMidiDevices).to(GetMidiDevices);
  container.bind(TYPES.FetchTrackNames).to(FetchTrackNames);
  container.bind(TYPES.GetConfig).to(GetConfig);
  container.bind(TYPES.UpdateConfig).to(UpdateConfig);
  container.bind(TYPES.TestOscConnection).to(TestOscConnection);
  return container;
}
class TrayController {
  tray = null;
  window = null;
  constructor(window2) {
    this.window = window2;
  }
  create() {
    const iconPath = this.getIconPath();
    const icon = require$$1$2.nativeImage.createFromPath(iconPath);
    this.tray = new require$$1$2.Tray(icon.resize({ width: 16, height: 16 }));
    this.tray.setToolTip("Ableton OSC MIDI Mapper");
    this.updateContextMenu();
    this.tray.on("click", () => {
      this.toggleWindow();
    });
  }
  updateContextMenu() {
    if (!this.tray) return;
    const contextMenu = require$$1$2.Menu.buildFromTemplate([
      {
        label: "Show Window",
        click: () => {
          this.showWindow();
        }
      },
      { type: "separator" },
      {
        label: "Quit",
        click: () => {
          require$$1$2.app.quit();
        }
      }
    ]);
    this.tray.setContextMenu(contextMenu);
  }
  getIconPath() {
    const platformPath = process.platform === "darwin" ? "iconTemplate.png" : "icon.png";
    return require$$0__namespace.join(__dirname, "../../resources", platformPath);
  }
  toggleWindow() {
    if (!this.window) return;
    if (this.window.isVisible()) {
      this.window.hide();
    } else {
      this.showWindow();
    }
  }
  showWindow() {
    if (!this.window) return;
    this.window.show();
    this.window.focus();
  }
  destroy() {
    if (this.tray) {
      this.tray.destroy();
      this.tray = null;
    }
  }
}
class IpcHandlers {
  constructor(container) {
    this.container = container;
  }
  register() {
    require$$1$2.ipcMain.handle("mappings:getAll", async () => {
      const useCase = this.container.get(TYPES.GetAllMappings);
      return await useCase.execute();
    });
    require$$1$2.ipcMain.handle("mappings:create", async (_2, input) => {
      const useCase = this.container.get(TYPES.CreateMapping);
      return await useCase.execute(input);
    });
    require$$1$2.ipcMain.handle("mappings:update", async (_2, input) => {
      const useCase = this.container.get(TYPES.UpdateMapping);
      return await useCase.execute(input);
    });
    require$$1$2.ipcMain.handle("mappings:delete", async (_2, input) => {
      const useCase = this.container.get(TYPES.DeleteMapping);
      return await useCase.execute(input);
    });
    require$$1$2.ipcMain.handle("midi:getDevices", async () => {
      const useCase = this.container.get(TYPES.GetMidiDevices);
      return await useCase.execute();
    });
    require$$1$2.ipcMain.handle("midi:selectDevice", async (_2, input) => {
      const useCase = this.container.get(TYPES.SelectMidiDevice);
      return await useCase.execute(input);
    });
    require$$1$2.ipcMain.handle("learn:start", async (_2, input) => {
      const useCase = this.container.get(TYPES.StartLearnMode);
      return await useCase.execute(input);
    });
    require$$1$2.ipcMain.handle("learn:stop", () => {
      const useCase = this.container.get(TYPES.StartLearnMode);
      useCase.cancel();
      return { success: true };
    });
    require$$1$2.ipcMain.handle("learn:isActive", () => {
      const useCase = this.container.get(TYPES.StartLearnMode);
      return useCase.isActive();
    });
    require$$1$2.ipcMain.handle("tracks:fetch", async (_2, forceRefresh) => {
      const useCase = this.container.get(TYPES.FetchTrackNames);
      return await useCase.execute(forceRefresh);
    });
    require$$1$2.ipcMain.handle("config:get", async () => {
      const useCase = this.container.get(TYPES.GetConfig);
      return await useCase.execute();
    });
    require$$1$2.ipcMain.handle("config:update", async (_2, input) => {
      const useCase = this.container.get(TYPES.UpdateConfig);
      return await useCase.execute(input);
    });
    require$$1$2.ipcMain.handle("osc:test", async () => {
      const useCase = this.container.get(TYPES.TestOscConnection);
      return await useCase.execute();
    });
    require$$1$2.ipcMain.handle("osc:connect", async () => {
      const oscService = this.container.get(TYPES.OscOutputService);
      const config = this.container.get(TYPES.GetConfig);
      const configResult = await config.execute();
      if (configResult.isFailure()) {
        return configResult;
      }
      return oscService.connect(configResult.value.oscHost, configResult.value.oscPort);
    });
  }
  /**
   * Set up MIDI input processing
   */
  setupMidiProcessing(webContents) {
    const midiService = this.container.get(TYPES.MidiInputService);
    const processMidiInput = this.container.get(TYPES.ProcessMidiInput);
    midiService.onMessage(async (message) => {
      await processMidiInput.execute(message);
      webContents.send("midi:message", {
        type: message.type,
        data: message.data.toJSON()
      });
    });
  }
}
let mainWindow = null;
let trayController = null;
function createWindow() {
  mainWindow = new require$$1$2.BrowserWindow({
    width: 1200,
    height: 800,
    show: false,
    // Don't show until ready
    webPreferences: {
      preload: require$$0__namespace.join(__dirname, "../preload/index.js"),
      contextIsolation: true,
      nodeIntegration: false
    }
  });
  if (process.env.NODE_ENV === "development") {
    mainWindow.loadURL("http://localhost:5173");
    mainWindow.webContents.openDevTools();
  } else {
    mainWindow.loadFile(require$$0__namespace.join(__dirname, "../renderer/index.html"));
  }
  mainWindow.once("ready-to-show", () => {
    mainWindow?.show();
  });
  mainWindow.on("close", (event) => {
    if (!require$$1$2.app.isQuitting) {
      event.preventDefault();
      mainWindow?.hide();
    }
  });
  mainWindow.on("closed", () => {
    mainWindow = null;
  });
}
async function initialize() {
  const container = createContainer();
  const ipcHandlers = new IpcHandlers(container);
  ipcHandlers.register();
  createWindow();
  if (mainWindow) {
    ipcHandlers.setupMidiProcessing(mainWindow.webContents);
  }
  if (mainWindow) {
    trayController = new TrayController(mainWindow);
    trayController.create();
  }
  try {
    const configRepo = container.get(TYPES.ConfigRepository);
    const oscService = container.get(TYPES.OscOutputService);
    const configResult = await configRepo.get();
    if (configResult.isSuccess()) {
      const { oscHost, oscPort, autoReconnect } = configResult.value;
      if (autoReconnect) {
        const connectResult = oscService.connect(oscHost, oscPort);
        if (connectResult.isSuccess()) {
          console.log(`Connected to OSC at ${oscHost}:${oscPort}`);
        } else {
          console.error("Failed to connect to OSC:", connectResult.error.message);
        }
      }
    }
  } catch (error2) {
    console.error("Error during initialization:", error2);
  }
}
require$$1$2.app.whenReady().then(initialize);
require$$1$2.app.on("before-quit", () => {
  require$$1$2.app.isQuitting = true;
});
require$$1$2.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$1$2.app.quit();
  }
});
require$$1$2.app.on("activate", () => {
  if (require$$1$2.BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  } else if (mainWindow) {
    mainWindow.show();
  }
});
require$$1$2.app.on("will-quit", () => {
  if (trayController) {
    trayController.destroy();
  }
});
